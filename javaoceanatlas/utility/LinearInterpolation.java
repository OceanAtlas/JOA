/* * $Id: Interpolation.java,v 1.8 2005/06/17 18:10:58 oz Exp $ * */package javaoceanatlas.utility;import org.w3c.dom.*;import com.fasterxml.jackson.core.JsonEncoding;import com.fasterxml.jackson.core.JsonFactory;import com.fasterxml.jackson.core.JsonGenerator;import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;import gov.noaa.pmel.sgt.contour.ZGrid;import java.util.*;import javaoceanatlas.classicdatamodel.*;import javaoceanatlas.resources.*;import javaoceanatlas.ui.*;import java.io.File;import java.io.IOException;public class LinearInterpolation implements Interpolation {	protected int mInterpolationType = LOCAL_INTERPOLATION;	protected double[][] mValues = null;	protected double[] mDistValues = null;	protected double[] mMeanValues = null;	protected double[] mBottomDepths = null;	protected int mNumLevels;	protected int mNumStns;	protected JOAVariable mInterpParam;	protected int mSurfaceParamNum;	protected NewInterpolationSurface mSurface;	protected String mName;	protected String mParam;	protected double mRefLevel;	protected boolean mTopDown;	protected FileViewer mFileViewer;	public static int MINUS = -1;	public static int PLUS = +1;	public static int ZERO = 0;	protected int mTotalStns;	protected double[] mSurfaceValues = null;	protected int mFarStationLimit;	protected int mFarBottleLimit;	protected int mFarStdLevelLimit;	protected boolean mUseFarFieldLimit;	protected double mFarFieldLimit;	protected int mNumBottles;	protected int mNumCasts;	protected double mMin = JOAConstants.MISSINGVALUE;	protected double mMax = JOAConstants.MISSINGVALUE;	protected boolean[] mMeanCastStnList = null;	protected boolean mIsResidualInterp = false;	protected String mSurfaceFileName;	protected boolean mFillEdges = false;	protected boolean mClipExtrapolatedValues = true;	private double mClipMin;	private double mClipMax;	private UVCoordinate[] mMeanCastValuesFromFile;	private boolean mUseMeanCastValuesFromFile = false;	private double[] mLatValues;	private double[] mLonValues;	private String[] mStnValues;	String mMeanCastFV;	private boolean mLocked = false;	public LinearInterpolation(LinearInterpolation interpIn) {		mInterpolationType = interpIn.mInterpolationType;		mFileViewer = interpIn.mFileViewer;		mTotalStns = mFileViewer.mTotalStations;		mSurface = new NewInterpolationSurface(interpIn.mSurface);		mSurfaceFileName = new String(interpIn.mSurfaceFileName);		mInterpParam = interpIn.mInterpParam;		mSurfaceParamNum = interpIn.mSurfaceParamNum;		mName = new String(interpIn.mName);		mParam = new String(interpIn.mParam);		mRefLevel = interpIn.mRefLevel;		mTopDown = interpIn.mTopDown;		mNumLevels = interpIn.mSurface.getNumLevels();		mSurfaceValues = new double[mNumLevels];		double[] inVals = mSurface.getValues();		for (int i = 0; i < mNumLevels; i++) {			mSurfaceValues[i] = inVals[i];		}		mNumCasts = interpIn.mNumCasts;		mNumBottles = interpIn.mNumBottles;		mIsResidualInterp = interpIn.mIsResidualInterp;		mMeanCastStnList = interpIn.mMeanCastStnList;		mFillEdges = interpIn.mFillEdges;		mClipExtrapolatedValues = interpIn.mClipExtrapolatedValues;		mFarBottleLimit = interpIn.mFarBottleLimit;		mUseFarFieldLimit = interpIn.mUseFarFieldLimit;		mFarFieldLimit = interpIn.mFarFieldLimit;		mFarStdLevelLimit = interpIn.mFarStdLevelLimit;		mFarStationLimit = interpIn.mFarStationLimit;		mMeanCastValuesFromFile = interpIn.mMeanCastValuesFromFile;		if (mMeanCastValuesFromFile != null) {			mUseMeanCastValuesFromFile = true;		}		// create the arrays		mValues = new double[128][mTotalStns];		mDistValues = new double[mTotalStns];		mBottomDepths = new double[mTotalStns];		mLatValues = new double[mTotalStns];		mLonValues = new double[mTotalStns];		mStnValues = new String[mTotalStns];		// compute the distances between casts		computeDistances();		doInterp(true);	}	public LinearInterpolation(FileViewer fv, String surfaceFileName, NewInterpolationSurface surface,	    JOAVariable interpParam, int surfaceParamNum, String name, String param, boolean topDown, int interpolationType,	    boolean fillEdges, boolean clipExtrapolation, int farBottleLimit, int farStdLevelLimit, int farStationLimit,	    boolean useFarFieldLimit, double farFieldLimit) {		this(fv, surfaceFileName, surface, interpParam, surfaceParamNum, name, param, Double.NaN, topDown,		    interpolationType, fillEdges, clipExtrapolation, farBottleLimit, farStdLevelLimit, farStationLimit,		    useFarFieldLimit, farFieldLimit, false, null, null, null);	}	public LinearInterpolation(FileViewer fv, String surfaceFileName, NewInterpolationSurface surface,	    JOAVariable interpParam, int surfaceParamNum, String name, String param, double refLevel, boolean topDown,	    int interpolationType, boolean fillEdges, boolean clipExtrapolation, int farBottleLimit, int farStdLevelLimit,	    int farStationLimit, boolean useFarFieldLimit, double farFieldLimit, boolean isResidualInterp,	    boolean[] meanStnList, UVCoordinate[] meanCastValuesFromFile, String meanCastFV) {		mFileViewer = fv;		mSurfaceFileName = surfaceFileName;		mTotalStns = mFileViewer.mTotalStations;		mSurface = new NewInterpolationSurface(surface);		mInterpolationType = interpolationType;		mInterpParam = interpParam;		mSurfaceParamNum = surfaceParamNum;		mName = new String(name);		mParam = new String(param);		mRefLevel = refLevel;		mTopDown = topDown;		mNumLevels = mSurface.getNumLevels();		mSurfaceValues = new double[mNumLevels];		double[] inVals = mSurface.getValues();		for (int i = 0; i < mNumLevels; i++) {			mSurfaceValues[i] = inVals[i];		}		mIsResidualInterp = isResidualInterp;		mMeanCastStnList = meanStnList;		mFillEdges = fillEdges;		mClipExtrapolatedValues = clipExtrapolation;		mFarBottleLimit = farBottleLimit;		mUseFarFieldLimit = useFarFieldLimit;		mFarFieldLimit = farFieldLimit;		mFarStdLevelLimit = farStdLevelLimit;		mFarStationLimit = farStationLimit;		mMeanCastValuesFromFile = meanCastValuesFromFile;		if (mMeanCastValuesFromFile != null) {			mUseMeanCastValuesFromFile = true;			mMeanCastValuesFromFile = meanCastValuesFromFile;			mMeanCastFV = meanCastFV;		}		// create the arrays		mValues = new double[128][mTotalStns];		mDistValues = new double[mTotalStns];		mMeanValues = new double[128];		mBottomDepths = new double[mTotalStns];		mLatValues = new double[mTotalStns];		mLonValues = new double[mTotalStns];		mStnValues = new String[mTotalStns];		// compute the distances between casts		computeDistances();		doInterp(false);	}	public void saveAsXML(FileViewer fv, Document doc, Element root, Element item) {		item.setAttribute("intertype", String.valueOf(mInterpolationType));		item.setAttribute("interpname", mName);		item.setAttribute("surfacepname", mSurfaceFileName);		item.setAttribute("interpvariable", mInterpParam.getVarName());		item.setAttribute("surfacevariable", fv.mAllProperties[mSurfaceParamNum].mVarLabel);		item.setAttribute("parameter", mParam);		item.setAttribute("reflevel", String.valueOf(mRefLevel));		item.setAttribute("topdown", String.valueOf(mTopDown));		item.setAttribute("numcasts", String.valueOf(mNumCasts));		item.setAttribute("usefarfieldlimit", String.valueOf(mUseFarFieldLimit));		item.setAttribute("farfieldlimit", String.valueOf(mUseFarFieldLimit));		item.setAttribute("farbottle", String.valueOf(mFarBottleLimit));		item.setAttribute("isfilledges", String.valueOf(mFillEdges));		item.setAttribute("isclipextrapolated", String.valueOf(mClipExtrapolatedValues));		item.setAttribute("isresidualinterp", String.valueOf(mIsResidualInterp));		root.appendChild(item);		if (mIsResidualInterp) {			Element item2 = doc.createElement("meancastvalues");			for (int i = 0; i < mMeanValues.length; i++) {				Element valItem = doc.createElement("value");				valItem.appendChild(doc.createTextNode(String.valueOf(mMeanValues[i])));				item2.appendChild(valItem);			}			root.appendChild(item2);		}	}	public void redimensionInterpolation() {		mValues = null;		mDistValues = null;		mTotalStns = mFileViewer.mTotalStations;		mValues = new double[128][mTotalStns];		mDistValues = new double[mTotalStns];		mBottomDepths = new double[mTotalStns];		mLatValues = new double[mTotalStns];		mLonValues = new double[mTotalStns];		mStnValues = new String[mTotalStns];		computeDistances();	}	private class VirtualBottle {		double mInterpValue;		double mSurfValue;		double mWeight;		public VirtualBottle(double ival, double sval, double weight) {			mInterpValue = ival;			mSurfValue = sval;			mWeight = weight;		}	}	public void computeDistances() {		int stCount = 0;		for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {			OpenDataFile of = (OpenDataFile) mFileViewer.mOpenFiles.elementAt(fc);			for (int sec = 0; sec < of.mNumSections; sec++) {				Section sech = (Section) of.mSections.elementAt(sec);				if (sech.mNumCasts == 0) {					continue;				}				for (int stc = 0; stc < sech.mStations.size(); stc++) {					Station sh = (Station) sech.mStations.elementAt(stc);					if (!sh.mUseStn) {						continue;					}					mDistValues[stCount] = sh.mCumDist;					mBottomDepths[stCount] = sh.mBottomDepthInDBARS;					mLatValues[stCount] = sh.getLat();					mLonValues[stCount] = sh.getLon();					mStnValues[stCount] = sh.getStn();					stCount++;				}			}		}	}		public void farFieldDown() {		// initialize some constants		double physHigh, physLow, interpLow, interpHigh, delta;		int newSign, oldSign;		boolean doIt = false;		// mean cast collector		double[] levelSum = new double[mNumLevels];		int[] levelCount = new int[mNumLevels];		int stnCnt = -1;		if (mIsResidualInterp && !mUseMeanCastValuesFromFile) {			for (int iz = 0; iz < mNumLevels; iz++) {				levelSum[iz] = 0;				levelCount[iz] = 0;			}		}		// if (mIsResidualInterp && mUseMeanCastValuesFromFile) {		// for (int iz=0; iz<mNumLevels; iz++) {		// System.out.println(mMeanCastValuesFromFile[iz].getU() + " " +		// mMeanCastValuesFromFile[iz].getV());		// }		// }		// set the extrapolate clip values		mClipMin = mFileViewer.mAllProperties[mInterpParam.getVariablePos()].mPlotMin;		mClipMax = mFileViewer.mAllProperties[mInterpParam.getVariablePos()].mPlotMax;		// begin the new interpolater		// collect up the stations to use (ones not filtered out)		Vector<SectionStation> inUseStations = new Vector<SectionStation>(200);		for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {			OpenDataFile of = (OpenDataFile) mFileViewer.mOpenFiles.elementAt(fc);			// loop over the sections			for (int sec = 0; sec < of.mNumSections; sec++) {				Section sech = (Section) of.mSections.elementAt(sec);				if (sech.mNumCasts == 0) {					continue;				}				int iPos = sech.getVarPos(mInterpParam.getVarName(), false);				int sPos = sech.getVarPos(mFileViewer.mAllProperties[mSurfaceParamNum].mVarLabel, false);				if (iPos < 0 || sPos < 0) {					continue;				}				// loop over the stations				int numStns = sech.mStations.size();				for (int stc = 0; stc < numStns; stc++) {					Station sh = (Station) sech.mStations.elementAt(stc);					if (sh.mNumBottles == 0) {						continue;					}					if (sh.mUseStn) {						// a useable station						inUseStations.addElement(new SectionStation(sh, sech, stnCnt));						stnCnt++;					}				}			}		}		// loop over the collected stations		int stnCount = 0;		int numStns = inUseStations.size();		double c1Val = JOAConstants.MISSINGVALUE;		double c2Val = JOAConstants.MISSINGVALUE;		double c3Val = JOAConstants.MISSINGVALUE;		double c4Val = JOAConstants.MISSINGVALUE;		int c1Pos = JOAConstants.MISSINGVALUE;		int c2Pos = JOAConstants.MISSINGVALUE;		int c3Pos = JOAConstants.MISSINGVALUE;		int c4Pos = JOAConstants.MISSINGVALUE;		VirtualBottle[] vBotts = new VirtualBottle[5000];		for (int stc = 0; stc < numStns; stc++) {			SectionStation secStn = (SectionStation) inUseStations.elementAt(stc);			Section sech = secStn.getSection();			int iPos = sech.getVarPos(mInterpParam.getVarName(), false);			int sPos = sech.getVarPos(mFileViewer.mAllProperties[mSurfaceParamNum].mVarLabel, false);			if (mFileViewer.mObsFilterActive) {				if (mFileViewer.mCurrObsFilter.isCriteria1Active()) {					c1Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(0)].getVarLabel(),					    false);				}				if (mFileViewer.mCurrObsFilter.isCriteria2Active()) {					c2Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(1)].getVarLabel(),					    false);				}				if (mFileViewer.mCurrObsFilter.isCriteria3Active()) {					c3Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(2)].getVarLabel(),					    false);				}				if (mFileViewer.mCurrObsFilter.isCriteria4Active()) {					c4Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(3)].getVarLabel(),					    false);				}			}			// create the virtual cast			int numBotts = secStn.mNumBottles;			// add all the "real" bottles for the station (will sort this later to put			// the virtual bottles in order)			// apply the observation filter first			Vector<Bottle> usedBottles = filterCast(secStn, sech);			int numUsedBottles = usedBottles.size();			int c = 0;			for (int b = 0; b < numUsedBottles; b++) {				Bottle bh = (Bottle) usedBottles.elementAt(b);				// add the values to new virtual bottle--don't add any real bottles that				// have missing data				if (bh == null || bh.mDValues[iPos] == JOAConstants.MISSINGVALUE				    || bh.mDValues[sPos] == JOAConstants.MISSINGVALUE) {					continue;				}				VirtualBottle vbh = new VirtualBottle(bh.mDValues[iPos], bh.mDValues[sPos], 1.00);				if (vbh != null) {					vBotts[c++] = vbh;				}			}			numBotts = c;			// figure out the indices of the bounding stations			int realFarStationLimit = mFarStationLimit;			while (realFarStationLimit > 0) {				if (stc < realFarStationLimit || stc >= numStns - realFarStationLimit) {					realFarStationLimit--;					continue;				}				break;			}			// now create virtual bottles			int[] prevStns = new int[realFarStationLimit];			int[] nextStns = new int[realFarStationLimit];			for (int r = 0; r < realFarStationLimit; r++) {				prevStns[r] = stc - (r + 1);				nextStns[r] = stc + (r + 1);			}			for (int s = 0; s < realFarStationLimit; s++) {				// pairs of stations are				SectionStation prevStn = (SectionStation) inUseStations.elementAt(prevStns[s]);				SectionStation nextStn = (SectionStation) inUseStations.elementAt(nextStns[s]);				if (mUseFarFieldLimit) {					double diff1 = Math.abs(secStn.mFoundStn.mCumDist - prevStn.mFoundStn.mCumDist);					double diff2 = Math.abs(secStn.mFoundStn.mCumDist - nextStn.mFoundStn.mCumDist);					if (diff1 > mFarFieldLimit || diff2 > mFarFieldLimit) {						break;					}				}				Section prevSec = prevStn.getSection();				Section nextSec = nextStn.getSection();				int prevSPos = prevSec.getVarPos(mFileViewer.mAllProperties[mSurfaceParamNum].mVarLabel, false);				int nextSPos = nextSec.getVarPos(mFileViewer.mAllProperties[mSurfaceParamNum].mVarLabel, false);				double nextDist = nextStn.mFoundStn.mCumDist;				double prevDist = prevStn.mFoundStn.mCumDist;				Vector<Bottle> prevBottles = filterCast(prevStn, prevSec);				Vector<Bottle> nextBottles = filterCast(nextStn, nextSec);				double deltaDist = nextDist - prevDist;				double del = secStn.mFoundStn.mCumDist - prevDist;				for (int b = 0; b < prevBottles.size(); b++) {					// make the virtual bottles					Bottle pbh = (Bottle) prevBottles.elementAt(b);					double sval = pbh.mDValues[prevSPos];					// look for the closest matching bottle in nextStn					Bottle nbh = findClosestBottle(nextBottles, sval, nextSPos);					if (nbh != null) {						// make a new virtual bottle						double surfVal = nbh.mDValues[sPos];						double prevSurfVal = pbh.mDValues[sPos];						double interpVal = nbh.mDValues[iPos];						double prevInterpVal = pbh.mDValues[iPos];						double iSlope = (interpVal - prevInterpVal) / deltaDist;						double sSlope = (surfVal - prevSurfVal) / deltaDist;						double predictedSurfVal = sSlope * del + pbh.mDValues[sPos];						double predictedInterpVal = iSlope * del + pbh.mDValues[iPos];						if (mClipExtrapolatedValues && predictedInterpVal > mClipMax) {							predictedInterpVal = mClipMax;						}						else if (mClipExtrapolatedValues && predictedInterpVal < mClipMin) {							predictedInterpVal = mClipMin;						}						if (prevInterpVal != JOAConstants.MISSINGVALUE && interpVal != JOAConstants.MISSINGVALUE						    && surfVal != JOAConstants.MISSINGVALUE && prevSurfVal != JOAConstants.MISSINGVALUE) {							// make the interpolated values for the obsfilter values							if (mFileViewer.mObsFilterActive) {								if (mFileViewer.mCurrObsFilter.isCriteria1Active()) {									interpVal = nbh.mDValues[c1Pos];									prevInterpVal = pbh.mDValues[c1Pos];									iSlope = (interpVal - prevInterpVal) / deltaDist;									sSlope = (surfVal - prevSurfVal) / deltaDist;									predictedSurfVal = sSlope * del + pbh.mDValues[sPos];									c1Val = iSlope * del + pbh.mDValues[c1Pos];									if (mClipExtrapolatedValues && c1Val > mClipMax) {										c1Val = mClipMax;									}									else if (mClipExtrapolatedValues && c1Val < mClipMin) {										c1Val = mClipMin;									}								}								if (mFileViewer.mCurrObsFilter.isCriteria2Active()) {									interpVal = nbh.mDValues[c2Pos];									prevInterpVal = pbh.mDValues[c2Pos];									iSlope = (interpVal - prevInterpVal) / deltaDist;									sSlope = (surfVal - prevSurfVal) / deltaDist;									predictedSurfVal = sSlope * del + pbh.mDValues[sPos];									c2Val = iSlope * del + pbh.mDValues[c2Pos];									if (mClipExtrapolatedValues && c2Val > mClipMax) {										c2Val = mClipMax;									}									else if (mClipExtrapolatedValues && c2Val < mClipMin) {										c2Val = mClipMin;									}								}								if (mFileViewer.mCurrObsFilter.isCriteria3Active()) {									interpVal = nbh.mDValues[c3Pos];									prevInterpVal = pbh.mDValues[c3Pos];									iSlope = (interpVal - prevInterpVal) / deltaDist;									sSlope = (surfVal - prevSurfVal) / deltaDist;									predictedSurfVal = sSlope * del + pbh.mDValues[sPos];									c3Val = iSlope * del + pbh.mDValues[c3Pos];									if (mClipExtrapolatedValues && c3Val > mClipMax) {										c3Val = mClipMax;									}									else if (mClipExtrapolatedValues && c3Val < mClipMin) {										c3Val = mClipMin;									}								}								if (mFileViewer.mCurrObsFilter.isCriteria4Active()) {									interpVal = nbh.mDValues[c4Pos];									prevInterpVal = pbh.mDValues[c4Pos];									iSlope = (interpVal - prevInterpVal) / deltaDist;									sSlope = (surfVal - prevSurfVal) / deltaDist;									predictedSurfVal = sSlope * del + pbh.mDValues[sPos];									c4Val = iSlope * del + pbh.mDValues[c4Pos];									if (mClipExtrapolatedValues && c4Val > mClipMax) {										c4Val = mClipMax;									}									else if (mClipExtrapolatedValues && c4Val < mClipMin) {										c4Val = mClipMin;									}								}								if (mFileViewer.mCurrObsFilter.testValues(c1Val, c2Val, c3Val, c4Val)) {									vBotts[numBotts++] = new VirtualBottle(predictedInterpVal, predictedSurfVal, 1.0 / (double) s);								}							}							else {								vBotts[numBotts++] = new VirtualBottle(predictedInterpVal, predictedSurfVal, 1.0 / (double) s);							}						}					}				}			}			// sort the virtual cast (vBotts)			for (int i = 0; i < numBotts - 1; i++) {				VirtualBottle vbh = vBotts[i];				for (int j = i + 1; j < numBotts; j++) {					VirtualBottle vbhp1 = vBotts[j];					double surfVal = vbh.mSurfValue;					double surfValP1 = vbhp1.mSurfValue;					if (surfVal > surfValP1) {						// swap the bottles						double tval = vbh.mSurfValue;						vbh.mSurfValue = vbhp1.mSurfValue;						vbhp1.mSurfValue = tval;						tval = vbh.mInterpValue;						vbh.mInterpValue = vbhp1.mInterpValue;						vbhp1.mInterpValue = tval;						tval = vbh.mWeight;						vbh.mWeight = vbhp1.mWeight;						vbhp1.mWeight = tval;					}				}			}			// for (int i=0; i<numBotts; i++) {;			// VirtualBottle vbh = vBotts[i];			// System.out.println(i + " vbh.mSurfValue = " + vbh.mSurfValue + "			// vbh.mInterpValue = " + vbh.mInterpValue);			// }			// do the actual interpolation onto standard levels			if (numBotts > 0) {				for (int iz = 0; iz < mNumLevels; iz++) {					mValues[iz][stnCount] = JOAConstants.MISSINGVALUE;					// initialize the sign variable from first bottle					VirtualBottle vbh = vBotts[0];					physHigh = vbh.mSurfValue;					delta = physHigh - mSurfaceValues[iz];					oldSign = 0;					if (delta > 0) {						oldSign = PLUS;					}					else if (delta < 0) {						oldSign = MINUS;					}					else {						oldSign = ZERO;					}					doIt = false;					// loop over the virtual bottles					for (int bb = 0; bb < numBotts; bb++) {						vbh = vBotts[bb];						// consider only real bottles						if (vbh.mWeight < 1.0) {							continue;						}						double val = vbh.mSurfValue;						if (val != JOAConstants.MISSINGVALUE) {							physHigh = val;							doIt = true;						}						if (doIt) {							delta = physHigh - mSurfaceValues[iz];							if (delta > 0) {								newSign = PLUS;							}							else if (delta < 0) {								newSign = MINUS;							}							else {								newSign = ZERO;							}							if (newSign == ZERO) {								// bottle and level are the same								if (vbh.mInterpValue != JOAConstants.MISSINGVALUE) {									mValues[iz][stnCount] = vbh.mInterpValue;									if (mValues[iz][stnCount] == 0.0) {										if (mIsResidualInterp && !mUseMeanCastValuesFromFile && mMeanCastStnList != null										    && mMeanCastStnList[stnCount]) {											levelSum[iz] += mValues[iz][stnCount];											levelCount[iz]++;										}									}									break;								}							}							else if (oldSign != newSign && bb > 0) {								// sign changes								int bbb = bb - 1;								VirtualBottle prevVBh = null;								int usl;								if (iz - mFarStdLevelLimit > 0) {									usl = iz - mFarStdLevelLimit;								}								else {									usl = 0;								}								double upperSurfLimit = mSurfaceValues[usl];								while (true) {									// search for a non missing value above current bottle									prevVBh = vBotts[bbb--];									if (bbb <= 0) {										bbb = 0;										break;									}									double surfVal = prevVBh.mSurfValue;									if (surfVal <= upperSurfLimit) {										break;									}								}								// range is from bb up bbb								double maxWeight = 0.0;								int useVBott = 0;								for (int vb = bb - 1; vb > bbb; vb--) {									prevVBh = vBotts[vb];									if (prevVBh.mWeight == 1.0) {										useVBott = vb;										break;									}									else if (prevVBh.mWeight > maxWeight) {										maxWeight = prevVBh.mWeight;										useVBott = vb;									}								}								prevVBh = vBotts[useVBott];								if (vbh.mInterpValue != JOAConstants.MISSINGVALUE && prevVBh.mInterpValue != JOAConstants.MISSINGVALUE) {									physLow = prevVBh.mSurfValue;									interpLow = vbh.mInterpValue;									interpHigh = prevVBh.mInterpValue;									mValues[iz][stnCount] = (delta / (physHigh - physLow)) * (interpHigh - interpLow) + interpLow;									if (mClipExtrapolatedValues && mValues[iz][stnCount] > mClipMax) {										mValues[iz][stnCount] = mClipMax;									}									else if (mClipExtrapolatedValues && mValues[iz][stnCount] < mClipMin) {										mValues[iz][stnCount] = mClipMin;									}									if (mIsResidualInterp && !mUseMeanCastValuesFromFile && mMeanCastStnList != null									    && mMeanCastStnList[stnCount]) {										levelSum[iz] += mValues[iz][stnCount];										levelCount[iz]++;									}								}								break;							}						}					}				}				stnCount++;			}			else {				for (int iz = 0; iz < mNumLevels; iz++) {					mValues[iz][stc] = JOAConstants.MISSINGVALUE;				}			}		}				processBottom();		if (mFillEdges) {			processEdgesVertical(stnCnt);			processEdges(stnCnt);		}		// compute the mean cast		if (mIsResidualInterp) {			for (int iz = 0; iz < mNumLevels; iz++) {				if (!mUseMeanCastValuesFromFile) {					// use computed values					if (levelCount[iz] >= 1) {						mMeanValues[iz] = levelSum[iz] / (double) levelCount[iz];						for (int s = 0; s < stnCnt + 1; s++) {							if (mValues[iz][s] != JOAConstants.MISSINGVALUE) {								mValues[iz][s] -= mMeanValues[iz];							}						}					}					else {						for (int s = 0; s < stnCnt; s++) {							mValues[iz][s] = JOAConstants.MISSINGVALUE;						}					}				}				else {					// use mean cast from external file					double meanVal = mMeanCastValuesFromFile[iz].getV();					for (int s = 0; s < stnCnt + 1; s++) {						if (mValues[iz][s] != JOAConstants.MISSINGVALUE && meanVal != JOAConstants.MISSINGVALUE) {							mValues[iz][s] -= meanVal;						}						else {							mValues[iz][s] = JOAConstants.MISSINGVALUE;						}					}				}			}		}	}	public void farFieldUp() {		// initialize some constants		double surfHigh, surfLow, interpLow, interpHigh, delta;		int newSign, oldSign;		// mean cast collector		double[] levelSum = new double[mNumLevels];		int[] levelCount = new int[mNumLevels];		int stnCnt = -1;		if (mIsResidualInterp && !mUseMeanCastValuesFromFile) {			for (int iz = 0; iz < mNumLevels; iz++) {				levelSum[iz] = 0;				levelCount[iz] = 0;			}		}		// set the extrapolate clip values		mClipMin = mFileViewer.mAllProperties[mInterpParam.getVariablePos()].mPlotMin;		mClipMax = mFileViewer.mAllProperties[mInterpParam.getVariablePos()].mPlotMax;		// begin the new interpolater		// collect up the stations to use (ones not filtered out)		Vector<SectionStation> inUseStations = new Vector<SectionStation>(200);		stnCnt = 0;		for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {			OpenDataFile of = (OpenDataFile) mFileViewer.mOpenFiles.elementAt(fc);			// loop over the sections			for (int sec = 0; sec < of.mNumSections; sec++) {				Section sech = (Section) of.mSections.elementAt(sec);				if (sech.mNumCasts == 0) {					continue;				}				int iPos = sech.getVarPos(mInterpParam.getVarName(), false);				int sPos = sech.getVarPos(mFileViewer.mAllProperties[mSurfaceParamNum].mVarLabel, false);				if (iPos < 0 || sPos < 0) {					continue;				}				// loop over the stations				int numStns = sech.mStations.size();				for (int stc = 0; stc < numStns; stc++) {					Station sh = (Station) sech.mStations.elementAt(stc);					if (sh.mNumBottles == 0) {						continue;					}					if (sh.mUseStn) {						// a useable station						inUseStations.addElement(new SectionStation(sh, sech, stnCnt));						stnCnt++;					}				}			}		}		// loop over the collected station		int stnCount = 0;		int numStns = inUseStations.size();		double c1Val = JOAConstants.MISSINGVALUE;		double c2Val = JOAConstants.MISSINGVALUE;		double c3Val = JOAConstants.MISSINGVALUE;		double c4Val = JOAConstants.MISSINGVALUE;		int c1Pos = JOAConstants.MISSINGVALUE;		int c2Pos = JOAConstants.MISSINGVALUE;		int c3Pos = JOAConstants.MISSINGVALUE;		int c4Pos = JOAConstants.MISSINGVALUE;		VirtualBottle[] vBotts = new VirtualBottle[5000];		for (int stc = 0; stc < numStns; stc++) {			SectionStation secStn = (SectionStation) inUseStations.elementAt(stc);			Section sech = secStn.getSection();			int iPos = sech.getVarPos(mInterpParam.getVarName(), false);			int sPos = sech.getVarPos(mFileViewer.mAllProperties[mSurfaceParamNum].mVarLabel, false);			if (mFileViewer.mObsFilterActive) {				if (mFileViewer.mCurrObsFilter.isCriteria1Active()) {					c1Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(0)].getVarLabel(),					    false);				}				if (mFileViewer.mCurrObsFilter.isCriteria2Active()) {					c2Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(1)].getVarLabel(),					    false);				}				if (mFileViewer.mCurrObsFilter.isCriteria3Active()) {					c3Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(2)].getVarLabel(),					    false);				}				if (mFileViewer.mCurrObsFilter.isCriteria4Active()) {					c4Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(3)].getVarLabel(),					    false);				}			}			// create the virtual cast			int numBotts = secStn.mNumBottles;			// add all the "real" bottles for the station (will sort this later to put			// the virtual bottles in order)			// apply the observation filter first			Vector<Bottle> usedBottles = filterCast(secStn, sech);			int numUsedBottles = usedBottles.size();			int c = 0;			for (int b = 0; b < numUsedBottles; b++) {				Bottle bh = (Bottle) usedBottles.elementAt(b);				// add the values to new virtual bottle--don't add any real bottles that				// have missing data				if (bh != null				    && !(bh.mDValues[iPos] == JOAConstants.MISSINGVALUE || bh.mDValues[sPos] == JOAConstants.MISSINGVALUE)) {					VirtualBottle vbh = new VirtualBottle(bh.mDValues[iPos], bh.mDValues[sPos], 1.00);					if (vbh != null) {						vBotts[c++] = vbh;					}				}			}			numBotts = c;			// figure out the indices of the bounding stations			int realFarStationLimit = mFarStationLimit;			while (realFarStationLimit > 0) {				if (stc < realFarStationLimit || stc >= numStns - realFarStationLimit) {					realFarStationLimit--;					continue;				}				break;			}			// now create virtual bottles			int[] prevStns = new int[realFarStationLimit];			int[] nextStns = new int[realFarStationLimit];			for (int r = 0; r < realFarStationLimit; r++) {				prevStns[r] = stc - (r + 1);				nextStns[r] = stc + (r + 1);			}			for (int s = 0; s < realFarStationLimit; s++) {				// pais of stations are				SectionStation prevStn = (SectionStation) inUseStations.elementAt(prevStns[s]);				SectionStation nextStn = (SectionStation) inUseStations.elementAt(nextStns[s]);				if (mUseFarFieldLimit) {					double diff1 = Math.abs(secStn.mFoundStn.mCumDist - prevStn.mFoundStn.mCumDist);					double diff2 = Math.abs(secStn.mFoundStn.mCumDist - nextStn.mFoundStn.mCumDist);					if (diff1 > mFarFieldLimit || diff2 > mFarFieldLimit) {						break;					}				}				Section prevSec = prevStn.getSection();				Section nextSec = nextStn.getSection();				int prevSPos = prevSec.getVarPos(mFileViewer.mAllProperties[mSurfaceParamNum].mVarLabel, false);				int nextSPos = nextSec.getVarPos(mFileViewer.mAllProperties[mSurfaceParamNum].mVarLabel, false);				double nextDist = nextStn.mFoundStn.mCumDist;				double prevDist = prevStn.mFoundStn.mCumDist;				Vector<Bottle> prevBottles = filterCast(prevStn, prevSec);				Vector<Bottle> nextBottles = filterCast(nextStn, nextSec);				double deltaDist = nextDist - prevDist;				double del = secStn.mFoundStn.mCumDist - prevDist;				for (int b = 0; b < prevBottles.size(); b++) {					// make the virtual bottles					Bottle pbh = (Bottle) prevBottles.elementAt(b);					double sval = pbh.mDValues[prevSPos];					// look for the closest matching bottle in nextStn					Bottle nbh = findClosestBottle(nextBottles, sval, nextSPos);					if (nbh != null) {						// make a new virtual bottle						double surfVal = nbh.mDValues[sPos];						double prevSurfVal = pbh.mDValues[sPos];						double interpVal = nbh.mDValues[iPos];						double prevInterpVal = pbh.mDValues[iPos];						double iSlope = (interpVal - prevInterpVal) / deltaDist;						double sSlope = (surfVal - prevSurfVal) / deltaDist;						double predictedSurfVal = sSlope * del + pbh.mDValues[sPos];						double predictedInterpVal = iSlope * del + pbh.mDValues[iPos];						if (mClipExtrapolatedValues && predictedInterpVal > mClipMax) {							predictedInterpVal = mClipMax;						}						else if (mClipExtrapolatedValues && predictedInterpVal < mClipMin) {							predictedInterpVal = mClipMin;						}						if (prevInterpVal != JOAConstants.MISSINGVALUE && interpVal != JOAConstants.MISSINGVALUE						    && surfVal != JOAConstants.MISSINGVALUE && prevSurfVal != JOAConstants.MISSINGVALUE) {							// make the interpolated values for the obsfilter values							if (mFileViewer.mObsFilterActive) {								if (mFileViewer.mCurrObsFilter.isCriteria1Active()) {									interpVal = nbh.mDValues[c1Pos];									prevInterpVal = pbh.mDValues[c1Pos];									iSlope = (interpVal - prevInterpVal) / deltaDist;									sSlope = (surfVal - prevSurfVal) / deltaDist;									predictedSurfVal = sSlope * del + pbh.mDValues[sPos];									c1Val = iSlope * del + pbh.mDValues[c1Pos];									if (mClipExtrapolatedValues && predictedInterpVal > mClipMax) {										predictedInterpVal = mClipMax;									}									else if (mClipExtrapolatedValues && predictedInterpVal < mClipMin) {										predictedInterpVal = mClipMin;									}								}								if (mFileViewer.mCurrObsFilter.isCriteria2Active()) {									interpVal = nbh.mDValues[c2Pos];									prevInterpVal = pbh.mDValues[c2Pos];									iSlope = (interpVal - prevInterpVal) / deltaDist;									sSlope = (surfVal - prevSurfVal) / deltaDist;									predictedSurfVal = sSlope * del + pbh.mDValues[sPos];									c2Val = iSlope * del + pbh.mDValues[c2Pos];									if (mClipExtrapolatedValues && c2Val > mClipMax) {										c2Val = mClipMax;									}									else if (mClipExtrapolatedValues && c2Val < mClipMin) {										c2Val = mClipMin;									}								}								if (mFileViewer.mCurrObsFilter.isCriteria3Active()) {									interpVal = nbh.mDValues[c3Pos];									prevInterpVal = pbh.mDValues[c3Pos];									iSlope = (interpVal - prevInterpVal) / deltaDist;									sSlope = (surfVal - prevSurfVal) / deltaDist;									predictedSurfVal = sSlope * del + pbh.mDValues[sPos];									c3Val = iSlope * del + pbh.mDValues[c3Pos];									if (mClipExtrapolatedValues && c3Val > mClipMax) {										c3Val = mClipMax;									}									else if (mClipExtrapolatedValues && c3Val < mClipMin) {										c3Val = mClipMin;									}								}								if (mFileViewer.mCurrObsFilter.isCriteria4Active()) {									interpVal = nbh.mDValues[c4Pos];									prevInterpVal = pbh.mDValues[c4Pos];									iSlope = (interpVal - prevInterpVal) / deltaDist;									sSlope = (surfVal - prevSurfVal) / deltaDist;									predictedSurfVal = sSlope * del + pbh.mDValues[sPos];									c4Val = iSlope * del + pbh.mDValues[c4Pos];									if (mClipExtrapolatedValues && c4Val > mClipMax) {										c4Val = mClipMax;									}									else if (mClipExtrapolatedValues && c4Val < mClipMin) {										c4Val = mClipMin;									}								}								if (mFileViewer.mCurrObsFilter.testValues(c1Val, c2Val, c3Val, c4Val)) {									vBotts[numBotts++] = new VirtualBottle(predictedInterpVal, predictedSurfVal, 1.0 / (double) s);								}							}							else {								vBotts[numBotts++] = new VirtualBottle(predictedInterpVal, predictedSurfVal, 1.0 / (double) s);							}						}					}				}			}			// sort the virtual cast (vBotts)			for (int i = 0; i < numBotts - 1; i++) {				VirtualBottle vbh = vBotts[i];				for (int j = i + 1; j < numBotts; j++) {					VirtualBottle vbhp1 = vBotts[j];					double surfVal = vbh.mSurfValue;					double surfValP1 = vbhp1.mSurfValue;					if (surfVal > surfValP1) {						// swap the bottles						double tval = vbh.mSurfValue;						vbh.mSurfValue = vbhp1.mSurfValue;						vbhp1.mSurfValue = tval;						tval = vbh.mInterpValue;						vbh.mInterpValue = vbhp1.mInterpValue;						vbhp1.mInterpValue = tval;						tval = vbh.mWeight;						vbh.mWeight = vbhp1.mWeight;						vbhp1.mWeight = tval;					}				}			}			// do the actual interpolation onto standard levels			if (numBotts > 0) {				for (int iz = 0; iz < mNumLevels; iz++) {					mValues[iz][stnCount] = JOAConstants.MISSINGVALUE;					// initialize the sign variable from first bottle					VirtualBottle vbh = vBotts[numBotts - 1];					surfHigh = vbh.mSurfValue;					delta = surfHigh - mSurfaceValues[iz];					if (delta > 0) {						oldSign = PLUS;					}					else if (delta < 0) {						oldSign = MINUS;					}					else {						oldSign = ZERO;					}					// loop over the virtual bottles					for (int b = numBotts - 1; b >= 0; b--) {						vbh = vBotts[b];						// consider only real bottles						if (vbh.mWeight < 1.0) {							continue;						}						surfHigh = vbh.mSurfValue;						if (surfHigh != JOAConstants.MISSINGVALUE) {							delta = surfHigh - mSurfaceValues[iz];							// System.out.println(iz + " delta=" + delta);							if (delta > 0) {								newSign = PLUS;							}							else if (delta < 0) {								newSign = MINUS;							}							else {								newSign = ZERO;							}							if (newSign == ZERO) {								// bottle and level are the same								if (vbh.mInterpValue != JOAConstants.MISSINGVALUE) {									mValues[iz][stnCount] = vbh.mInterpValue;									// System.out.println("0 " + iz + " mValues=" +									// mValues[iz][stnCount]);									if (mIsResidualInterp && !mUseMeanCastValuesFromFile && mMeanCastStnList != null									    && mMeanCastStnList[stnCount]) {										levelSum[iz] += mValues[iz][stnCount];										levelCount[iz]++;									}									break;								}							}							else if (oldSign != newSign) {								// sign changes								double maxSurfVal;								if (iz + mFarStdLevelLimit <= mNumLevels - 1) {									maxSurfVal = mSurfaceValues[iz + mFarStdLevelLimit];								}								else {									maxSurfVal = mSurfaceValues[mNumLevels - 1];								}								double maxWeight = 0.0;								int useVBott = -1;								for (int bb = b + 1; bb < numBotts - 1; bb++) {									VirtualBottle bh = vBotts[bb];									if (bh.mSurfValue > maxSurfVal) {										useVBott = bb;										break;									}									if (bh.mWeight == 1.0) {										useVBott = bb;										break;									}									else if (bh.mWeight > maxWeight) {										maxWeight = bh.mWeight;										useVBott = bb;									}								}								VirtualBottle prevVBh = null;								if (useVBott >= 0) {									prevVBh = vBotts[useVBott];								}								if (prevVBh != null && vbh.mInterpValue != JOAConstants.MISSINGVALUE								    && prevVBh.mInterpValue != JOAConstants.MISSINGVALUE) {									surfLow = prevVBh.mSurfValue;									interpLow = vbh.mInterpValue;									interpHigh = prevVBh.mInterpValue;									mValues[iz][stnCount] = (delta / (surfHigh - surfLow)) * (interpHigh - interpLow) + interpLow;									if (mClipExtrapolatedValues && mValues[iz][stnCount] > mClipMax) {										mValues[iz][stnCount] = mClipMax;									}									else if (mClipExtrapolatedValues && mValues[iz][stnCount] < mClipMin) {										mValues[iz][stnCount] = mClipMin;									}									if (mIsResidualInterp && !mUseMeanCastValuesFromFile && mMeanCastStnList != null									    && mMeanCastStnList[stnCount]) {										levelSum[iz] += mValues[iz][stnCount];										levelCount[iz]++;									}								}								break;							}						}					}				}				stnCount++;			}			else {				for (int iz = 0; iz < mNumLevels; iz++) {					mValues[iz][stc] = JOAConstants.MISSINGVALUE;				}			}		}		processBottom();		if (mFillEdges) {			processEdgesVertical(stnCnt);			processEdges(stnCnt);		}		// compute the mean cast		if (mIsResidualInterp) {			for (int iz = 0; iz < mNumLevels; iz++) {				if (!mUseMeanCastValuesFromFile) {					// use computed values					if (levelCount[iz] >= 1) {						mMeanValues[iz] = levelSum[iz] / (double) levelCount[iz];						// System.out.println(iz + " levelCount=" + levelCount[iz] + "						// levelSum=" + levelSum[iz] + " mean=" + mMeanValues[iz]);						for (int s = 0; s < stnCnt; s++) {							if (mValues[iz][s] != JOAConstants.MISSINGVALUE) {								mValues[iz][s] -= mMeanValues[iz];							}						}					}					else {						for (int s = 0; s < stnCnt; s++) {							mValues[iz][s] = JOAConstants.MISSINGVALUE;						}					}				}				else {					// use mean cast from external file					double meanVal = mMeanCastValuesFromFile[iz].getV();					for (int s = 0; s < stnCnt; s++) {						if (mValues[iz][s] != JOAConstants.MISSINGVALUE && meanVal != JOAConstants.MISSINGVALUE) {							mValues[iz][s] -= meanVal;						}						else {							mValues[iz][s] = JOAConstants.MISSINGVALUE;						}					}				}			}		}	}	public boolean isBelowBottom(int lvl, double stnDepth) {		// set everything in the interpolation		if (stnDepth != JOAConstants.MISSINGVALUE) {			if (mSurfaceValues[lvl] >= stnDepth) { return true; }		}		return false;	}	public boolean isTopDown() {		return mTopDown;	}	private Vector<Bottle> filterCast(Station sh, Section sech) {		Vector<Bottle> retVector = new Vector<Bottle>(200);		// int iPos = sech.getVarPos(mInterpParam.getVarName(), false);		// int sPos =		// sech.getVarPos(mFileViewer.mAllProperties[mSurfaceParamNum].mVarLabel,		// false);		if (mFileViewer.mObsFilterActive) {			// mFileViewer.mCurrObsFilter.dumpFilter();			double c1Val = JOAConstants.MISSINGVALUE;			double c2Val = JOAConstants.MISSINGVALUE;			double c3Val = JOAConstants.MISSINGVALUE;			double c4Val = JOAConstants.MISSINGVALUE;			int c1Pos = JOAConstants.MISSINGVALUE;			int c2Pos = JOAConstants.MISSINGVALUE;			int c3Pos = JOAConstants.MISSINGVALUE;			int c4Pos = JOAConstants.MISSINGVALUE;			if (mFileViewer.mCurrObsFilter.isCriteria1Active()) {				c1Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(0)].getVarLabel(),				    false);			}			if (mFileViewer.mCurrObsFilter.isCriteria2Active()) {				c2Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(1)].getVarLabel(),				    false);			}			if (mFileViewer.mCurrObsFilter.isCriteria3Active()) {				c3Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(2)].getVarLabel(),				    false);			}			if (mFileViewer.mCurrObsFilter.isCriteria4Active()) {				c4Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(3)].getVarLabel(),				    false);			}			for (int b = 0; b < sh.mNumBottles; b++) {				Bottle bh = (Bottle) sh.mBottles.elementAt(b);				if (mFileViewer.mCurrObsFilter.isCriteria1Active()) {					c1Val = bh.mDValues[c1Pos];				}				if (mFileViewer.mCurrObsFilter.isCriteria2Active()) {					c2Val = bh.mDValues[c2Pos];				}				if (mFileViewer.mCurrObsFilter.isCriteria3Active()) {					c3Val = bh.mDValues[c3Pos];				}				if (mFileViewer.mCurrObsFilter.isCriteria4Active()) {					c4Val = bh.mDValues[c4Pos];				}				if (mFileViewer.mCurrObsFilter.testValues(c1Val, c2Val, c3Val, c4Val, bh, c1Pos, c2Pos, c3Pos, c4Pos)) {					retVector.addElement(bh);				}			}		}		else {			// System.out.println(sh.getStn());			for (int b = 0; b < sh.mNumBottles; b++) {				Bottle bh = (Bottle) sh.mBottles.elementAt(b);				// System.out.println(bh.mDValues[sPos] + " " + bh.mDValues[iPos]);				retVector.addElement(bh);			}		}		return retVector;	}	public void doInterp(boolean redim) {		if (mLocked) {			return;		}				if (redim) {			redimensionInterpolation();		}		if (isTopDown()) {			doInterpDown();			if (getInterpolationType() == FAR_FIELD_INTERPOLATION) {				farFieldFill();			}		}		else if (!isTopDown()) {			doInterpUp();			if (getInterpolationType() == FAR_FIELD_INTERPOLATION) {				farFieldFill();			}		}	}	public void doInterpDown() {		// initialize some constants		double physHigh, physLow, interpLow, interpHigh, delta;		int newSign, oldSign;		int c1Pos = 0, c2Pos = 0, c3Pos = 0, c4Pos = 0;		boolean doIt = false;		double c1Val = 0.0, c2Val = 0.0, c3Val = 0.0, c4Val = 0.0;		// mean cast collector		double[] levelSum = new double[mNumLevels];		int[] levelCount = new int[mNumLevels];		int stnCnt = -1;		if (mIsResidualInterp && !mUseMeanCastValuesFromFile) {			for (int iz = 0; iz < mNumLevels; iz++) {				levelSum[iz] = 0;				levelCount[iz] = 0;			}		}		// set the extrapolate clip values		mClipMin = mInterpParam.getPlotMin();		mClipMax = mInterpParam.getPlotMin();		// interpolate		// loop over each level // interpolate		// loop over each level		for (int iz = 0; iz < mNumLevels; iz++) {			// init the values at this level to missing			for (int i = 0; i < mTotalStns; i++)				mValues[iz][i] = JOAConstants.MISSINGVALUE;			// use a counter			stnCnt = -1;			// loop over the files			for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {				OpenDataFile of = (OpenDataFile) mFileViewer.mOpenFiles.elementAt(fc);				// loop over the sections				for (int sec = 0; sec < of.mNumSections; sec++) {					Section sech = (Section) of.mSections.elementAt(sec);					if (sech.mNumCasts == 0) {						continue;					}					int iPos = sech.getVarPos(mInterpParam.getVarName(), false);					int sPos = sech.getVarPos(mFileViewer.mAllProperties[mSurfaceParamNum].mVarLabel, false);					if (iPos < 0 || sPos < 0)						continue;					if (mFileViewer.mObsFilterActive) {						if (mFileViewer.mCurrObsFilter.isCriteria1Active())							c1Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(0)]							    .getVarLabel(), false);						if (mFileViewer.mCurrObsFilter.isCriteria2Active())							c2Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(1)]							    .getVarLabel(), false);						if (mFileViewer.mCurrObsFilter.isCriteria3Active())							c3Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(2)]							    .getVarLabel(), false);						if (mFileViewer.mCurrObsFilter.isCriteria4Active())							c4Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(3)]							    .getVarLabel(), false);					}					// loop over the stations					for (int stc = 0; stc < sech.mStations.size(); stc++) {						Station sh = (Station) sech.mStations.elementAt(stc);						if (sh.mNumBottles == 0)							continue;						if (sh.mUseStn) {							stnCnt++;							// initialize the result to missing							mValues[iz][stnCnt] = JOAConstants.MISSINGVALUE;							// initialize the sign variable from first bottle							Bottle bh = (Bottle) sh.mBottles.elementAt(0);							physHigh = bh.mDValues[sPos];							delta = physHigh - mSurfaceValues[iz];							oldSign = 0;							if (delta > 0)								oldSign = PLUS;							else if (delta < 0)								oldSign = MINUS;							else								oldSign = ZERO;							doIt = false;							// loop over the bottles							for (int b = 0; b < sh.mNumBottles; b++) {								bh = (Bottle) sh.mBottles.elementAt(b);								double val = bh.mDValues[sPos];								double ival = bh.mDValues[iPos];								if (val != JOAConstants.MISSINGVALUE) {									physHigh = val;									doIt = true;								}								if (ival == JOAConstants.MISSINGVALUE) {									doIt = false;									continue;								}								if (doIt) {									delta = physHigh - mSurfaceValues[iz];									if (delta > 0)										newSign = PLUS;									else if (delta < 0)										newSign = MINUS;									else										newSign = ZERO;									if (newSign == ZERO) {										// bottle and level are the same										if (bh.mDValues[iPos] != JOAConstants.MISSINGVALUE) {											mValues[iz][stnCnt] = bh.mDValues[iPos];											if (mIsResidualInterp && !mUseMeanCastValuesFromFile && mMeanCastStnList != null											    && mMeanCastStnList[stnCnt]) {												levelSum[iz] += mValues[iz][stnCnt];												levelCount[iz]++;											}											if (mFileViewer.mObsFilterActive) {												if (mFileViewer.mCurrObsFilter.isCriteria1Active())													c1Val = bh.mDValues[c1Pos];												if (mFileViewer.mCurrObsFilter.isCriteria2Active())													c2Val = bh.mDValues[c2Pos];												if (mFileViewer.mCurrObsFilter.isCriteria3Active())													c3Val = bh.mDValues[c3Pos];												if (mFileViewer.mCurrObsFilter.isCriteria4Active())													c4Val = bh.mDValues[c4Pos];												if (!mFileViewer.mCurrObsFilter.testValues(c1Val, c2Val, c3Val, c4Val, bh, c1Pos, c2Pos, c3Pos,												    c4Pos))													mValues[iz][stnCnt] = JOAConstants.MISSINGVALUE;											}											break;										}									}									else if (oldSign != newSign && newSign != ZERO && b > 0) {										// sign changes										Bottle prevBh = null;										int bb = b - 1;										if (mInterpolationType == LOCAL_INTERPOLATION || mInterpolationType == FAR_FIELD_INTERPOLATION) {											// search for a non-missing bottle value above current											// bottle											int fbc = 0;											do {												prevBh = (Bottle) sh.mBottles.elementAt(bb--);												fbc++;											} while (fbc < mFarBottleLimit && prevBh.mDValues[iPos] == JOAConstants.MISSINGVALUE && bb >= 0);										}										else if (bb >= 0) {											prevBh = (Bottle) sh.mBottles.elementAt(bb);										}										if (bh.mDValues[iPos] != JOAConstants.MISSINGVALUE										    && prevBh.mDValues[iPos] != JOAConstants.MISSINGVALUE) {											physLow = prevBh.mDValues[sPos];											interpLow = bh.mDValues[iPos];											interpHigh = prevBh.mDValues[iPos];											mValues[iz][stnCnt] = (delta / (physHigh - physLow)) * (interpHigh - interpLow) + interpLow;											if (mIsResidualInterp && !mUseMeanCastValuesFromFile && mMeanCastStnList != null											    && mMeanCastStnList[stnCnt]) {												levelSum[iz] += mValues[iz][stnCnt];												levelCount[iz]++;											}											// test whether the interpolated values for the obs filter											// meet test											if (mFileViewer.mObsFilterActive) {												if (mFileViewer.mCurrObsFilter.isCriteria1Active()) {													interpLow = bh.mDValues[c1Pos];													interpHigh = prevBh.mDValues[c1Pos];													c1Val = (delta / (physHigh - physLow)) * (interpHigh - interpLow) + interpLow;												}												if (mFileViewer.mCurrObsFilter.isCriteria2Active()) {													interpLow = bh.mDValues[c2Pos];													interpHigh = prevBh.mDValues[c2Pos];													c2Val = (delta / (physHigh - physLow)) * (interpHigh - interpLow) + interpLow;												}												if (mFileViewer.mCurrObsFilter.isCriteria3Active()) {													interpLow = bh.mDValues[c3Pos];													interpHigh = prevBh.mDValues[c3Pos];													c3Val = (delta / (physHigh - physLow)) * (interpHigh - interpLow) + interpLow;												}												if (mFileViewer.mCurrObsFilter.isCriteria4Active()) {													interpLow = bh.mDValues[c4Pos];													interpHigh = prevBh.mDValues[c4Pos];													c4Val = (delta / (physHigh - physLow)) * (interpHigh - interpLow) + interpLow;												}												if (!mFileViewer.mCurrObsFilter.testValues(c1Val, c2Val, c3Val, c4Val, bh, c1Pos, c2Pos, c3Pos,												    c4Pos))													mValues[iz][stnCnt] = JOAConstants.MISSINGVALUE;												if (!mFileViewer.mCurrObsFilter.testValues(c1Val, c2Val, c3Val, c4Val, prevBh, c1Pos, c2Pos,												    c3Pos, c4Pos))													mValues[iz][stnCnt] = JOAConstants.MISSINGVALUE;											}											break;										}										break;									}								} // if doIT							} // for b						} // if useStn					} // for stc				} // for sec			} // for fc		} // for iz		processBottom();		if (mFillEdges) {			processEdgesVertical(stnCnt);			processEdges(stnCnt);		}		// compute the mean cast		if (mIsResidualInterp) {			for (int iz = 0; iz < mNumLevels; iz++) {				if (!mUseMeanCastValuesFromFile) {					// use computed values					if (levelCount[iz] >= 1) {						mMeanValues[iz] = levelSum[iz] / (double) levelCount[iz];						for (int s = 0; s < stnCnt + 1; s++) {							if (mValues[iz][s] != JOAConstants.MISSINGVALUE) {								mValues[iz][s] -= mMeanValues[iz];							}						}					}					else {						for (int s = 0; s < stnCnt + 1; s++) {							mValues[iz][s] = JOAConstants.MISSINGVALUE;						}					}				}				else {					// use mean cast from external file					double meanVal = mMeanCastValuesFromFile[iz].getV();					for (int s = 0; s < stnCnt + 1; s++) {						if (mValues[iz][s] != JOAConstants.MISSINGVALUE && meanVal != JOAConstants.MISSINGVALUE) {							mValues[iz][s] -= meanVal;						}						else {							mValues[iz][s] = JOAConstants.MISSINGVALUE;						}					}				}			}		}	}		public void doSimpleInterpDown() {		// initialize some constants		double physHigh, physLow, interpLow, interpHigh, delta;		int newSign, oldSign;		boolean doIt = false;		// mean cast collector		int stnCnt = -1;		// set the extrapolate clip values		mClipMin = mInterpParam.getPlotMin();		mClipMax = mInterpParam.getPlotMin();		// interpolate		// loop over each level // interpolate		// loop over each level		for (int iz = 0; iz < mNumLevels; iz++) {			// init the values at this level to missing			for (int i = 0; i < mTotalStns; i++)				mValues[iz][i] = JOAConstants.MISSINGVALUE;			// use a counter			stnCnt = -1;			// loop over the files			for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {				OpenDataFile of = (OpenDataFile) mFileViewer.mOpenFiles.elementAt(fc);				// loop over the sections				for (int sec = 0; sec < of.mNumSections; sec++) {					Section sech = (Section) of.mSections.elementAt(sec);					if (sech.mNumCasts == 0) {						continue;					}					int iPos = sech.getVarPos(mInterpParam.getVarName(), false);					int sPos = sech.getVarPos(mFileViewer.mAllProperties[mSurfaceParamNum].mVarLabel, false);					if (iPos < 0 || sPos < 0)						continue;					// loop over the stations					for (int stc = 0; stc < sech.mStations.size(); stc++) {						Station sh = (Station) sech.mStations.elementAt(stc);						if (sh.mNumBottles == 0)							continue;						if (sh.mUseStn) {							stnCnt++;							// initialize the result to missing							mValues[iz][stnCnt] = JOAConstants.MISSINGVALUE;							// initialize the sign variable from first bottle							Bottle bh = (Bottle) sh.mBottles.elementAt(0);							physHigh = bh.mDValues[sPos];							delta = physHigh - mSurfaceValues[iz];							oldSign = 0;							if (delta > 0)								oldSign = PLUS;							else if (delta < 0)								oldSign = MINUS;							else								oldSign = ZERO;							doIt = false;							// loop over the bottles							for (int b = 0; b < sh.mNumBottles; b++) {								bh = (Bottle) sh.mBottles.elementAt(b);								double val = bh.mDValues[sPos];								double ival = bh.mDValues[iPos];								if (val != JOAConstants.MISSINGVALUE) {									physHigh = val;									doIt = true;								}								if (ival == JOAConstants.MISSINGVALUE) {									doIt = false;									continue;								}								if (doIt) {									delta = physHigh - mSurfaceValues[iz];									if (delta > 0)										newSign = PLUS;									else if (delta < 0)										newSign = MINUS;									else										newSign = ZERO;									if (newSign == ZERO) {										// bottle and level are the same										if (bh.mDValues[iPos] != JOAConstants.MISSINGVALUE) {											mValues[iz][stnCnt] = bh.mDValues[iPos];											break;										}									}									else if (oldSign != newSign && newSign != ZERO && b > 0) {										// sign changes										Bottle prevBh = null;										int bb = b - 1;										if (mInterpolationType == LOCAL_INTERPOLATION || mInterpolationType == FAR_FIELD_INTERPOLATION) {											// search for a non-missing bottle value above current											// bottle											int fbc = 0;											do {												prevBh = (Bottle) sh.mBottles.elementAt(bb--);												fbc++;											} while (fbc < mFarBottleLimit && prevBh.mDValues[iPos] == JOAConstants.MISSINGVALUE && bb >= 0);										}										else if (bb >= 0)											prevBh = (Bottle) sh.mBottles.elementAt(bb);										if (bh.mDValues[iPos] != JOAConstants.MISSINGVALUE										    && prevBh.mDValues[iPos] != JOAConstants.MISSINGVALUE) {											physLow = prevBh.mDValues[sPos];											interpLow = bh.mDValues[iPos];											interpHigh = prevBh.mDValues[iPos];											mValues[iz][stnCnt] = (delta / (physHigh - physLow)) * (interpHigh - interpLow) + interpLow;											break;										}										break;									}								} // if doIT							} // for b						} // if useStn					} // for stc				} // for sec			} // for fc		} // for iz		processBottomSimple();//		if (mFillEdges) {//			processEdgesVertical(stnCnt);//			processEdges(stnCnt);//		}	}	public void processBottom() {		int pPos = mFileViewer.getPRESPropertyPos(), c1Pos = 0, c2Pos = 0, c3Pos = 0, c4Pos = 0;		double physLow, c1Val = 0.0, c2Val = 0.0, c3Val = 0.0, c4Val = 0.0;		// loop over the files		int stnCnt = -1;		for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {			OpenDataFile of = (OpenDataFile) mFileViewer.mOpenFiles.elementAt(fc);			// loop over the sections			for (int sec = 0; sec < of.mNumSections; sec++) {				Section sech = (Section) of.mSections.elementAt(sec);				if (sech.mNumCasts == 0) {					continue;				}				int iPos = sech.getVarPos(mInterpParam.getVarName(), false);				int sPos = sech.getVarPos(mFileViewer.mAllProperties[mSurfaceParamNum].mVarLabel, false);				if (iPos < 0 || sPos < 0) {					continue;				}				if (mFileViewer.mObsFilterActive) {					if (mFileViewer.mCurrObsFilter.isCriteria1Active()) {						c1Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(0)]						    .getVarLabel(), false);					}					if (mFileViewer.mCurrObsFilter.isCriteria2Active()) {						c2Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(1)]						    .getVarLabel(), false);					}					if (mFileViewer.mCurrObsFilter.isCriteria3Active()) {						c3Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(2)]						    .getVarLabel(), false);					}					if (mFileViewer.mCurrObsFilter.isCriteria4Active()) {						c4Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(3)]						    .getVarLabel(), false);					}				}				// loop over the stations				for (int stc = 0; stc < sech.mStations.size(); stc++) {					Station sh = (Station) sech.mStations.elementAt(stc);					;					if (sh.mNumBottles <= 2) {						continue;					}					if (sh.mUseStn) {						stnCnt++;						// find the last bottle and the one above it						Bottle bh = (Bottle) sh.mBottles.elementAt(sh.mNumBottles - 1);						double surfVal = bh.mDValues[sPos];						physLow = bh.mDValues[iPos];						Bottle bhu = (Bottle) sh.mBottles.elementAt(sh.mNumBottles - 2);						double surfValu = bhu.mDValues[sPos];						double physLowu = bhu.mDValues[iPos];						double slope = (physLow - physLowu) / (surfVal - surfValu);						if (mFileViewer.mObsFilterActive) {							if (mFileViewer.mCurrObsFilter.isCriteria1Active()) {								c1Val = bh.mDValues[c1Pos];							}							if (mFileViewer.mCurrObsFilter.isCriteria2Active()) {								c2Val = bh.mDValues[c2Pos];							}							if (mFileViewer.mCurrObsFilter.isCriteria3Active()) {								c3Val = bh.mDValues[c3Pos];							}							if (mFileViewer.mCurrObsFilter.isCriteria4Active()) {								c4Val = bh.mDValues[c4Pos];							}							if (!mFileViewer.mCurrObsFilter.testValues(c1Val, c2Val, c3Val, c4Val, bh, c1Pos, c2Pos, c3Pos, c4Pos)) {								continue; // bottle is filtered out							}						}						// look for the level below last bottle						int lastBottleLevel = JOAConstants.MISSINGVALUE;						for (int iz = 0; iz < mNumLevels; iz++) {							if (mSurfaceValues[iz] >= surfVal) {								lastBottleLevel = iz;								break;							}						}						// look for the level below ocean bottom						int lastLevelUnderBottom = JOAConstants.MISSINGVALUE;						if (sh.mBottomDepthInDBARS != JOAConstants.MISSINGVALUE) {							double floorDbar = sh.mBottomDepthInDBARS * mFileViewer.mAllProperties[pPos].mActScale							    + mFileViewer.mAllProperties[pPos].mActOrigin;							for (int iz = 0; iz < mNumLevels; iz++) {								if (mSurfaceValues[iz] >= floorDbar) {									lastLevelUnderBottom = iz;									break;								}							}						}						if (lastBottleLevel != JOAConstants.MISSINGVALUE && lastLevelUnderBottom == JOAConstants.MISSINGVALUE) {							// extend last bottle to last bottle level + 1							if (stc > 0 && physLow != JOAConstants.MISSINGVALUE) {								for (int iz = lastBottleLevel; iz <= lastBottleLevel + 1; iz++) {									if (iz < mNumLevels) {										mValues[iz][stnCnt] = physLow;									}								}							}						}						else if (lastBottleLevel != JOAConstants.MISSINGVALUE && lastLevelUnderBottom != JOAConstants.MISSINGVALUE) {							if (lastLevelUnderBottom == lastBottleLevel) {								mValues[lastLevelUnderBottom][stnCnt] = physLow;								if (lastLevelUnderBottom + 1 < mNumLevels) {									mValues[lastLevelUnderBottom + 1][stnCnt] = physLow;								}							}							else if (lastLevelUnderBottom - lastBottleLevel < 0 && physLow != JOAConstants.MISSINGVALUE) {								// reported bottom is above last bottle--extend interpolation								// one level anyway								mValues[lastLevelUnderBottom][stnCnt] = physLow;								if (lastLevelUnderBottom + 1 < mNumLevels) {									mValues[lastLevelUnderBottom + 1][stnCnt] = physLow;								}							}							else if (lastLevelUnderBottom - lastBottleLevel <= 3) {								// extrapolate to below bottom if not more than three levels								for (int iz = lastBottleLevel + 1; iz <= lastLevelUnderBottom + 1; iz++) {									if (iz < mNumLevels) {										if (mSurfaceValues[iz] == JOAConstants.MISSINGVALUE										    || mSurfaceValues[lastBottleLevel] == JOAConstants.MISSINGVALUE										    || mValues[lastBottleLevel][stnCnt] == JOAConstants.MISSINGVALUE) {											continue;										}										double del = mSurfaceValues[iz] - mSurfaceValues[lastBottleLevel];										// compute new values										double newVal = slope * del + mValues[lastBottleLevel][stnCnt];										mValues[iz][stnCnt] = newVal;										if (mValues[iz][stnCnt] < 0) {											System.out.println("#4 " + mValues[iz][stnCnt] + " " + iz + " " + stnCnt);										}									}								} // for							} // else if						} // else if					} // if true				} // for stns			} // for secs		} // for files	}		public void processBottomSimple() {		int pPos = mFileViewer.getPRESPropertyPos();		double physLow;		// loop over the files		int stnCnt = -1;		for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {			OpenDataFile of = (OpenDataFile) mFileViewer.mOpenFiles.elementAt(fc);			// loop over the sections			for (int sec = 0; sec < of.mNumSections; sec++) {				Section sech = (Section) of.mSections.elementAt(sec);				if (sech.mNumCasts == 0) {					continue;				}				int iPos = sech.getVarPos(mInterpParam.getVarName(), false);				int sPos = sech.getVarPos(mFileViewer.mAllProperties[mSurfaceParamNum].mVarLabel, false);				if (iPos < 0 || sPos < 0) {					continue;				}				// loop over the stations				for (int stc = 0; stc < sech.mStations.size(); stc++) {					Station sh = (Station) sech.mStations.elementAt(stc);					;					if (sh.mNumBottles <= 2) {						continue;					}					if (sh.mUseStn) {						stnCnt++;						// find the last bottle and the one above it						Bottle bh = (Bottle) sh.mBottles.elementAt(sh.mNumBottles - 1);						double surfVal = bh.mDValues[sPos];						physLow = bh.mDValues[iPos];						Bottle bhu = (Bottle) sh.mBottles.elementAt(sh.mNumBottles - 2);						double surfValu = bhu.mDValues[sPos];						double physLowu = bhu.mDValues[iPos];						double slope = (physLow - physLowu) / (surfVal - surfValu);						// look for the level below last bottle						int lastBottleLevel = JOAConstants.MISSINGVALUE;						for (int iz = 0; iz < mNumLevels; iz++) {							if (mSurfaceValues[iz] >= surfVal) {								lastBottleLevel = iz;								break;							}						}						// look for the level below ocean bottom						int lastLevelUnderBottom = JOAConstants.MISSINGVALUE;						if (sh.mBottomDepthInDBARS != JOAConstants.MISSINGVALUE) {							double floorDbar = sh.mBottomDepthInDBARS * mFileViewer.mAllProperties[pPos].mActScale							    + mFileViewer.mAllProperties[pPos].mActOrigin;							for (int iz = 0; iz < mNumLevels; iz++) {								if (mSurfaceValues[iz] >= floorDbar) {									lastLevelUnderBottom = iz;									break;								}							}						}						if (lastBottleLevel != JOAConstants.MISSINGVALUE && lastLevelUnderBottom == JOAConstants.MISSINGVALUE) {							// extend last bottle to last bottle level + 1							if (stc > 0 && physLow != JOAConstants.MISSINGVALUE) {								for (int iz = lastBottleLevel; iz <= lastBottleLevel + 1; iz++) {									if (iz < mNumLevels) {										mValues[iz][stnCnt] = physLow;									}								}							}						}						else if (lastBottleLevel != JOAConstants.MISSINGVALUE && lastLevelUnderBottom != JOAConstants.MISSINGVALUE) {							if (lastLevelUnderBottom == lastBottleLevel) {								mValues[lastLevelUnderBottom][stnCnt] = physLow;								if (lastLevelUnderBottom + 1 < mNumLevels) {									mValues[lastLevelUnderBottom + 1][stnCnt] = physLow;								}							}							else if (lastLevelUnderBottom - lastBottleLevel < 0 && physLow != JOAConstants.MISSINGVALUE) {								// reported bottom is above last bottle--extend interpolation								// one level anyway								mValues[lastLevelUnderBottom][stnCnt] = physLow;								if (lastLevelUnderBottom + 1 < mNumLevels) {									mValues[lastLevelUnderBottom + 1][stnCnt] = physLow;								}							}							else if (lastLevelUnderBottom - lastBottleLevel <= 3) {								// extrapolate to below bottom if not more than three levels								for (int iz = lastBottleLevel + 1; iz <= lastLevelUnderBottom + 1; iz++) {									if (iz < mNumLevels) {										if (mSurfaceValues[iz] == JOAConstants.MISSINGVALUE										    || mSurfaceValues[lastBottleLevel] == JOAConstants.MISSINGVALUE										    || mValues[lastBottleLevel][stnCnt] == JOAConstants.MISSINGVALUE) {											continue;										}										double del = mSurfaceValues[iz] - mSurfaceValues[lastBottleLevel];										// compute new values										double newVal = slope * del + mValues[lastBottleLevel][stnCnt];										mValues[iz][stnCnt] = newVal;										if (mValues[iz][stnCnt] < 0) {											System.out.println("#4 " + mValues[iz][stnCnt] + " " + iz + " " + stnCnt);										}									}								} // for							} // else if						} // else if					} // if true				} // for stns			} // for secs		} // for files	}	public void processEdgesVertical(int stnCnt) {		// fix the sides of interpolation		for (int stc = 0; stc < stnCnt; stc++) {			// get the level of the last non missing observation in the interpolation			int lastLevelAtCurrStn = JOAConstants.MISSINGVALUE;			int iz;			for (iz = mNumLevels - 1; iz >= 0; iz--) {				if (mValues[iz][stc] != JOAConstants.MISSINGVALUE) {					lastLevelAtCurrStn = iz;					break;				}			}			int lastLevelM1AtCurrStn = JOAConstants.MISSINGVALUE;			iz = lastLevelAtCurrStn--;			while (iz >= 0) {				if (mValues[iz][stc] != JOAConstants.MISSINGVALUE) {					lastLevelM1AtCurrStn = iz;					break;				}				iz--;			}			if (lastLevelAtCurrStn >= 0 && lastLevelM1AtCurrStn >= 0) {				// compute a slope				double slope = (mValues[lastLevelAtCurrStn][stc] - mValues[lastLevelM1AtCurrStn][stc])				    / (mSurfaceValues[lastLevelAtCurrStn] - mSurfaceValues[lastLevelM1AtCurrStn]);				// find the level below the bottom				int lastLevelUnderBottom = JOAConstants.MISSINGVALUE;				if (mBottomDepths[stc] != JOAConstants.MISSINGVALUE) {					for (iz = 0; iz < mNumLevels; iz++) {						if (mSurfaceValues[iz] >= mBottomDepths[stc]) {							lastLevelUnderBottom = iz;							break;						}					}				}				if (lastLevelUnderBottom != JOAConstants.MISSINGVALUE) {					// extrapolate to below bottom if not more than three levels					for (iz = lastLevelAtCurrStn + 1; iz <= lastLevelUnderBottom + 3; iz++) {						if (iz < mNumLevels) {							double del = mSurfaceValues[iz] - mSurfaceValues[lastLevelAtCurrStn];							// compute new values							double newVal = slope * del + mValues[lastLevelAtCurrStn][stc];							if (mClipExtrapolatedValues && newVal > mClipMax) {								mValues[iz][stc] = mClipMax;							}							else if (mClipExtrapolatedValues && newVal < mClipMin) {								mValues[iz][stc] = mClipMin;							}							else {								mValues[iz][stc] = newVal;							}						}					} // for				}			}		}	}	public void processEdges(int stnCnt) {		double[][] mNewValues = new double[mNumLevels][stnCnt];		// create a temp array to do processing		for (int iz = 0; iz < mNumLevels; iz++) {			for (int stc = 0; stc < stnCnt; stc++) {				mNewValues[iz][stc] = JOAConstants.MISSINGVALUE;			}		}		// fix the sides of interpolation		for (int stc = 0; stc < stnCnt; stc++) {			// loop over the stations			int lastLevelAtCurrStn = JOAConstants.MISSINGVALUE;			int lastLevelAtPrevStn = JOAConstants.MISSINGVALUE;			int lastLevelAtNextStn = JOAConstants.MISSINGVALUE;			int prevStn = JOAConstants.MISSINGVALUE;			int nextStn = JOAConstants.MISSINGVALUE;			int prevStnM1 = JOAConstants.MISSINGVALUE;			int nextStnP1 = JOAConstants.MISSINGVALUE;			// get the next non-missing station			if (stc + 1 < stnCnt) {				nextStn = stc + 1;			}			if (stc + 2 < stnCnt) {				nextStnP1 = stc + 2;			}			if (stc - 1 >= 0) {				prevStn = stc - 1;			}			if (stc - 2 >= 0) {				prevStnM1 = stc - 2;			}			// get the level of the last non missing observation in the interpolation			for (int iz = mNumLevels - 1; iz >= 0; iz--) {				if (mValues[iz][stc] != JOAConstants.MISSINGVALUE) {					lastLevelAtCurrStn = iz;					break;				}			}			if (prevStn != JOAConstants.MISSINGVALUE) {				for (int iz = mNumLevels - 1; iz >= 0; iz--) {					if (mValues[iz][prevStn] != JOAConstants.MISSINGVALUE) {						lastLevelAtPrevStn = iz;						break;					}				}			}			if (nextStn != JOAConstants.MISSINGVALUE) {				for (int iz = mNumLevels - 1; iz >= 0; iz--) {					if (mValues[iz][nextStn] != JOAConstants.MISSINGVALUE) {						lastLevelAtNextStn = iz;						break;					}				}			}			if (lastLevelAtCurrStn == JOAConstants.MISSINGVALUE) {				continue;			}			if (stc == 0 && lastLevelAtCurrStn != JOAConstants.MISSINGVALUE			    && lastLevelAtNextStn != JOAConstants.MISSINGVALUE) {				// first station--can only look to the right				if (lastLevelAtNextStn > lastLevelAtCurrStn && nextStnP1 != JOAConstants.MISSINGVALUE) {					// fill in values for the first stn using horizontal gradients					for (int l = lastLevelAtCurrStn; l <= lastLevelAtNextStn; l++) {						if (mValues[l][nextStn] == JOAConstants.MISSINGVALUE || mValues[l][nextStnP1] == JOAConstants.MISSINGVALUE) {							continue;						}						// compute the gradient						double num = mValues[l][nextStn] - mValues[l][nextStnP1];						double denom = mDistValues[nextStn] - mDistValues[nextStnP1];						double slope = num / denom;						double del = mDistValues[stc] - mDistValues[nextStn];						// compute new values						double newVal = slope * del + mValues[l][nextStn];						if (mClipExtrapolatedValues && newVal > mClipMax) {							mNewValues[l][stc] = mClipMax;						}						else if (mClipExtrapolatedValues && newVal < mClipMin) {							mNewValues[l][stc] = mClipMin;						}						else {							mNewValues[l][stc] = newVal;						}					}				}			}			else if (stc == stnCnt - 1 && lastLevelAtCurrStn != JOAConstants.MISSINGVALUE			    && lastLevelAtPrevStn != JOAConstants.MISSINGVALUE) {				// last station--can only look to the left				if (lastLevelAtPrevStn > lastLevelAtCurrStn && prevStnM1 != JOAConstants.MISSINGVALUE) {					// fill in values for the last stn using horizontal gradients					for (int l = lastLevelAtCurrStn; l <= lastLevelAtPrevStn; l++) {						if (mValues[l][prevStn] == JOAConstants.MISSINGVALUE || mValues[l][prevStnM1] == JOAConstants.MISSINGVALUE) {							continue;						}						// compute the gradient						double num = mValues[l][prevStn] - mValues[l][prevStnM1];						double denom = mDistValues[prevStn] - mDistValues[prevStnM1];						double slope = num / denom;						double del = mDistValues[stc] - mDistValues[prevStn];						// compute new values						double newVal = slope * del + mValues[l][prevStn];						if (mClipExtrapolatedValues && newVal > mClipMax) {							mNewValues[l][stc] = mClipMax;						}						else if (mClipExtrapolatedValues && newVal < mClipMin) {							mNewValues[l][stc] = mClipMin;						}						else {							mNewValues[l][stc] = newVal;						}					}				}			}			else if (stc == 1 && lastLevelAtCurrStn != JOAConstants.MISSINGVALUE			    && lastLevelAtPrevStn != JOAConstants.MISSINGVALUE) {				// second station--can't use the left gradient				if (lastLevelAtNextStn > lastLevelAtCurrStn && nextStnP1 != JOAConstants.MISSINGVALUE) {					// fill in values for the first stn using horizontal gradients					for (int l = lastLevelAtCurrStn; l <= lastLevelAtNextStn; l++) {						if (mValues[l][nextStn] == JOAConstants.MISSINGVALUE || mValues[l][nextStnP1] == JOAConstants.MISSINGVALUE) {							continue;						}						// compute the gradient						double num = mValues[l][nextStn] - mValues[l][nextStnP1];						double denom = mDistValues[nextStn] - mDistValues[nextStnP1];						double slope = num / denom;						double del = mDistValues[stc] - mDistValues[nextStn];						// compute new values						double newVal = slope * del + mValues[l][nextStn];						if (mClipExtrapolatedValues && newVal > mClipMax) {							mNewValues[l][stc] = mClipMax;						}						else if (mClipExtrapolatedValues && newVal < mClipMin) {							mNewValues[l][stc] = mClipMin;						}						else {							mNewValues[l][stc] = newVal;						}					}				}			}			else if (stc == stnCnt - 2 && lastLevelAtCurrStn != JOAConstants.MISSINGVALUE			    && lastLevelAtPrevStn != JOAConstants.MISSINGVALUE) {				// second station from the end--can't use the right gradient				if (lastLevelAtPrevStn > lastLevelAtCurrStn && prevStnM1 != JOAConstants.MISSINGVALUE) {					// fill in values for the first stn using horizontal gradients					for (int l = lastLevelAtCurrStn; l <= lastLevelAtPrevStn; l++) {						if (mValues[l][prevStn] == JOAConstants.MISSINGVALUE || mValues[l][prevStnM1] == JOAConstants.MISSINGVALUE) {							continue;						}						// compute the gradient						double num = mValues[l][prevStn] - mValues[l][prevStnM1];						double denom = mDistValues[prevStn] - mDistValues[prevStnM1];						double slope = num / denom;						double del = mDistValues[stc] - mDistValues[prevStnM1];						// compute new values						double newVal = slope * del + mValues[l][prevStn];						if (mClipExtrapolatedValues && newVal > mClipMax) {							mNewValues[l][stc] = mClipMax;						}						else if (mClipExtrapolatedValues && newVal < mClipMin) {							mNewValues[l][stc] = mClipMin;						}						else {							mNewValues[l][stc] = newVal;						}					}				}			}			else {				// have surrounding stations in the interpolation				if (lastLevelAtPrevStn > lastLevelAtCurrStn && lastLevelAtPrevStn > lastLevelAtNextStn				    && prevStnM1 != JOAConstants.MISSINGVALUE) {					// use the previous station					for (int l = lastLevelAtCurrStn; l <= lastLevelAtPrevStn; l++) {						if (mValues[l][prevStn] == JOAConstants.MISSINGVALUE || mValues[l][prevStnM1] == JOAConstants.MISSINGVALUE) {							continue;						}						// compute the gradient						double num = mValues[l][prevStn] - mValues[l][prevStnM1];						double denom = mDistValues[prevStn] - mDistValues[prevStnM1];						double slope = num / denom;						double del = mDistValues[stc] - mDistValues[prevStn];						// compute new values						double newVal = slope * del + mValues[l][prevStn];						if (mClipExtrapolatedValues && newVal > mClipMax) {							mNewValues[l][stc] = mClipMax;						}						else if (mClipExtrapolatedValues && newVal < mClipMin) {							mNewValues[l][stc] = mClipMin;						}						else {							mNewValues[l][stc] = newVal;						}					}				}				else if (lastLevelAtNextStn > lastLevelAtCurrStn && lastLevelAtNextStn > lastLevelAtPrevStn				    && nextStnP1 != JOAConstants.MISSINGVALUE) {					// use the next station					for (int l = lastLevelAtCurrStn; l <= lastLevelAtNextStn; l++) {						if (mValues[l][nextStn] == JOAConstants.MISSINGVALUE || mValues[l][nextStnP1] == JOAConstants.MISSINGVALUE) {							continue;						}						// compute the gradient						double num = mValues[l][nextStn] - mValues[l][nextStnP1];						double denom = mDistValues[nextStn] - mDistValues[nextStnP1];						double slope = num / denom;						double del = mDistValues[stc] - mDistValues[nextStn];						// compute new values						double newVal = slope * del + mValues[l][nextStn];						if (mClipExtrapolatedValues && newVal > mClipMax) {							mNewValues[l][stc] = mClipMax;						}						else if (mClipExtrapolatedValues && newVal < mClipMin) {							mNewValues[l][stc] = mClipMin;						}						else {							mNewValues[l][stc] = newVal;						}					}				}			}		}		// copy new values back into the interpolation array		for (int iz = 0; iz < mNumLevels; iz++) {			for (int stc = 0; stc < stnCnt; stc++) {				if (mNewValues[iz][stc] != JOAConstants.MISSINGVALUE) {					mValues[iz][stc] = mNewValues[iz][stc];				}			}		}	}	public void doInterpUp() {		// initialize some constants		double physHigh, physLow, interpLow, interpHigh, delta;		int newSign, oldSign;		int c1Pos = 0, c2Pos = 0, c3Pos = 0, c4Pos = 0;		boolean doIt = false;		double c1Val = 0.0, c2Val = 0.0, c3Val = 0.0, c4Val = 0.0;		// mean cast collector		double[] levelSum = new double[mNumLevels];		int[] levelCount = new int[mNumLevels];		int stnCnt = -1;		if (mIsResidualInterp && !mUseMeanCastValuesFromFile) {			for (int iz = 0; iz < mNumLevels; iz++) {				levelSum[iz] = 0;				levelCount[iz] = 0;			}		}		// set the extrapolate clip values		mClipMin = mInterpParam.getPlotMin();		mClipMax = mInterpParam.getPlotMin();		// interpolate		// loop over each level		for (int iz = mNumLevels - 1; iz >= 0; iz--) {			// init the values at this level to missing			for (int i = 0; i < mTotalStns; i++) {				mValues[iz][i] = JOAConstants.MISSINGVALUE;			}			// use a counter			stnCnt = -1;			// loop over the files			for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {				OpenDataFile of = (OpenDataFile) mFileViewer.mOpenFiles.elementAt(fc);				// loop over the sections				for (int sec = 0; sec < of.mNumSections; sec++) {					Section sech = (Section) of.mSections.elementAt(sec);					if (sech.mNumCasts == 0) {						continue;					}					;					int iPos = sech.getVarPos(mInterpParam.getVarName(), false);					int sPos = sech.getVarPos(mFileViewer.mAllProperties[mSurfaceParamNum].mVarLabel, false);					if (iPos < 0 || sPos < 0) {						continue;					}					if (mFileViewer.mObsFilterActive) {						if (mFileViewer.mCurrObsFilter.isCriteria1Active()) {							c1Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(0)]							    .getVarLabel(), false);						}						if (mFileViewer.mCurrObsFilter.isCriteria2Active()) {							c2Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(1)]							    .getVarLabel(), false);						}						if (mFileViewer.mCurrObsFilter.isCriteria3Active()) {							c3Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(2)]							    .getVarLabel(), false);						}						if (mFileViewer.mCurrObsFilter.isCriteria4Active()) {							c4Pos = sech.getVarPos(mFileViewer.mAllProperties[mFileViewer.mCurrObsFilter.getParamIndex(3)]							    .getVarLabel(), false);						}					}					// loop over the stations					for (int stc = 0; stc < sech.mStations.size(); stc++) {						Station sh = (Station) sech.mStations.elementAt(stc);						if (sh.mUseStn) {							stnCnt++;							// initialize the result to missing							mValues[iz][stnCnt] = JOAConstants.MISSINGVALUE;							// initialize the sign variable from last bottle							Bottle bh = (Bottle) sh.mBottles.elementAt(sh.mNumBottles - 1);							physHigh = bh.mDValues[sPos];							delta = physHigh - mSurfaceValues[iz];							oldSign = 0;							if (delta > 0) {								oldSign = PLUS;							}							else if (delta < 0) {								oldSign = MINUS;							}							else {								oldSign = ZERO;							}							doIt = false;							// loop over the bottles							for (int b = sh.mNumBottles - 1; b >= 0; b--) {								bh = (Bottle) sh.mBottles.elementAt(b);								double val = bh.mDValues[sPos];								if (val != JOAConstants.MISSINGVALUE) {									physHigh = val;									doIt = true;								}								/*								 * else { // look for a non missing value on the surrounding								 * casts if (stc > 0 && stc < sech.mStations.size()-1) { //								 * there are bounding stations Station firstStn =								 * (Station)sech.mStations.elementAt(stnCnt-1); Station								 * secondStn = (Station)sech.mStations.elementAt(stnCnt+1);								 * Bottle myBH = (Bottle)firstStn.mBottles.elementAt(b);								 * testDepth1 = myBH.mDValues[pPos]; Bottle foundBottle =								 * findClosestBottle(firstStn, testDepth1, pPos); if								 * (foundBottle != null) { // check for a match in the second								 * stn Bottle myBH2 = (Bottle)secondStn.mBottles.elementAt(b);								 * testDepth2 = myBH2.mDValues[pPos]; foundBottle =								 * findClosestBottle(firstStn, testDepth2, pPos); if								 * (foundBottle != null) { // found two matching								 * bottles--interpolate a new value physHigh =								 * (myBH.mDValues[iPos] + myBH2.mDValues[iPos])/2.0; doIt =								 * true; } // if foundBottle } // if foundBottle } // if stc } //								 * else								 */								if (doIt) {									delta = physHigh - mSurfaceValues[iz];									if (delta > 0) {										newSign = PLUS;									}									else if (delta < 0) {										newSign = MINUS;									}									else {										newSign = ZERO;									}									if (newSign == ZERO) {										// bottle and level are the same										if (bh.mDValues[iPos] != JOAConstants.MISSINGVALUE) {											mValues[iz][stnCnt] = bh.mDValues[iPos];											if (mIsResidualInterp && !mUseMeanCastValuesFromFile && mMeanCastStnList != null											    && mMeanCastStnList[stnCnt]) {												levelSum[iz] += mValues[iz][stnCnt];												levelCount[iz]++;											}											if (mFileViewer.mObsFilterActive) {												if (mFileViewer.mCurrObsFilter.isCriteria1Active()) {													c1Val = bh.mDValues[c1Pos];												}												if (mFileViewer.mCurrObsFilter.isCriteria2Active()) {													c2Val = bh.mDValues[c2Pos];												}												if (mFileViewer.mCurrObsFilter.isCriteria3Active()) {													c3Val = bh.mDValues[c3Pos];												}												if (mFileViewer.mCurrObsFilter.isCriteria4Active()) {													c4Val = bh.mDValues[c4Pos];												}												if (!mFileViewer.mCurrObsFilter.testValues(c1Val, c2Val, c3Val, c4Val, bh, c1Pos, c2Pos, c3Pos,												    c4Pos)) {													mValues[iz][stnCnt] = JOAConstants.MISSINGVALUE;												}											}											break;										} // if bh									} // if newSign									else if (oldSign != newSign && newSign != ZERO && bh.mOrdinal < sh.mNumBottles) {										// sign changes										Bottle prevBh = null;										// int fbc = 0;										int bb = b + 1;										if ((mInterpolationType == LOCAL_INTERPOLATION || mInterpolationType == FAR_FIELD_INTERPOLATION)										    && bb < sh.mNumBottles - 1) {											// search for a non-missing bottle value below current											// bottle											int fbc = 0;											do {												prevBh = (Bottle) sh.mBottles.elementAt(bb++);												fbc++;											} while (fbc < mFarBottleLimit && prevBh.mDValues[iPos] == JOAConstants.MISSINGVALUE											    && bb < sh.mNumBottles - 1);										}										else if (bb < sh.mNumBottles - 1) {											prevBh = (Bottle) sh.mBottles.elementAt(bb);										}										if (bh.mDValues[iPos] != JOAConstants.MISSINGVALUE && prevBh != null										    && prevBh.mDValues[iPos] != JOAConstants.MISSINGVALUE) {											physLow = prevBh.mDValues[sPos];											interpLow = bh.mDValues[iPos];											interpHigh = prevBh.mDValues[iPos];											mValues[iz][stnCnt] = (delta / (physHigh - physLow)) * (interpHigh - interpLow) + interpLow;											if (mIsResidualInterp && !mUseMeanCastValuesFromFile && mMeanCastStnList != null											    && mMeanCastStnList[stnCnt]) {												levelSum[iz] += mValues[iz][stnCnt];												levelCount[iz]++;											}											// test whether the interpolated values for the obs filter											// meet test											if (mFileViewer.mObsFilterActive) {												if (mFileViewer.mCurrObsFilter.isCriteria1Active()) {													interpLow = bh.mDValues[c1Pos];													interpHigh = prevBh.mDValues[c1Pos];													c1Val = (delta / (physHigh - physLow)) * (interpHigh - interpLow) + interpLow;												}												if (mFileViewer.mCurrObsFilter.isCriteria2Active()) {													interpLow = bh.mDValues[c2Pos];													interpHigh = prevBh.mDValues[c2Pos];													c2Val = (delta / (physHigh - physLow)) * (interpHigh - interpLow) + interpLow;												}												if (mFileViewer.mCurrObsFilter.isCriteria3Active()) {													interpLow = bh.mDValues[c3Pos];													interpHigh = prevBh.mDValues[c3Pos];													c3Val = (delta / (physHigh - physLow)) * (interpHigh - interpLow) + interpLow;												}												if (mFileViewer.mCurrObsFilter.isCriteria4Active()) {													interpLow = bh.mDValues[c4Pos];													interpHigh = prevBh.mDValues[c4Pos];													c4Val = (delta / (physHigh - physLow)) * (interpHigh - interpLow) + interpLow;												}												if (!mFileViewer.mCurrObsFilter.testValues(c1Val, c2Val, c3Val, c4Val, bh, c1Pos, c2Pos, c3Pos,												    c4Pos)) {													mValues[iz][stnCnt] = JOAConstants.MISSINGVALUE;												}											}										}										break;									}								} // if doIT							} // for b						} // if useStn					} // for stc				} // for sec			} // for fc		} // for iz				processBottom();		if (mFillEdges) {			processEdgesVertical(stnCnt);			processEdges(stnCnt);		}		// compute the mean cast		if (mIsResidualInterp) {			for (int iz = 0; iz < mNumLevels; iz++) {				if (!mUseMeanCastValuesFromFile) {					// use computed values					if (levelCount[iz] >= 1) {						mMeanValues[iz] = levelSum[iz] / (double) levelCount[iz];						for (int s = 0; s < stnCnt + 1; s++) {							if (mValues[iz][s] != JOAConstants.MISSINGVALUE) {								mValues[iz][s] -= mMeanValues[iz];							}						}					}					else {						for (int s = 0; s < stnCnt + 1; s++) {							mValues[iz][s] = JOAConstants.MISSINGVALUE;						}					}				}				else {					// use mean cast from external file					double meanVal = mMeanCastValuesFromFile[iz].getV();					for (int s = 0; s < stnCnt + 1; s++) {						if (mValues[iz][s] != JOAConstants.MISSINGVALUE && meanVal != JOAConstants.MISSINGVALUE) {							mValues[iz][s] -= meanVal;						}						else {							mValues[iz][s] = JOAConstants.MISSINGVALUE;						}					}				}			}		}	}		public void doSimpleInterpUp() {		// initialize some constants		double physHigh, physLow, interpLow, interpHigh, delta;		int newSign, oldSign;		boolean doIt = false;		int stnCnt = -1;		// set the extrapolate clip values		mClipMin = mInterpParam.getPlotMin();		mClipMax = mInterpParam.getPlotMin();		// interpolate		// loop over each level		for (int iz = mNumLevels - 1; iz >= 0; iz--) {			// init the values at this level to missing			for (int i = 0; i < mTotalStns; i++) {				mValues[iz][i] = JOAConstants.MISSINGVALUE;			}			// use a counter			stnCnt = -1;			// loop over the files			for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {				OpenDataFile of = (OpenDataFile) mFileViewer.mOpenFiles.elementAt(fc);				// loop over the sections				for (int sec = 0; sec < of.mNumSections; sec++) {					Section sech = (Section) of.mSections.elementAt(sec);					if (sech.mNumCasts == 0) {						continue;					}					int iPos = sech.getVarPos(mInterpParam.getVarName(), false);					int sPos = sech.getVarPos(mFileViewer.mAllProperties[mSurfaceParamNum].mVarLabel, false);					if (iPos < 0 || sPos < 0) {						continue;					}					// loop over the stations					for (int stc = 0; stc < sech.mStations.size(); stc++) {						Station sh = (Station) sech.mStations.elementAt(stc);						if (sh.mUseStn) {							stnCnt++;							// initialize the result to missing							mValues[iz][stnCnt] = JOAConstants.MISSINGVALUE;							// initialize the sign variable from last bottle							Bottle bh = (Bottle) sh.mBottles.elementAt(sh.mNumBottles - 1);							physHigh = bh.mDValues[sPos];							delta = physHigh - mSurfaceValues[iz];							oldSign = 0;							if (delta > 0) {								oldSign = PLUS;							}							else if (delta < 0) {								oldSign = MINUS;							}							else {								oldSign = ZERO;							}							doIt = false;							// loop over the bottles							for (int b = sh.mNumBottles - 1; b >= 0; b--) {								bh = (Bottle) sh.mBottles.elementAt(b);								double val = bh.mDValues[sPos];								if (val != JOAConstants.MISSINGVALUE) {									physHigh = val;									doIt = true;								}								if (doIt) {									delta = physHigh - mSurfaceValues[iz];									if (delta > 0) {										newSign = PLUS;									}									else if (delta < 0) {										newSign = MINUS;									}									else {										newSign = ZERO;									}									if (newSign == ZERO) {										// bottle and level are the same										if (bh.mDValues[iPos] != JOAConstants.MISSINGVALUE) {											mValues[iz][stnCnt] = bh.mDValues[iPos];											break;										} // if bh									} // if newSign									else if (oldSign != newSign && newSign != ZERO && bh.mOrdinal < sh.mNumBottles) {										// sign changes										Bottle prevBh = null;										// int fbc = 0;										int bb = b + 1;										if ((mInterpolationType == LOCAL_INTERPOLATION || mInterpolationType == FAR_FIELD_INTERPOLATION)										    && bb < sh.mNumBottles - 1) {											// search for a non-missing bottle value below current											// bottle											int fbc = 0;											do {												prevBh = (Bottle) sh.mBottles.elementAt(bb++);												fbc++;											} while (fbc < mFarBottleLimit && prevBh.mDValues[iPos] == JOAConstants.MISSINGVALUE											    && bb < sh.mNumBottles - 1);										}										else if (bb < sh.mNumBottles - 1) {											prevBh = (Bottle) sh.mBottles.elementAt(bb);										}										if (bh.mDValues[iPos] != JOAConstants.MISSINGVALUE && prevBh != null										    && prevBh.mDValues[iPos] != JOAConstants.MISSINGVALUE) {											physLow = prevBh.mDValues[sPos];											interpLow = bh.mDValues[iPos];											interpHigh = prevBh.mDValues[iPos];											mValues[iz][stnCnt] = (delta / (physHigh - physLow)) * (interpHigh - interpLow) + interpLow;										}										break;									}								} // if doIT							} // for b						} // if useStn					} // for stc				} // for sec			} // for fc		} // for iz				processBottomSimple();		if (mFillEdges) {			processEdgesVertical(stnCnt);			processEdges(stnCnt);		}	}	public Bottle findClosestBottle(Vector<Bottle> botts, double testVal, int spos) {		double dist = 6000;		Bottle retBot = null;		for (int b = 0; b < botts.size(); b++) {			Bottle bh = (Bottle) botts.elementAt(b);			double sval = bh.mDValues[spos];			double del = Math.abs(sval - testVal);			if (del < dist) {				dist = del;				retBot = bh;			}			else if (del > dist) { return retBot; }		}		return null;	}	public int getLevels() {		return mNumLevels;	}	public int getNumStns() {		return mTotalStns;	}	public JOAVariable getParam() {		return mInterpParam;	}	public int getSurfParamNum() {		return mSurfaceParamNum;	}	public String getName() {		return mName;	}	public void setName(String s) {		mName = s;	}	public String getParamName() {		return mParam;	}	public void setParamName(String s) {		mParam = s;	}	public NewInterpolationSurface getSurface() {		return mSurface;	}	public double getMinValue() {		if (mMin != JOAConstants.MISSINGVALUE) { return mMin; }		double min = 1e10;		for (int i = 0; i < mNumLevels; i++) {			for (int j = 0; j < mTotalStns; j++) {				if (mValues[i][j] != JOAConstants.MISSINGVALUE) {					min = mValues[i][j] < min ? mValues[i][j] : min;				}			}		}		mMin = min;		// System.out.println("mMin=" + mMin);		return mMin;	}	public double getMaxValue() {		if (mMax != JOAConstants.MISSINGVALUE) { return mMax; }		double max = -1e10;		for (int i = 0; i < mNumLevels; i++) {			for (int j = 0; j < mTotalStns; j++) {				max = mValues[i][j] != JOAConstants.MISSINGVALUE && mValues[i][j] > max ? mValues[i][j] : max;				// if(max > 2.0) {				// System.out.println(i + " " + j + " max=" + max);				// }			}		}		mMax = max;		// System.out.println("mMax=" + mMax);		return mMax;	}	public double[][] getValues() {		return mValues;	}	public double[] getDistValues() {		return mDistValues;	}	public double[] getBottomDepths() {		return mBottomDepths;	}	public double[] getLatValues() {		return mLatValues;	}	public double[] getLonValues() {		return mLonValues;	}	public String[] getStnValues() {		return mStnValues;	}	public void dereference() {		if (mRefLevel == JOAConstants.MISSINGVALUE) { return; }		// compute dereferenced interpolation		int row1 = 0, row2 = 0, iSame = 0;		double datum, delta1 = 0.0, delta2 = 0.0;		double part1, part2, theRef, theRef1, theRef2;		boolean flag1, flag2;		// Test for refLevel matching an interpolation surface.		flag1 = false;		for (int i = 0; i < mNumLevels; i++) {			if (mSurfaceValues[i] == JOAConstants.MISSINGVALUE) {				continue;			}			flag1 = (mRefLevel - mSurfaceValues[i]) == 0;			if (flag1) {				iSame = i;				break;			}		}		flag2 = false;		for (int i = 0; i < mNumLevels - 1; i++) {			if (mSurfaceValues[i] == JOAConstants.MISSINGVALUE) {				continue;			}			if (mSurfaceValues[i + 1] == JOAConstants.MISSINGVALUE) {				continue;			}			delta1 = mRefLevel - mSurfaceValues[i];			delta2 = mRefLevel - mSurfaceValues[i + 1];			flag2 = ((delta1 > 0) ^ (delta2 > 0));			if (flag2) {				row1 = i;				row2 = i + 1;				break;			}		}		if (!flag2 && !flag1) {			;// return -1; // Error: invalid reference level.		}		if (flag1) {			flag2 = false;			for (int j = 0; j < mTotalStns; j++) {				theRef = mValues[iSame][j];				for (int i = 0; i < mNumLevels; i++) {					datum = mValues[i][j];					if (datum == JOAConstants.MISSINGVALUE) {						continue;					}					datum = (theRef == JOAConstants.MISSINGVALUE) ? theRef : datum - theRef;					mValues[i][j] = datum;				}			}		}		if (flag2) {			delta1 = Math.abs(delta1);			delta2 = Math.abs(delta2);			part1 = delta2 / (delta1 + delta2);			part2 = delta1 / (delta1 + delta2);			for (int j = 0; j < mTotalStns; j++) {				theRef1 = mValues[row1][j];				theRef2 = mValues[row2][j];				theRef = part1 * theRef1 + part2 * theRef2;				theRef = (theRef1 == JOAConstants.MISSINGVALUE) ? JOAConstants.MISSINGVALUE : theRef;				theRef = (theRef2 == JOAConstants.MISSINGVALUE) ? JOAConstants.MISSINGVALUE : theRef;				for (int i = 0; i < mNumLevels; i++) {					datum = mValues[i][j];					if (datum == JOAConstants.MISSINGVALUE) {						continue;					}					datum = (theRef == JOAConstants.MISSINGVALUE) ? theRef : datum - theRef;					mValues[i][j] = datum;				}			}		}	}	protected void farFieldFill() {		int l1 = 0, l2 = 0;		double d1 = 0.0, d2 = 0.0;		boolean interpF = false;		if (mTotalStns <= 0) { return; }		for (int j = 1; j < mTotalStns - 1; j++) { // loop across from 2nd station			// to last-1			int i = 0;			while (i < mNumLevels) { // Loop down while there are more points				while (i < mNumLevels) { // Scan ahead to a bad point					interpF = (mValues[i][j] == JOAConstants.MISSINGVALUE);					if (interpF) {						break;					}					i++;				}				if (!interpF) {					continue; // If no bad point, skip to end of loop.				}				// found a missing point in the interp				for (int k = 1; k <= mTotalStns; k++) { // Look backward for a good					// point.					l1 = (j - k < 0) ? 0 : k;					if (mUseFarFieldLimit) {						// compute distance between j and j-l1						double deltaDist = Math.abs(mDistValues[j] - mDistValues[j - l1]);						if (deltaDist > mFarFieldLimit) {							d1 = JOAConstants.MISSINGVALUE;							break;						}					}					d1 = mValues[i][j - l1];					if (d1 != JOAConstants.MISSINGVALUE) {						break;					}				}				if (d1 != JOAConstants.MISSINGVALUE) {					// found a back point, now look for a forward point					for (int k = 1; k <= mTotalStns; k++) { // Look forward for a good						// point						if (j + k < mTotalStns) {							if (mUseFarFieldLimit) {								// compute distance between j and j+k								double deltaDist = Math.abs(mDistValues[j] - mDistValues[j + k]);								if (deltaDist > mFarFieldLimit) {									d2 = JOAConstants.MISSINGVALUE;									break;								}							}							d2 = mValues[i][j + k];							l2 = k;						}						else {							if (mUseFarFieldLimit) {								// compute distance between j and mTotalStns-1								double deltaDist = Math.abs(mDistValues[j] - mDistValues[mTotalStns - 1]);								if (deltaDist > mFarFieldLimit) {									d2 = JOAConstants.MISSINGVALUE;									break;								}							}							d2 = mValues[i][mTotalStns - 1];							l2 = mTotalStns - 1 - j;						}						if (d2 != JOAConstants.MISSINGVALUE) {							break;						}					}				}				if (d1 != JOAConstants.MISSINGVALUE && d2 != JOAConstants.MISSINGVALUE) {					mValues[i][j] = (l2 * d1 + l1 * d2) / (l1 + l2);					if (Double.isNaN(mValues[i][j])) {						System.out.println("l2 =" + l2);						System.out.println("d1 =" + d1);						System.out.println("l1 =" + l1);						System.out.println("d2 =" + d2);					}				}				i++;			} // End of loop down		} // End of loop across stations	}	public boolean isResidualInterp() {		return mIsResidualInterp;	}	public int getInterpolationType() {		return mInterpolationType;	}	/*	 * Regridding assumes that both interpolations are on the same y grid the	 * grids overlap (otherwise routine wouldn't be called)	 * 	 */	public Vector<Object>[] regridToUnionandDifference(LinearInterpolation otherGrid, int horzGridMode) {		return null;	}		private double combineVals(int op, double a, double b) {		if (op == JOAConstants.PLUS_OP) {			return a + b;		}		else if (op == JOAConstants.MINUS_OP) {			return a - b;		}		return JOAConstants.MISSINGVALUE;	}	@SuppressWarnings("unchecked")	public Vector<Object>[] regridAndCombine(int op, LinearInterpolation bGrid, int horzGridMode, boolean diffFlag,	    double maxDist, boolean rvsDiff) {		/*		 * this regridding works by interpolating the values in this interpolation		 * to the lat or lon locations of the bGrid The results are a vector of new		 * profiles for the variable represented by this interpolation		 */		Vector[] results = new Vector[2];		results[0] = new Vector<double[]>();		results[1] = new Vector<UVCoordinate>();		int newStnCnt = 0;		if (horzGridMode == JOAConstants.REGRID_MODE_LAT) {			double[][] bVals = bGrid.getValues();			double[][] aVals = this.getValues();			double[] bLats = bGrid.getLatValues();			double[] bLons = bGrid.getLonValues();			double[] bBottoms = bGrid.getBottomDepths();			double[] aLats = this.getLatValues();			int numBStns = bGrid.getNumStns();			int numAStns = this.getNumStns();			// loop on the profiles in the 'b' interpolation (the interp based to this			// return)			// interpolating to the locations in the 'b' interpolation			for (int i = 0; i < numBStns; i++) {				// want to interpolate a value to this location				double bLat = bLats[i];				double bLon = bLons[i];				double bBottom = bBottoms[i];				// this is the destination profile				double[] newProfile = null;				// search the 'a' interpolation (this object) for bounding stations				double prevLat = aLats[0];				for (int j = 1; j < numAStns; j++) {					double aLat = aLats[j];							if (bLat == prevLat) {						// this is where the new profile is going to go						newProfile = new double[mNumLevels];						for (int z = 0; z < mNumLevels; z++) {							newProfile[z] = JOAConstants.MISSINGVALUE;						}												// can directly difference						for (int z = 0; z < mNumLevels; z++) {							if (aVals[z][0] != JOAConstants.MISSINGVALUE && bVals[z][i] != JOAConstants.MISSINGVALUE) {								if (rvsDiff) {									newProfile[z] = combineVals(op, bVals[z][i], aVals[z][0]);								}								else {									newProfile[z] = combineVals(op, aVals[z][0], bVals[z][i]);								}							}						}						double newStnLat = bLat;						double newStnLon = bLon;						UVCoordinate loc = new UVCoordinate(newStnLon, newStnLat, bBottom);						results[0].add(newProfile);						results[1].add(loc);						newStnCnt++;						break;						}					else if (bLat == aLat) {						// this is where the new profile is going to go						newProfile = new double[mNumLevels];						for (int z = 0; z < mNumLevels; z++) {							newProfile[z] = JOAConstants.MISSINGVALUE;						}												// can directly difference						for (int z = 0; z < mNumLevels; z++) {							if (aVals[z][j] != JOAConstants.MISSINGVALUE && bVals[z][i] != JOAConstants.MISSINGVALUE) {								if (rvsDiff) {									newProfile[z] = combineVals(op, bVals[z][i], aVals[z][0]);								}								else {									newProfile[z] = combineVals(op, aVals[z][0], bVals[z][i]);								}							}						}						double newStnLat = bLat;						double newStnLon = bLon;						UVCoordinate loc = new UVCoordinate(newStnLon, newStnLat, bBottom);						results[0].add(newProfile);						results[1].add(loc);						newStnCnt++;						break;						}					else if	(aLat > bLat && prevLat < bLat && (Math.abs(aLat - bLat) < maxDist && Math.abs(prevLat - bLat) < maxDist)) {						// found bounding stations in 'a' around the location in 'b'						// this is where the new profile is going to go						newProfile = new double[mNumLevels];						for (int z = 0; z < mNumLevels; z++) {							newProfile[z] = JOAConstants.MISSINGVALUE;						}						// interpolate and make new difference cast						double deltaLat = aLat - prevLat;						double del = bLat - prevLat;						for (int z = 0; z < mNumLevels; z++) {							double prevInterpVal = mValues[z][j - 1];							double interpVal = mValues[z][j];							if (prevInterpVal == JOAConstants.MISSINGVALUE || interpVal == JOAConstants.MISSINGVALUE							    || bVals[z][i] == JOAConstants.MISSINGVALUE) {								newProfile[z] = JOAConstants.MISSINGVALUE;								continue;							}							double iSlope = (interpVal - prevInterpVal) / deltaLat;							double predictedInterpVal = iSlope * del + prevInterpVal;							if (diffFlag) {								// compute the difference														if (rvsDiff) {									newProfile[z] = combineVals(op, bVals[z][i], predictedInterpVal);								}								else {									newProfile[z] = combineVals(op, predictedInterpVal, bVals[z][i]);								}							}							else {								newProfile[z] = predictedInterpVal;							}						}						double newStnLat = bLat;						double newStnLon = bLon;						UVCoordinate loc = new UVCoordinate(newStnLon, newStnLat, bBottom);						results[0].add(newProfile);						results[1].add(loc);						newStnCnt++;						break;					}					prevLat = aLat;				}			}			return results;		}		else {  //difference in longitude			double[][] bVals = bGrid.getValues();			double[][] aVals = this.getValues();			double[] bLats = bGrid.getLatValues();			double[] bLons = bGrid.getLonValues();			double[] bBottoms = bGrid.getBottomDepths();			double[] aLons = this.getLonValues();			int numBStns = bGrid.getNumStns();			int numAStns = this.getNumStns();			// loop on the profiles in the 'b' interpolation (the interp based to this			// return)			// interpolating to the locations in the 'b' interpolation			for (int i = 0; i < numBStns; i++) {				// want to interpolate a value to this location				double bLon = bLons[i];				double bLon0 = bLons[i];				double bLat = bLats[i];				double bBottom = bBottoms[i];				// this is the destination profile				double[] newProfile = null;				// search the 'a' interpolation (this object) for bounding stations				double prevLon = aLons[0];				if (prevLon < 0) {					prevLon += 360;				}				for (int j = 1; j < numAStns; j++) {					double aLon = aLons[j];					if (aLon < 0) {						aLon += 360;					}					if (bLon < 0) {						bLon += 360;					}					if (bLon == prevLon) {						// this is where the new profile is going to go						newProfile = new double[mNumLevels];						for (int z = 0; z < mNumLevels; z++) {							newProfile[z] = JOAConstants.MISSINGVALUE;						}												// can directly difference						for (int z = 0; z < mNumLevels; z++) {							if (aVals[z][0] != JOAConstants.MISSINGVALUE && bVals[z][i] != JOAConstants.MISSINGVALUE) {								if (rvsDiff) {									newProfile[z] = combineVals(op, bVals[z][i], aVals[z][0]);								}								else {									newProfile[z] = combineVals(op, aVals[z][0], bVals[z][i]);								}							}						}						double newStnLat = bLat;						double newStnLon = bLon;						UVCoordinate loc = new UVCoordinate(newStnLon, newStnLat, bBottom);						results[0].add(newProfile);						results[1].add(loc);						newStnCnt++;						break;						}					else if (bLon == aLon) {						// this is where the new profile is going to go						newProfile = new double[mNumLevels];						for (int z = 0; z < mNumLevels; z++) {							newProfile[z] = JOAConstants.MISSINGVALUE;						}												// can directly difference						for (int z = 0; z < mNumLevels; z++) {							if (aVals[z][j] != JOAConstants.MISSINGVALUE && bVals[z][i] != JOAConstants.MISSINGVALUE) {								if (rvsDiff) {									newProfile[z] = combineVals(op, bVals[z][i], aVals[z][0]);								}								else {									newProfile[z] = combineVals(op, aVals[z][0], bVals[z][i]);								}							}						}						double newStnLat = bLat;						double newStnLon = bLon;						UVCoordinate loc = new UVCoordinate(newStnLon, newStnLat, bBottom);						results[0].add(newProfile);						results[1].add(loc);						newStnCnt++;						break;						}					else if (aLon > bLon && prevLon < bLon && (Math.abs(aLon - bLon) < maxDist && Math.abs(prevLon - bLon) < maxDist)) {						// found bounding stations in 'a' around the location in 'b'						// this is where the new profile is going to go						newProfile = new double[mNumLevels];						for (int z = 0; z < mNumLevels; z++) {							newProfile[z] = JOAConstants.MISSINGVALUE;						}						// interpolate and make new difference cast						double deltaLon = aLon - prevLon;						double del = bLon - prevLon;						for (int z = 0; z < mNumLevels; z++) {							double prevInterpVal = mValues[z][j - 1];							double interpVal = mValues[z][j];							if (prevInterpVal == JOAConstants.MISSINGVALUE || interpVal == JOAConstants.MISSINGVALUE							    || bVals[z][i] == JOAConstants.MISSINGVALUE) {								newProfile[z] = JOAConstants.MISSINGVALUE;								continue;							}							double iSlope = (interpVal - prevInterpVal) / deltaLon;							double predictedInterpVal = iSlope * del + prevInterpVal;							// System.out.println(prevInterpVal + " " + predictedInterpVal + "							// " + interpVal);							// compute the difference												if (rvsDiff) {								newProfile[z] = combineVals(op, bVals[z][i], predictedInterpVal);							}							else {								newProfile[z] = combineVals(op, predictedInterpVal, bVals[z][i]);							}						}						UVCoordinate loc = new UVCoordinate(bLon0, bLat, bBottom);						results[0].add(newProfile);						results[1].add(loc);						newStnCnt++;						break;					}					prevLon = aLon;				}			}			return results;		}	}	public void dump() {		System.out.println("mNumLevels = " + mNumLevels);		System.out.println("mNumStns= " + mTotalStns);		System.out.println("mInterpParam = " + mInterpParam);		System.out.println("mSurfaceParamNum = " + mSurfaceParamNum);		System.out.println("mSurface = " + mSurface.getParam());		System.out.println("mName = " + mName);		System.out.println("mParam = " + mParam);		System.out.println("mValues = " + mValues.length);	}	public void writeToLog(String preamble) throws IOException {		try {			String dirText = "down";			if (!mTopDown) {				dirText = "up";			}			JOAConstants.LogFileStream.writeBytes(preamble + "\n");			JOAConstants.LogFileStream.writeBytes("\t" + "Param = " + mInterpParam + ", Surf. = " + mSurface.getTitle() + " "			    + mSurface.getDescrip() + ", interp direction = " + dirText + ", clip extrapolated = "			    + String.valueOf(mClipExtrapolatedValues) + ", fill edges = " + String.valueOf(mFillEdges) + "\n");			// missing value stuff			if (mInterpolationType != NO_MISSING_INTERPOLATION) {				if (mInterpolationType == FAR_FIELD_INTERPOLATION) {					JOAConstants.LogFileStream.writeBytes("\t" + "Missing value option = far field interp,  max #std levels = "					    + String.valueOf(mFarStdLevelLimit));					JOAConstants.LogFileStream.writeBytes(", max #stns left and right = " + String.valueOf(mFarStationLimit));					if (mUseFarFieldLimit) {						JOAConstants.LogFileStream.writeBytes(", max dist = " + JOAFormulas.formatDouble(mFarFieldLimit, 3, false));					}				}				else if (mInterpolationType == LOCAL_INTERPOLATION || mInterpolationType == FAR_FIELD_INTERPOLATION) {					JOAConstants.LogFileStream.writeBytes("\t" + "Missing value option = local interp,  max #obs = "					    + String.valueOf(mFarBottleLimit));				}				JOAConstants.LogFileStream.writeBytes("\n");			}			else {				JOAConstants.LogFileStream.writeBytes("\t" + "No Missing value processing" + "\n");			}			// reference stuff			if (mIsResidualInterp) {				if (mUseMeanCastValuesFromFile) {					// mean cast from file					JOAConstants.LogFileStream.writeBytes("\t" + "Referenced to mean cast in file = " + mMeanCastFV);				}				else if (mRefLevel != JOAConstants.MISSINGVALUE) {					// residual from reference value					JOAConstants.LogFileStream.writeBytes("\t" + "Referenced to value = "					    + JOAFormulas.formatDouble(mRefLevel, 3, false));				}				else {					// computed mean cast					JOAConstants.LogFileStream.writeBytes("\t" + "Referenced to computed mean cast");				}				JOAConstants.LogFileStream.writeBytes("\n");			}			JOAConstants.LogFileStream.flush();		}		catch (IOException ex) {			throw ex;		}	}	public void computeHorzGradient(boolean isVelocity) {		// makes a new array based at the mid points between casts		double[][] gradientMatrix = new double[mNumLevels][mTotalStns];		double[] midDistances = new double[mTotalStns];		for (int i = 0; i < mNumLevels; i++) {			for (int j = 0; j < mTotalStns; j++) {				gradientMatrix[i][j] = JOAConstants.MISSINGVALUE;			}		}		int numMidStns = 0;		for (int i = 0; i < mNumLevels; i++) {			double oldMid = 0.0;			double midLat = 0.0;			int iCross = -1;			int c = 0;			for (int j0 = 0, j1 = 1; j1 < mTotalStns; j0++, j1++) {				double datum0 = mValues[i][j0];				double datum1 = mValues[i][j1];				double dist0 = JOAConstants.NAUT2METERS * mDistValues[j0];				double dist1 = JOAConstants.NAUT2METERS * mDistValues[j1];				if (datum0 == JOAConstants.MISSINGVALUE || datum1 == JOAConstants.MISSINGVALUE) {					c++;					continue;				}				double grad = (datum1 - datum0) / (dist1 - dist0);				midDistances[c] = dist0 + (0.5 * (dist1 - dist0));				if (isVelocity) {					midLat = (0.5 * (mLatValues[j0] + mLatValues[j1])) * JOAConstants.F;					double f = JOAConstants.TWOOMEGA * Math.sin(midLat);					if (midLat * oldMid < 0.0) {						iCross = j0;					}					gradientMatrix[i][c] = grad / f;				}				else {					gradientMatrix[i][c] = grad;				}				oldMid = midLat;				c++;			}			if (i == 0) {				numMidStns = c;			}			if (iCross != -1) {				// crossed the equator				double datum0 = gradientMatrix[i][iCross];				double datum1 = gradientMatrix[i][iCross + 1];				datum1 = (datum0 == JOAConstants.MISSINGVALUE) ? JOAConstants.MISSINGVALUE : datum1;				datum0 = (datum1 == JOAConstants.MISSINGVALUE) ? JOAConstants.MISSINGVALUE : datum0;				datum0 = 0.5 * (datum0 + datum1);				gradientMatrix[i][iCross] = datum0;				gradientMatrix[i][iCross + 1] = datum0;			}		}		// set the first and last columns to missing		for (int i = 0; i < mNumLevels; i++) {			mValues[i][0] = JOAConstants.MISSINGVALUE;			mValues[i][mTotalStns - 1] = JOAConstants.MISSINGVALUE;		}		// interpolate the velocity back onto the original grid		for (int i = 0; i < mNumLevels; i++) {			for (int c = 0; c < numMidStns; c++) {				double gradVal0 = gradientMatrix[i][c];				double gradVal1 = gradientMatrix[i][c + 1];				if (gradVal0 == JOAConstants.MISSINGVALUE || gradVal1 == JOAConstants.MISSINGVALUE) {					mValues[i][c] = JOAConstants.MISSINGVALUE;					continue;				}				double gradDist0 = midDistances[c];				double gradDist1 = midDistances[c + 1];				double deltaGradVal = gradVal0 - gradVal1;				double ratio = ((JOAConstants.NAUT2METERS * mDistValues[c]) - gradDist0) / (gradDist1 - gradDist0);				mValues[i][c] = gradVal0 + (ratio * deltaGradVal);			}		}	}	public boolean isOnSameGrid(LinearInterpolation inGrid) {		NewInterpolationSurface inSurf = inGrid.getSurface();		double[] tSurfLevels = inSurf.getValues();		return this.getSurface().equalGrids(tSurfLevels, inSurf.getNumLevels());	}	public void multiplyBy(LinearInterpolation inGrid) {		// on the same grid?		if (!isOnSameGrid(inGrid)) { return; }		// multiply		double[][] inVals = inGrid.getValues();		for (int i = 0; i < mNumLevels; i++) {			for (int j = 0; j < mTotalStns; j++) {				if (inVals[i][j] != JOAConstants.MISSINGVALUE && mValues[i][j] != JOAConstants.MISSINGVALUE) {					mValues[i][j] = mValues[i][j] * inVals[i][j];				}				else {					mValues[i][j] = JOAConstants.MISSINGVALUE;				}			}		}	}	public void integrate(int direc, boolean up) {	}	public double getTotalDistance() {		return mFileViewer.mTotMercDist;	}	public double getTotalLatitude() {		return mFileViewer.mTotLatDegs;	}	public double getTotalLongitude() {		return mFileViewer.getLonRange();	}	public double getTotalTime() {		return mFileViewer.getTimeLength();	}	/*	 * (non-Javadoc)	 * 	 * @see javaoceanatlas.utility.Interpolation#getNumUsedStations()	 */	public int getNumUsedStations() {		int numUsedStns = 0;		for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {			OpenDataFile of = (OpenDataFile) mFileViewer.mOpenFiles.elementAt(fc);			// loop over the sections			for (int sec = 0; sec < of.mNumSections; sec++) {				Section sech = (Section) of.mSections.elementAt(sec);				if (sech.mNumCasts == 0) {					continue;				}				// loop over the stations				for (int stc = 0; stc < sech.mStations.size(); stc++) {					Station sh = (Station) sech.mStations.elementAt(stc);					if (!sh.mUseStn) {						continue;					}					else {						numUsedStns++;					}				}			}		}		return numUsedStns;	}	/*	 * (non-Javadoc)	 * 	 * @see javaoceanatlas.utility.Interpolation#getDX()	 */	public double getDX() {		// TODO Auto-generated method stub		return 0;	}	/*	 * (non-Javadoc)	 * 	 * @see javaoceanatlas.utility.Interpolation#getClosestValue(int,	 *      javaoceanatlas.classicdatamodel.Station)	 */	public double getClosestValue(int level, Station sh) {		int interpCol = sh.mOrdinal - 1;		try {			return mValues[level][interpCol];		}		catch (Exception ex) {			return mValues[level][mValues[level].length-1];		}	}  public boolean isLocked() {	  return mLocked;  }  public void setLocked(boolean b) {  	mLocked = b;  }	/* (non-Javadoc)   * @see javaoceanatlas.utility.Interpolation#exportJSON(java.io.File)   */  public void exportJSON(File file) {   		JsonFactory f = new JsonFactory();		JsonGenerator jsonGen;		try {			// test to see if it exists			jsonGen = f.createJsonGenerator(file, JsonEncoding.UTF8);			jsonGen.setPrettyPrinter(new DefaultPrettyPrinter());			jsonGen.writeStartObject();			// key value pairs go here//			jsonGen.writeObjectFieldStart("contourplotspecification");		//			jsonGen.writeNumberField("offset", mOffset);//			jsonGen.writeNumberField("style", mStyle);//			jsonGen.writeNumberField("winyplotmax",  mWinYPlotMax);//			jsonGen.writeNumberField("winyplotmin", mWinYPlotMin);//			jsonGen.writeNumberField("markers", mMarkers);//			jsonGen.writeNumberField("markersize", mMarkerSize);//			jsonGen.writeBooleanField("plotaxes", mPlotAxes);//			jsonGen.writeBooleanField("includeCBAR", mIncludeCBAR);//			jsonGen.writeBooleanField("includeobspanel", mIncludeObsPanel);//			jsonGen.writeBooleanField("autoscalexaxis", mAutoScaleXAxis);//			jsonGen.writeBooleanField("browsingenabled", mBrowsingEnabled);//			jsonGen.writeNumberField("yinc", mYInc);//			jsonGen.writeNumberField("xaxisscale", mXAxisScale);//			jsonGen.writeNumberField("ytics", mYTics);//			jsonGen.writeNumberField("xtics",mXTics);//			jsonGen.writeStringField("windowtitle", mWindowName);//			jsonGen.writeStringField("yparam", mYParam.getVarName());//			String hexStr = Integer.toHexString(mFG.getRGB());//			jsonGen.writeStringField("fgcolor", "#" + hexStr);//			hexStr = Integer.toHexString(mBG.getRGB());//			jsonGen.writeStringField("bgcolor", "#" + hexStr);//			hexStr = Integer.toHexString(mSymbolColor.getRGB());//			jsonGen.writeStringField("connectstncolor", "#" + hexStr);//			jsonGen.writeBooleanField("colorlines", mColorLines);//			jsonGen.writeBooleanField("plotbottom", mPlotBottom);//			jsonGen.writeNumberField("width", mWidth);//			jsonGen.writeNumberField("height", mHeight);//			jsonGen.writeNumberField("ploteverynthcontour", mPlotEveryNthContour);//			jsonGen.writeNumberField("labeleverynthcontour", mLabelEveryNthContour);//			jsonGen.writeNumberField("labelprec", mLabelPrec);//			jsonGen.writeNumberField("skipxaxislabels", mSkipXAxisLabels);						jsonGen.writeEndObject(); // for field 'contourplotspecification'				 			jsonGen.close(); // important: will force flushing of output, close underlying								 // output stream		}		catch (IOException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} 	    }}