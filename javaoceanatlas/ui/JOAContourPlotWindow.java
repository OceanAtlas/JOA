/* * $Id: JOAContourPlotWindow.java,v 1.37 2005/09/23 14:51:24 oz Exp $ * */package javaoceanatlas.ui;import javax.swing.*;import java.awt.*;import java.awt.event.*;import java.util.*;import java.io.*;import javaoceanatlas.classicdatamodel.*;import javaoceanatlas.events.*;import javaoceanatlas.utility.*;import javaoceanatlas.specifications.*;import javaoceanatlas.resources.*;import javaoceanatlas.ui.widgets.*;import java.awt.geom.*;import java.awt.font.*;import java.awt.print.*;import com.visualtek.png.*;import gov.noaa.pmel.sgt.*;import gov.noaa.pmel.util.SoTRange;import gov.noaa.pmel.sgt.contour.*;import gov.noaa.pmel.sgt.dm.*;import javaoceanatlas.PowerOceanAtlas;@SuppressWarnings("serial")public class JOAContourPlotWindow extends JOAWindow implements DataAddedListener, ActionListener, ConfigurableWindow,    StnFilterChangedListener, ObsFilterChangedListener, PrefsChangedListener, WindowsMenuChangedListener {	protected FileViewer mFileViewer;	protected String mWinTitle;	protected int mWidth = 0, mHeight = 0, mLegendHeight = 0;	protected Interpolation mInterpolation = null;	protected Interpolation mOverlayInterpolation = null;	protected NewColorBar mColorBar = null;	protected NewColorBar mOverlayColorBar = null;	protected double mPlotMin = 0;	protected double mPlotMax = 0;	protected int mStyle;	protected int mOffset;	protected int mLabelMode;	protected int mMarkers;	protected int mMarkerSize;	protected int mOverlayMarkers;	protected int mOverlayMarkerSize;	protected boolean mLegend;	protected boolean mAxes;	protected boolean mCrossSections;	protected int mCurrLevel = 0;	protected ContourPlotPanel mContPlot = null;	protected VerticalXSecPanel mVXsec = null;	protected HorizontalXSecPanel mHXsec = null;	protected LevelDataPanel mLevelDisplay = null;	protected ColorBarDisplay mCbarDisplay = null;	protected int count = 0;	protected ContourPlotSpecification mPlotSpec;	protected Container mContents = null;	protected JPanel mSouthContainer = null;	protected JPanel mEastContainer = null;	protected JOAWindow mFrame = null;	protected JFrame mParent = null;	protected int mPlotEveryNthContour;	protected int mLabelEveryNthContour;	protected JOAContourPlotWindow mThis = null;	protected boolean mNtoSSection = false;	protected Color mSymbolColor;	ResourceBundle b = ResourceBundle.getBundle("javaoceanatlas.resources.JOAResources");	private boolean mOverlayContours;	private boolean mSameFV;	FileViewer mOverlayFileViewer;	boolean mSameProperties = false;	protected int mPlotEveryNthOvlContour;	protected int mLabelPrecision;	protected Station mFirstStation = null;	protected Station mLastStation = null;	protected Station mOverlayFirstStation = null;	protected Station mOverlayLastStation = null;	private StationRegion mStationRegion = null;	private JOAVariable interpVar;	private int surfVarNum;	private int overlaySurfVarNum;	private double[][] interpValues;	double[][] interpOvlValues;	private NewInterpolationSurface surface;	private double[] surfaceValues;	private int nz;	private int nsta;	private Color[] colors;	double[] contourValues;	int numContours;	public JOAContourPlotWindow(FileViewer fv, ContourPlotSpecification plotspec, JFrame parent) {		super(true, true, true, true, true, plotspec);		this.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);		mPlotSpec = plotspec;		mParent = parent;		mInterpolation = mPlotSpec.getInterp();		nz = mInterpolation.getLevels();		nsta = mInterpolation.getNumStns();		interpVar = mInterpolation.getParam();		surfVarNum = mInterpolation.getSurfParamNum();		interpValues = mInterpolation.getValues();		surface = mInterpolation.getSurface();		surfaceValues = surface.getValues();		if (mOverlayInterpolation != null) {			overlaySurfVarNum = mOverlayInterpolation.getSurfParamNum();		}		interpValues = mInterpolation.getValues();		surface = mInterpolation.getSurface();		surfaceValues = surface.getValues();		mOverlayInterpolation = mPlotSpec.getOverlayInterp();		mColorBar = mPlotSpec.getColorBar();		mColorBar.getNumLevels();		colors = mColorBar.getColors();		contourValues = mColorBar.getValues();		mWidth = mPlotSpec.getWidth();		mHeight = mPlotSpec.getHeight();		mFileViewer = fv;		mWinTitle = mPlotSpec.getWinTitle();		mPlotMin = mPlotSpec.getWinYPlotMin();		mPlotMax = mPlotSpec.getWinYPlotMax();		mStyle = mPlotSpec.getStyle();		mOffset = mPlotSpec.getOffset();		mLabelMode = mPlotSpec.getXAxisLabels();		mMarkers = mPlotSpec.getMarkers();		mOverlayMarkers = mPlotSpec.getOverlayMarkers();		mMarkerSize = mPlotSpec.getMarkerSize();		mOverlayMarkerSize = mPlotSpec.getOverlayMarkerSize();		mLegend = mPlotSpec.isIncludeCBAR();		// mIncludeObsPanel = mPlotSpec.mIncludeObsPanel;		mAxes = mPlotSpec.isPlotAxes();		mCrossSections = mPlotSpec.isBrowsingEnabled();		mPlotEveryNthContour = mPlotSpec.getPlotEveryNthContour();		mLabelEveryNthContour = mPlotSpec.getLabelEveryNthContour();		mSymbolColor = mPlotSpec.getSymbolColor();		mOverlayContours = mPlotSpec.isOverlayContours();		mLabelPrecision = mPlotSpec.getLabelPrecision();		if (mOverlayInterpolation != null) {			mOverlayFileViewer = mOverlayInterpolation.getParam().getFileViewer();			mSameFV = mFileViewer == mOverlayFileViewer;			mSameProperties = mInterpolation.getParam().equals(mOverlayInterpolation.getParam());			mPlotEveryNthOvlContour = mPlotSpec.getPlotEveryNthOvlContour();		}		mThis = this;		init();	}	public StationRegion getStationRegion() {		return mStationRegion;	}	private void findFirstLastStation() {		mFirstStation = mFileViewer.findFirstStation();		mLastStation = mFileViewer.findLastStation();		if (mOverlayFileViewer != null) {			mOverlayFirstStation = mOverlayFileViewer.findFirstStation();			mOverlayLastStation = mOverlayFileViewer.findLastStation();		}	}	public void init() {		mFrame = this;		mContents = this.getContentPane();		mContents.setLayout(new BorderLayout(0, 0));		// add the toolbar		mToolBar = new JOAJToolBar();		JOAJToggleButton lockTool = new JOAJToggleButton(new ImageIcon(getClass().getResource("images/lock_open.gif")),		    true);		lockTool.setSelectedIcon(new ImageIcon(getClass().getResource("images/lock_closed.gif")));		lockTool.setSelected(false);		lockTool.setToolTipText(b.getString("kLockPlot"));		// bg.add(zoomTool);		lockTool.setActionCommand("lock");		lockTool.addActionListener(this);		mToolBar.add(lockTool);		mContents.add(mToolBar, "North");		if (!mCrossSections && !mLegend) {			mContPlot = new ContourPlotPanel(mWidth, mHeight);			mContents.add(mContPlot, "Center");		}		else if (!mCrossSections && mLegend) {			mContPlot = new ContourPlotPanel(mWidth, mHeight);			mContents.add(mContPlot, "Center");			mCbarDisplay = new ColorBarDisplay(120, mHeight);			mContents.add(mCbarDisplay, "East");		}		else if (mCrossSections && !mLegend) {			mContPlot = new ContourPlotPanel(mWidth, mHeight);			mContents.add(mContPlot, "Center");			mVXsec = new VerticalXSecPanel(150, mHeight);			mContents.add(mVXsec, "East");			mHXsec = new HorizontalXSecPanel(mWidth - 130, 110);			mLevelDisplay = new LevelDataPanel(150, 80);			mSouthContainer = new JPanel();			mSouthContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);			mSouthContainer.setLayout(new BorderLayout(0, 0));			mSouthContainer.add(mHXsec, "Center");			mSouthContainer.add(mLevelDisplay, "East");			mContents.add(mSouthContainer, "South");		}		else {			mContPlot = new ContourPlotPanel(mWidth, mHeight);			mContents.add(mContPlot, "Center");			mEastContainer = new JPanel();			mEastContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);			mEastContainer.setLayout(new BorderLayout(0, 0));			mVXsec = new VerticalXSecPanel(150, mHeight);			mEastContainer.add(mVXsec, "West");			mCbarDisplay = new ColorBarDisplay(120, mHeight);			mEastContainer.add(mCbarDisplay, "East");			mContents.add(mEastContainer, "East");			mHXsec = new HorizontalXSecPanel(mWidth - 80, 110);			mLevelDisplay = new LevelDataPanel(250, 80);			mSouthContainer = new JPanel();			mSouthContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);			mSouthContainer.setLayout(new BorderLayout(0, 0));			mSouthContainer.add(mHXsec, "Center");			mSouthContainer.add(mLevelDisplay, "East");			mContents.add(mSouthContainer, "South");		}		getRootPane().registerKeyboardAction(new RightListener((Object)mContPlot, mContPlot.getClass()),		    KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0, false), JComponent.WHEN_IN_FOCUSED_WINDOW);		getRootPane().registerKeyboardAction(new LeftListener((Object)mContPlot, mContPlot.getClass()),		    KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0, false), JComponent.WHEN_IN_FOCUSED_WINDOW);		getRootPane().registerKeyboardAction(new UpListener((Object)mContPlot, mContPlot.getClass()),		    KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0, false), JComponent.WHEN_IN_FOCUSED_WINDOW);		getRootPane().registerKeyboardAction(new DownListener((Object)mContPlot, mContPlot.getClass()),		    KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0, false), JComponent.WHEN_IN_FOCUSED_WINDOW);		WindowListener windowListener = new WindowAdapter() {			public void windowClosing(java.awt.event.WindowEvent e) {				closeMe();			}			public void windowActivated(WindowEvent we) {				if (!JOAConstants.ISMAC) { return; }				// ResourceBundle b =				// ResourceBundle.getBundle("javaoceanatlas.resources.JOAResources");				// Menu fmenu = mMenuBar.getAWTMenuBar().getMenu(0);				// MenuItem mi = fmenu.getItem(6);				// mi.setLabel(b.getString("kSaveGraphic"));			}		};		this.addWindowListener(windowListener);		if (mWinTitle.length() == 0) {			this.setTitle(new String("Untitled Contour Plot"));		}		else {			this.setTitle(new String(mWinTitle));		}		mFileViewer.addDataAddedListener(this);		mFileViewer.addStnFilterChangedListener(this);		mFileViewer.addObsFilterChangedListener(this);		PowerOceanAtlas.getInstance().addPrefsChangedListener(this);		PowerOceanAtlas.getInstance().addWindowsMenuChangedListener(this);		mMenuBar = new JOAMenuBar(this, true, mFileViewer);		// offset the window down and right from 'parent' frame		Rectangle r = mParent.getBounds();		this.setLocation(r.x + 20, r.y + 20);		this.setSize(mWidth + 1, mHeight);		this.setSize(mWidth, mHeight);		findFirstLastStation();		mStationRegion = new StationRegion(mFileViewer, mPlotSpec, interpVar, surfVarNum, mFirstStation, mLastStation);		mStationRegion.update(mContPlot);	}	public Interpolation getInterpolation() {		return mInterpolation;	}	public Interpolation getOverlayInterpolation() {		return mOverlayInterpolation;	}	public void closeMe() {		mFileViewer.removeOpenWindow(mFrame);		mFileViewer.removeInterpolation(mInterpolation);		if (mOverlayInterpolation != null) {			mFileViewer.removeInterpolation(mOverlayInterpolation);		}		mFileViewer.removeDataAddedListener((DataAddedListener)mFrame);		mFileViewer.removeStnFilterChangedListener((StnFilterChangedListener)mFrame);		mFileViewer.removeObsFilterChangedListener((ObsFilterChangedListener)mFrame);		PowerOceanAtlas.getInstance().removePrefsChangedListener((PrefsChangedListener)mFrame);		mFileViewer.removeObsChangedListener((ObsChangedListener)mContPlot);		PowerOceanAtlas.getInstance().removeWindowsMenuChangedListener((WindowsMenuChangedListener)mFrame);		System.gc();	}	public void actionPerformed(ActionEvent e) {		String cmd = e.getActionCommand();		if (cmd.equals("lock")) {			mWindowIsLocked = !mWindowIsLocked;			if (!mWindowIsLocked) {				// are now unlocking the window				this.setSize(this.getSize().width + 1, this.getSize().height);				this.setSize(this.getSize().width, this.getSize().height);				// if (mCurrObsPanel != null)				// mCurrObsPanel.setLocked(false);				mContPlot.invalidate();				mContPlot.validate();				this.invalidate();				this.validate();				mContPlot.setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));				this.setResizable(true);			}			else {				mContPlot.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));				this.setResizable(false);				// if (mCurrObsPanel != null)				// mCurrObsPanel.setLocked(true);			}		}		else if (cmd.equals("saveas")) {			saveAsPNG();		}		else if (cmd.equals("close")) {			closeMe();			this.dispose();		}		else if (cmd.equals("print")) {			try {				if (JOAConstants.DEFAULT_PAGEFORMAT == null) {					JOAConstants.DEFAULT_PRINTERJOB = PrinterJob.getPrinterJob();					JOAConstants.DEFAULT_PAGEFORMAT = JOAConstants.DEFAULT_PRINTERJOB.defaultPage();					JOAConstants.DEFAULT_PAGEFORMAT = JOAConstants.DEFAULT_PRINTERJOB.pageDialog(JOAConstants.DEFAULT_PAGEFORMAT);				}				if (JOAConstants.DEFAULT_PRINTERJOB.printDialog()) {					JOAConstants.DEFAULT_PRINTERJOB.setPrintable(mContPlot, JOAConstants.DEFAULT_PAGEFORMAT);					try {						JOAConstants.DEFAULT_PRINTERJOB.print();					}					catch (PrinterException ex) {						ex.printStackTrace();					}				}			}			catch (Exception exx) {				System.out.println("outside");			}			/*			 * String sTemp = this.getTitle(); Properties props = new Properties();			 * PrintJob pj = Toolkit.getDefaultToolkit().getPrintJob(this, "Print			 * Contour Plot", props); if (pj != null) { Graphics g = pj.getGraphics();			 * // get the offsets Dimension od = mContPlot.getSize(); Dimension pd =			 * pj.getPageDimension(); int xOffset = 20; int yOffset = 40;			 * 			 * if (mVXsec == null) { //cross sections not showing xOffset = (pd.width			 * - od.width)/2; yOffset = (pd.height - od.height)/2;			 * 			 * if (mCbarDisplay != null) { Dimension dd = mCbarDisplay.getSize();			 * xOffset = xOffset - dd.width/2 - 20; } }			 * 			 * g.translate(xOffset, yOffset); // add the title int size = 12; if			 * (JOAConstants.ISSUNOS) size = 14; g.setFont(new Font("Courier",			 * Font.BOLD, size)); FontMetrics fm = g.getFontMetrics(); int strWidth =			 * fm.stringWidth(sTemp); int hh = xOffset + pd.width/2 - strWidth/2; //			 * adjust for other panels /*if (mCbarDisplay != null && mVXsec == null) {			 * Dimension dd = mCbarDisplay.getSize(); hh = hh - dd.width/2 - 20; }			 * else if (mCbarDisplay != null && mVXsec != null) { Dimension dd =			 * mCbarDisplay.getSize(); hh = hh - dd.width/2; dd = mVXsec.getSize(); hh			 * = hh - dd.width/2; }			 */			/*			 * int vv = yOffset - 45; g.drawString(sTemp, hh, vv); int fsize = 12; if			 * (JOAConstants.ISSUNOS) fsize = 14; g.setFont(new Font("Courier",			 * Font.PLAIN, fsize)); // print the contour plot panel			 * mContPlot.paintComponent(g); // print the horizontal cross section			 * g.setClip(0, 0, 20000, 20000); if (mHXsec != null) { g.translate(0,			 * od.height); mHXsec.paintComponent(g); } // print the vertical cross			 * section if (mVXsec != null) { Dimension dd = mVXsec.getSize();			 * g.translate(od.width, -od.height); mVXsec.paintComponent(g); } // print			 * the color bar g.setClip(0, 0, 20000, 20000); if (mCbarDisplay != null)			 * { Dimension dd = mCbarDisplay.getSize(); if (mVXsec == null)			 * g.translate(od.width, od.height/2 - dd.height/2); else { Dimension dd2			 * = mVXsec.getSize(); g.translate(-od.width, 0); g.translate(od.width +			 * dd2.width, od.height/2 - dd.height/2); }			 * mCbarDisplay.paintComponent(g); } // print the data display if			 * (mLevelDisplay != null) { Dimension dd = mCbarDisplay.getSize();			 * Dimension dd2 = mVXsec.getSize(); g.translate(-(od.width + dd2.width),			 * -(od.height/2 - dd.height/2)); g.translate(od.width, od.height);			 * mLevelDisplay.paintComponent(g); }			 * 			 * g.dispose(); pj.end(); }			 */		}		else {			mFileViewer.doCommand(cmd, mFrame);		}	}	public Dimension getPreferredSize() {		return new Dimension(mWidth, mHeight);	}	public void dataAdded(DataAddedEvent evt) {		if (mWindowIsLocked) { return; }		if (!mStationRegion.isZoomed()) {			findFirstLastStation();			mStationRegion.setStartStation(mFirstStation);			mStationRegion.setEndStation(mLastStation);			mStationRegion.update(mContPlot);		}		mContPlot.invalidate();		if (mVXsec != null) {			mVXsec.invalidate();		}		if (mHXsec != null) {			mHXsec.invalidate();		}		if (mLevelDisplay != null) {			mLevelDisplay.invalidate();		}		this.setSize(this.getSize().width + 1, this.getSize().height);		this.setSize(this.getSize().width, this.getSize().height);	}	public void saveAsPNG() {		class BasicThread extends Thread {			// ask for filename			public void run() {				if (JOAConstants.DEFAULT_PAGEFORMAT == null) {					JOAConstants.DEFAULT_PRINTERJOB = PrinterJob.getPrinterJob();					JOAConstants.DEFAULT_PAGEFORMAT = JOAConstants.DEFAULT_PRINTERJOB.defaultPage();					// try to set page to largest margins					Paper newPaper = JOAConstants.DEFAULT_PAGEFORMAT.getPaper();					// double width = newPaper.getWidth();					// double iwidth = newPaper.getImageableWidth();					newPaper.setImageableArea(0, 0, newPaper.getWidth(), newPaper.getHeight());					JOAConstants.DEFAULT_PAGEFORMAT.setPaper(newPaper);					JOAConstants.DEFAULT_PAGEFORMAT = JOAConstants.DEFAULT_PRINTERJOB.pageDialog(JOAConstants.DEFAULT_PAGEFORMAT);				}				Image offScreen = createImage((int)JOAConstants.DEFAULT_PAGEFORMAT.getImageableWidth() * 4, 						(int)JOAConstants.DEFAULT_PAGEFORMAT.getImageableHeight() * 4);				Graphics2D og = (Graphics2D)offScreen.getGraphics();				og.scale(4.0, 4.0);				//				Image image = mContPlot.makeOffScreen((Graphics2D)mContPlot.getGraphics(), true, true);				mContPlot.genPage(og, (int)JOAConstants.DEFAULT_PAGEFORMAT.getImageableWidth(), 						(int)JOAConstants.DEFAULT_PAGEFORMAT.getImageableHeight(), 						0, //(int)JOAConstants.DEFAULT_PAGEFORMAT.getImageableX(), 						0); //(int)JOAConstants.DEFAULT_PAGEFORMAT.getImageableY());				FilenameFilter filter = new FilenameFilter() {					public boolean accept(File dir, String name) {						if (name.endsWith("png")) {							return true;						}						else {							return false;						}					}				};				Frame fr = new Frame();				String directory = System.getProperty("user.dir"); // + File.separator				// + "JOA_Support" +				// File.separator;				FileDialog f = new FileDialog(fr, "Save image as:", FileDialog.SAVE);				f.setDirectory(directory);				f.setFilenameFilter(filter);				f.setFile("untitled.png");				f.setVisible(true);				directory = f.getDirectory();				f.dispose();				if (directory != null && f.getFile() != null) {					String path = directory + File.separator + f.getFile();					try {						(new PNGEncoder(offScreen, path)).encode();					}					catch (Exception ex) {						ex.printStackTrace();					}					try {						JOAConstants.LogFileStream.writeBytes("Saved Plot:" + mThis.getTitle() + " as " + path + "\n");						JOAConstants.LogFileStream.flush();					}					catch (Exception ex) {					}				}			}		}		// Create a thread and run it		Thread thread = new BasicThread();		thread.start();	}	public void prefsChanged(PrefsChangedEvent evt) {		if (mWindowIsLocked) { return; }		findFirstLastStation();		this.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);		mPlotSpec.setBGColor(JOAConstants.DEFAULT_CONTENTS_COLOR);		if (mContPlot != null) {			mContPlot.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);		}		if (mVXsec != null) {			mVXsec.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);		}		if (mHXsec != null) {			mHXsec.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);		}		if (mLevelDisplay != null) {			mLevelDisplay.setNewBGColor(JOAConstants.DEFAULT_FRAME_COLOR);		}		if (mCbarDisplay != null) {			mCbarDisplay.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);		}		if (mSouthContainer != null) {			mSouthContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);		}		if (mEastContainer != null) {			mEastContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);		}		mContPlot.invalidate();		this.setSize(this.getSize().width + 1, this.getSize().height);		this.setSize(this.getSize().width, this.getSize().height);	}	public void stnFilterChanged(StnFilterChangedEvent evt) {		if (mWindowIsLocked) { return; }		if (mVXsec != null) {			mVXsec.invalidate();		}		if (mHXsec != null) {			mHXsec.invalidate();		}		if (mLevelDisplay != null) {			mLevelDisplay.invalidate();		}		mContPlot.init();		mContPlot.forceUpdate();		getStationRegion().update(mContPlot);		this.setSize(this.getSize().width + 1, this.getSize().height);		this.setSize(this.getSize().width, this.getSize().height);	}	public void obsFilterChanged(ObsFilterChangedEvent evt) {		if (mWindowIsLocked) { return; }		if (mVXsec != null) {			mVXsec.invalidate();		}		if (mHXsec != null) {			mHXsec.invalidate();		}		if (mLevelDisplay != null) {			mLevelDisplay.invalidate();		}		mContPlot.init();		mContPlot.forceUpdate();		getStationRegion().update(mContPlot);		this.setSize(this.getSize().width + 1, this.getSize().height);		this.setSize(this.getSize().width, this.getSize().height);	}	public void showConfigDialog() {		// show configuration dialog		mContPlot.showConfigDialog();	}	public class ContourPlotPanel extends RubberbandPanel implements ObsChangedListener, DialogClient, ActionListener,	    Printable {		private Image mOffScreen = null;		private double yScale = 0.0;		private double yOrigin = 0.0;		private int pLeftMargin = 0;		private int pBottomMargin = 0;		private int pTopMargin = 0;		private int pRightMargin = 5;		private int panelWidth = 0;		private int panelHeight = 0;		private ObsMarker mObsMarker = null;		private boolean mIgnore = false;		private DialogClient mDialogClient = null;		private JPopupMenu mPopupMenu = null;		private Rubberband rbRect;		private BasicStroke lw2 = new BasicStroke(2);		private BasicStroke lw1 = new BasicStroke(1);		private GeneralPath mSelection = new GeneralPath();		public ContourPlotPanel(int inWidth, int inHeight) {			this.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);			mFileViewer.addObsChangedListener(this);			addMouseListener(new ContourPlotMouseHandler());			panelWidth = inWidth;			panelHeight = inHeight;			init();			if (mAxes) {				pLeftMargin = 70;				pBottomMargin = 50;				pTopMargin = 35;			}			scaleAxes();			setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));			rbRect = new RubberbandRectangle(this);			// rbRect.setConstrainVertical(true);			rbRect.setActive(true);		}		public int getLeftMargin() {			return pLeftMargin;		}		public int getTopMargin() {			return pTopMargin;		}		public int getRightMargin() {			return pRightMargin;		}		public void init() {			mDialogClient = this;			nz = mInterpolation.getLevels();			nsta = mInterpolation.getNumStns();			numContours = mColorBar.getNumLevels();			colors = mColorBar.getColors();			interpVar = mInterpolation.getParam();			surfVarNum = mInterpolation.getSurfParamNum();			if (mOverlayInterpolation != null)				overlaySurfVarNum = mOverlayInterpolation.getSurfParamNum();			interpValues = mInterpolation.getValues();			surface = mInterpolation.getSurface();			surfaceValues = surface.getValues();			contourValues = mColorBar.getValues();			scaleAxes();		}		public void setRubberbandDisplayObject(Object obj, boolean concat) {			// this routine expects a Rectangle Object			mSelection = (GeneralPath)obj;			repaint();		}				public void genPage(Graphics2D g, double pwidth, double pheight, double px, double py) {			// compute the offset for the legend			Dimension od = this.getSize();			double xOffset;			double yOffset;			// compute scale factors			int cbwidth = 0;			if (mCbarDisplay != null) {				cbwidth = mCbarDisplay.getColorBarWidth(g);			}			int vxsecwidth = 0;			if (mVXsec != null) {				vxsecwidth = mVXsec.getWidth();			}			int hxsecheight = 0;			if (mHXsec != null) {				hxsecheight = mHXsec.getHeight();			}			double xScale = 1.0;			double yScale = 1.0;			if (od.width + cbwidth + vxsecwidth > pwidth) {				xScale = pwidth / ((double)(od.width + cbwidth + vxsecwidth));			}			if (od.height + hxsecheight > pheight) {				yScale = pheight / ((double)(od.height + hxsecheight));			}			xScale = Math.min(xScale, yScale);			yScale = xScale;			xOffset = (pwidth - (od.width * xScale)) / 2 + ((cbwidth * xScale) / 2)			    + ((vxsecwidth * xScale) / 2);			yOffset = (pheight - (od.height * yScale)) / 2 + ((hxsecheight * yScale) / 2);			// center the plot on the page			g.translate(px + (xOffset - (cbwidth * xScale) - (vxsecwidth * xScale)), py			    + (yOffset - (hxsecheight * yScale)));			g.scale(xScale, yScale);			// add the title			String sTemp = mThis.getTitle();			Hashtable<TextAttribute, Serializable> map = new Hashtable<TextAttribute, Serializable>();			map.put(TextAttribute.FAMILY, JOAConstants.DEFAULT_PLOT_TITLE_FONT);			map.put(TextAttribute.SIZE, new Float(JOAConstants.DEFAULT_PLOT_TITLE_SIZE));						if (JOAConstants.DEFAULT_PLOT_TITLE_STYLE == Font.BOLD			    || JOAConstants.DEFAULT_PLOT_TITLE_STYLE == (Font.BOLD | Font.ITALIC)) {				map.put(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD);			}						if (JOAConstants.DEFAULT_PLOT_TITLE_STYLE == Font.ITALIC			    || JOAConstants.DEFAULT_PLOT_TITLE_STYLE == (Font.BOLD | Font.ITALIC)) {				map.put(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE);			}			map.put(TextAttribute.FOREGROUND, JOAConstants.DEFAULT_PLOT_TITLE_COLOR);			// layout the title			TextLayout tl = new TextLayout(sTemp, (Map<TextAttribute, Serializable>)map, g.getFontRenderContext());			Rectangle2D strbounds = tl.getBounds();			double strWidth = strbounds.getWidth();			double hh = 30 + od.width / 2 - strWidth / 2;			double vv = -10;			JOAFormulas.drawStyledString(sTemp, (int)hh, (int)vv, g, 0.0, JOAConstants.DEFAULT_PLOT_TITLE_FONT,			    JOAConstants.DEFAULT_PLOT_TITLE_SIZE, JOAConstants.DEFAULT_PLOT_TITLE_STYLE,			    JOAConstants.DEFAULT_PLOT_TITLE_COLOR);			// Add the BG color to the plot			int x1, y1, width, height;			x1 = pLeftMargin;			if (!mPlotSpec.isAutoScaleXAxis()) {				width = (int)((mStationRegion.getXScale() * mFileViewer.mTotMercDist));			}			else {				width = this.getSize().width - pLeftMargin - pRightMargin;			}			y1 = pTopMargin;			height = this.getSize().height - pTopMargin - pBottomMargin;			if (mStyle == JOAConstants.STYLE_FILLED || mStyle == JOAConstants.STYLE_FILLED_CONTOURS) {				g.setColor(JOAConstants.DEFAULT_CONTENTS_COLOR);			}			else {				g.setColor(mPlotSpec.getBGColor());			}			g.fillRect(x1, y1, width, height);						int iw = mContPlot.getWidth()*4;			int ih = mContPlot.getHeight()*4;			Image mOffScreen = JOAConstants.gc[0].createCompatibleImage(iw, ih);			final Graphics2D og = (Graphics2D)mOffScreen.getGraphics();			og.scale(4.0, 4.0);			super.paintComponent(og);//			og.setClip(x1, y1, width, height);			plotContours(og);			if (mOverlayContours) {				plotOverlayContours(og);			}			// destination then source			g.drawImage(mOffScreen, 0, 0, mContPlot.getWidth(), mContPlot.getHeight(), 0, 0, iw, ih, null);			og.dispose();			if (mHXsec != null) {				g.setColor(Color.black);				Point p = mObsMarker.getPos();				int x = (int)p.getX();				int y = (int)p.getY();				g.setClip(x1, y1, width, height);				g.drawLine(x - 2000, y, x + 2000, y);				g.drawLine(x, y - 2000, x, y + 2000);			}			g.setClip(0, 0, 20000, 20000);			if (mAxes) {				plotYAxis(g);				if (mPlotSpec.getXAxisLabels() == ContourPlotSpecification.LABEL_OFFSET_PARAMETER) {					plotXAxis(g);				}				else {					labelXAxis(g);				}			}			// plot the bottom			int pPos = mFileViewer.getPRESPropertyPos();			if (surfVarNum == pPos && mPlotSpec.isPlotBottom()) {				plotBottom(g);			}			// plot the bottom			Interpolation ovlInterp = mPlotSpec.getOverlayInterp();			if (ovlInterp != null) {				if (mOverlayFileViewer != null && mPlotSpec.isPlotOverlayBottom()) {					PlotOverlayBottom(g);				}			}			// plot the data markers			if (mMarkers == JOAConstants.MARKERS_OBSERVATIONS) {				drawSectionPoints(g);			}			else if (mMarkers == JOAConstants.MARKERS_SURFACE_LEVELS) {				drawLevelsPoints(g);			}			if (mOverlayContours && mOverlayMarkers == JOAConstants.MARKERS_OBSERVATIONS) {				drawOverlaySectionPoints(g);			}			else if (mOverlayMarkers == JOAConstants.MARKERS_SURFACE_LEVELS) {				drawOverlayLevelsPoints(g);			}			// draw the auxillary panels			if (mHXsec != null) {				g.translate(0, od.height);				mHXsec.paintComponent(g);				g.translate(od.width, 0);				mLevelDisplay.paintComponent(g);				g.translate(0, -od.height);				mVXsec.paintComponent(g);			}			if (mCbarDisplay != null) {				if (mVXsec == null) {					g.translate(od.width, pTopMargin);				}				else {					g.translate(mVXsec.getWidth(), pTopMargin);				}				drawColorBar(g, od.height - pTopMargin - pBottomMargin);			}		}		public int print(Graphics gin, PageFormat pageFormat, int pageIndex) {			if (pageIndex == 0) {				Graphics2D g = (Graphics2D)gin;				genPage(g, pageFormat.getImageableWidth(), pageFormat.getImageableHeight(), pageFormat.getImageableX(), 						pageFormat.getImageableY());				return PAGE_EXISTS;			}			else {				return NO_SUCH_PAGE;			}		}		public void drawColorBar(Graphics2D g, int height) {			int numColors = mColorBar.getNumLevels();			int left = 0;			int top = 20;			int bottom = height;			// if (!(mLabelPanel && mFancyLabelPanel))			// bottom -= 15;			int pixelsPerBand = (bottom - top - 2) / numColors;			int bandTop = 0;			int bandBottom = 0;			g.setFont(new Font(JOAConstants.DEFAULT_COLORBAR_LABEL_FONT, JOAConstants.DEFAULT_COLORBAR_LABEL_STYLE,			    JOAConstants.DEFAULT_COLORBAR_LABEL_SIZE));			// draw the color ramp and labels			double base = mColorBar.getBaseLevel();			double end = mColorBar.getEndLevel();			double diff = Math.abs(end - base);			int numPlaces = 2;			if (diff < 10) {				numPlaces = 3;			}			else if (diff >= 10 && diff < 100) {				numPlaces = 2;			}			else if (diff >= 100 && diff < 1000) {				numPlaces = 1;			}			else if (diff >= 1000) {				numPlaces = 1;			}			int labelInc = 0;			if (numColors <= 16) {				labelInc = 1;			}			else if (numColors > 16 && numColors <= 32) {				labelInc = 2;			}			else if (numColors > 32 && numColors <= 48) {				labelInc = 3;			}			else if (numColors > 48 && numColors <= 64) {				labelInc = 4;			}			else if (numColors > 64) {				labelInc = 5;			}			for (int i = 0; i < numColors; i++) {				// swatch				bandTop = (int)(top + (i) * pixelsPerBand);				bandBottom = (int)(bandTop + pixelsPerBand);				g.setColor(mColorBar.getColorValue(i));				g.fillRect(left + 10, bandTop, left + 25, bandBottom - bandTop);				if (mColorBar.isColorEnhanced(i)) {					if (i == mColorBar.getMinEnhancedRange()) {					}					if (i == mColorBar.getMaxEnhancedRange()) {					}				}				// label				g.setColor(Color.black);				if (i % labelInc == 0) {					String sTemp = mColorBar.getFormattedValue(i, numPlaces, true);					g.drawString(sTemp, left + 35, bandBottom);				}			}			if (mFileViewer != null) {				int pPos = mFileViewer.getPropertyPos(mColorBar.getParam(), false);				if (pPos >= 0 && mFileViewer.mAllProperties[pPos].getUnits() != null				    && mFileViewer.mAllProperties[pPos].getUnits().length() > 0) {				}				else {				}			}			else {			}		}		public int getMinX() {			return pLeftMargin;		}		public int getMinY() {			return pTopMargin;		}		public int getMaxX() {			return this.getSize().width - pRightMargin;		}		public int getMaxY() {			return this.getSize().height - pBottomMargin;		}		public void rubberbandEnded(Rubberband rb) {		}		public void createPopup(Point point) {			mPopupMenu = new JPopupMenu();			JMenuItem openContextualMenu = new JMenuItem(b.getString("kProperties"));			openContextualMenu.setActionCommand("opencontextual");			openContextualMenu.addActionListener(this);			mPopupMenu.add(openContextualMenu);			mPopupMenu.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));			mPopupMenu.show(this, point.x, point.y);		}		public void showConfigDialog() {			// show configuration dialog			ConfigContourPlotDC cp = new ConfigContourPlotDC(mFrame, mFileViewer, mDialogClient, mPlotSpec);			// cp.setSize(415, 610);			cp.pack();			cp.setVisible(true);		}		public void actionPerformed(ActionEvent e) {			String cmd = e.getActionCommand();			if (cmd.equals("opencontextual")) {				showConfigDialog();			}		}		public class ContourPlotMouseHandler extends MouseAdapter {			public void mouseClicked(MouseEvent me) {				if (mWindowIsLocked) { return; }				if (me.getClickCount() == 2) {					// show configuration dialog					showConfigDialog();				}				else {					if (me.isPopupTrigger()) {						createPopup(me.getPoint());					}					else {						// find a new observation						findByXY(me.getX(), me.getY());					}				}			}			public void mouseReleased(MouseEvent me) {				if (mWindowIsLocked) { return; }				super.mouseReleased(me);				setRubberbandDisplayObject(null, false);				if (me.isPopupTrigger()) {					createPopup(me.getPoint());				}				else {					if (rbRect != null && me.getID() == MouseEvent.MOUSE_RELEASED) {						zoomPlot(rbRect.getBounds(), me.isAltDown());					}				}			}			public void mousePressed(MouseEvent me) {				if (mWindowIsLocked) { return; }				super.mousePressed(me);				if (me.isPopupTrigger()) {					createPopup(me.getPoint());				}			}		}		public void zoomPlot(Rectangle newRect, boolean mode) {			boolean reverseY = mFileViewer.mAllProperties[surfVarNum].isReverseY();			// convert corners of rectangle to new plot range			Rectangle newBounds = rbRect.lastBounds();			int y1 = newBounds.y;			int y2 = y1 + newBounds.height;			int x1 = newBounds.x;			int x2 = x1 + newBounds.width;			if (newBounds.height < 10 || newBounds.width < 10) { return; }			// convert the x coords into a station range			// mStationRegion.setStartStation(mStartStation);			// mStationRegion.setEndStation(mEndStation);			// mStationRegion.computeDeltas();			// mStationRegion.rescale();			// adjust for axes labels			if (!reverseY) {				y1 -= pTopMargin;				y2 -= pTopMargin;			}			else if (reverseY) {				y1 = this.getSize().height - y1;				y1 -= pBottomMargin;				y2 = this.getSize().height - y2;				y2 -= pBottomMargin;			}			FoundBundle leftStuff = findStnByX(x1, -99);			FoundBundle rightStuff = findStnByX(x2, -99);			if (mode) {				mStationRegion.setStartStation(leftStuff.getFoundStn());				mStationRegion.setEndStation(rightStuff.getFoundStn());				mStationRegion.setZoomed(true);				mStationRegion.update(mContPlot);				mInterpolation.setLocked(true);				if (reverseY) {					mPlotMax = y2 / yScale + yOrigin;					mPlotMin = y1 / yScale + yOrigin;				}				else {					mPlotMax = y1 / yScale + yOrigin;					mPlotMin = y2 / yScale + yOrigin;				}				Triplet newRange = JOAFormulas.GetPrettyRange(mPlotMin, mPlotMax);				mPlotMin = newRange.getVal1();				mPlotMax = newRange.getVal2();				mPlotSpec.setYInc(newRange.getVal3());				mPlotSpec.setWinYPlotMax(mPlotMax);				mPlotSpec.setWinYPlotMin(mPlotMin);				// zoom using current window				// invalidate and replot				if (mVXsec != null) {					mVXsec.obsMarker = null;					mVXsec.obsMarker2 = null;					mVXsec.invalidate();				}				if (mHXsec != null) {					mHXsec.obsMarker = null;					mHXsec.obsMarker2 = null;					mHXsec.invalidate();				}				forceUpdate();				rbRect.end(rbRect.getStretched());			}			else {				double newPlotMin, newPlotMax, newPlotInc;				if (reverseY) {					newPlotMax = y2 / yScale + yOrigin;					newPlotMin = y1 / yScale + yOrigin;				}				else {					newPlotMax = y1 / yScale + yOrigin;					newPlotMin = y2 / yScale + yOrigin;				}				Triplet newRange = JOAFormulas.GetPrettyRange(newPlotMin, newPlotMax);				newPlotMin = newRange.getVal1();				newPlotMax = newRange.getVal2();				newPlotInc = newRange.getVal3();				ContourPlotSpecification ps = new ContourPlotSpecification();				if (mPlotSpec.getInterp() instanceof LinearInterpolation) {					LinearInterpolation interp = new LinearInterpolation((LinearInterpolation)mPlotSpec.getInterp());					interp.setLocked(true);					ps.setInterp(interp);				}				else {					ps.setInterp(new ZGridInterpolation((ZGridInterpolation)mPlotSpec.getInterp()));				}				// save the interpolation				// mFileViewer.addInterpolation(ps.getInterp());				ps.setColorBar(new NewColorBar(mPlotSpec.getColorBar()));				ps.setOffset(mPlotSpec.getOffset());				ps.setStyle(mPlotSpec.getStyle());				ps.setMarkers(mPlotSpec.getMarkers());				ps.setMarkerSize(mPlotSpec.getMarkerSize());				ps.setPlotAxes(mPlotSpec.isPlotAxes());				ps.setIncludeCBAR(mPlotSpec.isIncludeCBAR());				ps.setIncludeObsPanel(mPlotSpec.isIncludeObsPanel());				ps.setBrowsingEnabled(mPlotSpec.isBrowsingEnabled());				ps.setAutoScaleXAxis(mPlotSpec.isAutoScaleXAxis());				ps.setWinYPlotMin(newPlotMin);				ps.setWinYPlotMax(newPlotMax);				ps.setYInc(newPlotInc);				ps.setXAxisScale(mPlotSpec.getXAxisScale());				ps.setYTics(mPlotSpec.getYTics());				ps.setXTics(mPlotSpec.getXTics());				ps.setWinTitle(mWinTitle + "z");				ps.setWidth(mPlotSpec.getWidth());				ps.setFGColor(new Color(mPlotSpec.getFGColor().getRGB()));				ps.setBGColor(new Color(mPlotSpec.getBGColor().getRGB()));				ps.setColorLines(mPlotSpec.isColorLines());				ps.setPlotEveryNthContour(mPlotSpec.getPlotEveryNthContour());				ps.setLabelEveryNthContour(mPlotSpec.getLabelEveryNthContour());				ps.setWidth(mThis.getSize().width);				ps.setHeight(mThis.getSize().height);				ps.setSymbolColor(mPlotSpec.getSymbolColor());				if (mPlotSpec.getOverlaySymbolColor() != null) {					ps.setOverlaySymbolColor(mPlotSpec.getOverlaySymbolColor());				}				if (mPlotSpec.getOverlayInterp() != null) {					ps.setOverlayInterp(mPlotSpec.getOverlayInterp());				}				if (mPlotSpec.getOverlayColorBar() != null) {					ps.setOverlayColorBar(mPlotSpec.getOverlayColorBar());				}				if (mPlotSpec.getOverlaySymbolColor() != null) {					ps.setOverlayMarkers(mPlotSpec.getOverlayMarkers());				}				ps.setOverlayMarkerSize(mPlotSpec.getOverlayMarkerSize());				ps.setYVar(mPlotSpec.getYVar());				if (mPlotSpec.getOvlYVar() != null) {					ps.setOvlYVar(mPlotSpec.getOvlYVar());				}				ps.setPlotBottom(mPlotSpec.isPlotBottom());				ps.setPlotOverlayBottom(mPlotSpec.isPlotOverlayBottom());				try {					ps.writeToLog("Zoomed Contour Plot (" + mFileViewer.getTitle() + ")");				}				catch (Exception ex) {				}				// make a new plot window				JOAContourPlotWindow contPlot = new JOAContourPlotWindow(mFileViewer, ps, mFileViewer);				contPlot.pack();				StationRegion stnRegion = contPlot.getStationRegion();				stnRegion.setStartStation(leftStuff.getFoundStn());				stnRegion.setEndStation(rightStuff.getFoundStn());				mStationRegion.setZoomed(true);				stnRegion.update(mContPlot);				contPlot.setVisible(true);				mFileViewer.addOpenWindow(contPlot);			}		}		public void forceUpdate() {		}		public Dimension getPreferredSize() {			return new Dimension(panelWidth, panelHeight);		}		public void invalidate() {			try {				super.invalidate();				if (mOffScreen != null) {					mOffScreen = null;				}				if (mObsMarker != null) {					mObsMarker = null;				}			}			catch (Exception e) {				e.printStackTrace();			}		}		public Image makeOffScreen(Graphics2D g, boolean addTitle, boolean plotOverlays) {			Image outImage = null;			int pwidth = getSize().width;			// adjust width/height for other components			if (mCbarDisplay != null) {				pwidth += 100;			}			outImage = createImage(pwidth, getSize().height);			Graphics2D og = (Graphics2D)outImage.getGraphics();			super.paintComponent(og);			scaleAxes();			mStationRegion.rescale(mContPlot);			int x1, y1, width, height;			x1 = pLeftMargin;			double scale = mStationRegion.getXScale();			if (!mPlotSpec.isAutoScaleXAxis()) {				width = (int)((scale * mFileViewer.mTotMercDist));			}			else {				width = this.getSize().width - pLeftMargin - pRightMargin;			}			y1 = pTopMargin;			height = this.getSize().height - pTopMargin - pBottomMargin;			if (mStyle == JOAConstants.STYLE_FILLED || mStyle == JOAConstants.STYLE_FILLED_CONTOURS) {				og.setColor(JOAConstants.DEFAULT_CONTENTS_COLOR);			}			else {				og.setColor(mPlotSpec.getBGColor());			}			og.fillRect(x1, y1, width, height);			// scale axes			panelHeight = this.getSize().height;			panelWidth = this.getSize().width;			if (mHXsec != null) {				mHXsec.setSize(this.getSize().width, 100);			}			if (mVXsec != null) {				mVXsec.setSize(150, this.getSize().height);				mVXsec.scaleAxes();			}			// plot contours			og.setClip(x1, y1, width, height);			plotContours(og);			if (mOverlayContours) {				plotOverlayContours(og);			}			og.setClip(0, 0, 2000, 2000);			// System.out.println("ri " + (System.currentTimeMillis() - st));			if (mAxes) {				plotYAxis(og);				if (mPlotSpec.getXAxisLabels() == ContourPlotSpecification.LABEL_OFFSET_PARAMETER) {					plotXAxis(og);				}				else {					labelXAxis(og);				}			}			// plot the bottom			int pPos = mFileViewer.getPRESPropertyPos();			if (surfVarNum == pPos && mPlotSpec.isPlotBottom()) {				plotBottom(og);			}			// plot the bottom			if (mOverlayInterpolation != null) {				int ovlpPos = mOverlayFileViewer.getPRESPropertyPos();				if (overlaySurfVarNum == ovlpPos && mPlotSpec.isPlotOverlayBottom()) {					PlotOverlayBottom(og);				}			}			// plot the data markers			if (mMarkers == JOAConstants.MARKERS_OBSERVATIONS) {				drawSectionPoints(og);			}			else if (mMarkers == JOAConstants.MARKERS_SURFACE_LEVELS) {				drawLevelsPoints(og);			}			if (mOverlayContours && mOverlayMarkers == JOAConstants.MARKERS_OBSERVATIONS) {				drawOverlaySectionPoints(og);			}			else if (mOverlayContours && mOverlayMarkers == JOAConstants.MARKERS_SURFACE_LEVELS) {				drawOverlayLevelsPoints(og);			}			if (addTitle) {				// add the title				String sTemp = mThis.getTitle();				Font font = new Font(JOAConstants.DEFAULT_PLOT_TITLE_FONT, JOAConstants.DEFAULT_PLOT_TITLE_STYLE,				    JOAConstants.DEFAULT_PLOT_TITLE_SIZE);				FontMetrics fm = Toolkit.getDefaultToolkit().getFontMetrics(font);				int strWidth = fm.stringWidth(sTemp);				double hh = 30 + this.getWidth() / 2 - strWidth / 2;				double vv = fm.getHeight() - 3;				JOAFormulas.drawStyledString(sTemp, (int)hh, (int)vv, og, 0.0, JOAConstants.DEFAULT_PLOT_TITLE_FONT,				    JOAConstants.DEFAULT_PLOT_TITLE_SIZE, JOAConstants.DEFAULT_PLOT_TITLE_STYLE,				    JOAConstants.DEFAULT_PLOT_TITLE_COLOR);			}			Dimension od = this.getSize();			if (plotOverlays) {				if (mHXsec != null) {					g.translate(0, od.height);					mHXsec.paintComponent(og);					g.translate(od.width, 0);					mLevelDisplay.paintComponent(og);					g.translate(0, -od.height);					mVXsec.paintComponent(og);				}				if (mCbarDisplay != null) {					if (mVXsec == null) {						og.translate(od.width, pTopMargin);					}					else {						og.translate(mVXsec.getWidth(), 0);					}					drawColorBar(og, od.height - pTopMargin - pBottomMargin);				}			}			og.dispose();			return outImage;		}		public void paintComponent(Graphics gin) {			Graphics2D g = (Graphics2D)gin;			if (mOffScreen == null) {				mOffScreen = makeOffScreen(g, JOAConstants.DEFAULT_PLOT_TITLES, false);				g.drawImage(mOffScreen, 0, 0, null);			}			else {				g.drawImage(mOffScreen, 0, 0, null);				if (mSelection != null) {					g.setColor(JOAConstants.DEFAULT_SELECTION_REGION_OUTLINE_COLOR);					g.setStroke(lw2);					g.draw(mSelection);					g.setColor(Color.black);				}			}			if (mObsMarker == null) {				initDataSpot();			}			if (mObsMarker != null /* && !mWindowIsLocked */) {				g.setClip(pLeftMargin, pTopMargin, this.getSize().width, this.getSize().height - pBottomMargin - pTopMargin);				mObsMarker.drawMarker(g, false);				if (mPlotSpec.isBrowsingEnabled()) {					g.drawLine(mObsMarker.getX() - 2000, mObsMarker.getY(), mObsMarker.getX() + 2000, mObsMarker.getY());					g.drawLine(mObsMarker.getX(), mObsMarker.getY() - 2000, mObsMarker.getX(), mObsMarker.getY() + 2000);				}				g.setClip(0, 0, 2000, 2000);			}		}		public void scaleAxes() {			// compute the y axis lower limits to fill in the region			int maxY = this.getSize().height - pBottomMargin - pTopMargin;			// scale the axes			yScale = -maxY / (mPlotMax - mPlotMin);			yOrigin = mPlotMax;			yOrigin = mPlotMax;			// determine the direction for latitude offset			mNtoSSection = isNtoSSection();		}		private boolean isNtoSSection() {			double startLat = 0.0;			for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {				OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.elementAt(fc);				// loop over the sections				for (int sec = 0; sec < of.mNumSections; sec++) {					Section sech = (Section)of.mSections.elementAt(sec);					if (sech.mNumCasts == 0) {						continue;					}					// loop over the stations					for (int stc = 0; stc < sech.mStations.size(); stc++) {						Station sh = (Station)sech.mStations.elementAt(stc);						if (stc == 0 && sec == 0 && fc == 0) {							startLat = sh.mLat;							continue;						}						else if (sh.mLat < startLat) { return true; }					}				}			}			return false;		}		public void plotYAxis(Graphics2D g) {			int maxY = 0;			maxY = this.getSize().height - pBottomMargin - pTopMargin;			g.setColor(Color.black);			int bottom = maxY;			int top = pTopMargin;			int leftMTicPos = pLeftMargin - 5 - 2;			double yDiff = (mPlotMax - mPlotMin);			int majorYTicks = (int)(yDiff / mPlotSpec.getYInc());			double yInc = (double)(maxY) / (yDiff / mPlotSpec.getYInc());			double minorYInc = yInc / ((double)mPlotSpec.getYTics() + 1);			// draw the Y axis			g.drawLine(pLeftMargin, top, pLeftMargin, pTopMargin + maxY);			// draw the Y tic marks			for (int i = 0; i <= majorYTicks; i++) {				int v = (int)(pTopMargin + (i * yInc));				g.drawLine(leftMTicPos, v, pLeftMargin, v);				/* plot the minor ticks */				if (i < majorYTicks) {					for (int vv = 0; vv < mPlotSpec.getYTics() + 1; vv++) {						int newV = (int)(v + (vv * minorYInc));						g.drawLine(pLeftMargin - 3, newV, pLeftMargin, newV);					}				}				if (v > bottom) {					g.drawLine(pLeftMargin, bottom, pLeftMargin, v);				}			}			/* set the Y precision */			int numPlaces = JOAFormulas.GetDisplayPrecision(Math.abs(mPlotSpec.getYInc()));			if (numPlaces > 0) {				numPlaces++;			}			double vOrigin;			int lleft;			double myVal;			if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {				vOrigin = mPlotMin;			}			else {				vOrigin = mPlotMax;			}			if (vOrigin < 0) {				lleft = 23;			}			else {				lleft = 28;			}			String sTemp = null;			sTemp = JOAFormulas.formatDouble(String.valueOf(vOrigin + (majorYTicks * mPlotSpec.getYInc())), numPlaces, false);			if (numPlaces == 0) {			}			else {			}			for (int i = 0; i <= majorYTicks; i++) {				if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {					myVal = vOrigin + (i * mPlotSpec.getYInc());				}				else {					myVal = vOrigin - (i * mPlotSpec.getYInc());				}				if (myVal == -0.0) {					myVal = 0.0;				}				int v = (int)(pTopMargin + (i * yInc));				if (numPlaces > 0) {					sTemp = JOAFormulas.returnSpacePaddedString(					    JOAFormulas.formatDouble(String.valueOf(myVal), numPlaces, false), 4);				}				else {					sTemp = JOAFormulas.returnSpacePaddedString((int)myVal, 4);				}				Font font = new Font(JOAConstants.DEFAULT_AXIS_VALUE_FONT, JOAConstants.DEFAULT_AXIS_VALUE_STYLE,				    JOAConstants.DEFAULT_AXIS_VALUE_SIZE);				FontMetrics fm = Toolkit.getDefaultToolkit().getFontMetrics(font);				int widthOfValLbl = fm.stringWidth(sTemp);				JOAFormulas.drawStyledString(sTemp, leftMTicPos - widthOfValLbl, v + 4, g, 0.0,				    JOAConstants.DEFAULT_AXIS_VALUE_FONT, JOAConstants.DEFAULT_AXIS_VALUE_SIZE,				    JOAConstants.DEFAULT_AXIS_VALUE_STYLE, JOAConstants.DEFAULT_AXIS_VALUE_COLOR);			}			String axisLabel = null;			if (mFileViewer.mAllProperties[surfVarNum].getUnits() != null			    && mFileViewer.mAllProperties[surfVarNum].getUnits().length() > 0) {				axisLabel = mFileViewer.mAllProperties[surfVarNum].getVarLabel() + " ("				    + mFileViewer.mAllProperties[surfVarNum].getUnits() + ")";			}			else {				axisLabel = mFileViewer.mAllProperties[surfVarNum].getVarLabel();			}			int height = this.getSize().height;			JOAFormulas.drawStyledString(axisLabel, pRightMargin + 15, pTopMargin + (height - pTopMargin) / 2, g, 90,			    JOAConstants.DEFAULT_AXIS_LABEL_FONT, JOAConstants.DEFAULT_AXIS_LABEL_SIZE,			    JOAConstants.DEFAULT_AXIS_LABEL_STYLE, JOAConstants.DEFAULT_AXIS_LABEL_COLOR);		}		public void labelXAxis(Graphics2D g) {			int maxY = this.getSize().height - pBottomMargin;			g.setColor(Color.black);			int bottom = maxY;			Font font = new Font(JOAConstants.DEFAULT_AXIS_VALUE_FONT, JOAConstants.DEFAULT_AXIS_VALUE_STYLE,			    JOAConstants.DEFAULT_AXIS_VALUE_SIZE);			g.setFont(font);			FontMetrics fm = Toolkit.getDefaultToolkit().getFontMetrics(font);			// draw the station tic marks first			int stnCnt = 0;			int sc = 0;			boolean firstStnFound = false;			for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {				OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.elementAt(fc);				// loop over the sections				for (int sec = 0; sec < of.mNumSections; sec++) {					Section sech = (Section)of.mSections.elementAt(sec);					if (sech.mNumCasts == 0) {						continue;					}					// loop over the stations					int v = pTopMargin;					int h = pLeftMargin;					for (int stc = 0; stc < sech.mStations.size(); stc++) {						Station sh = (Station)sech.mStations.elementAt(stc);						if (!sh.mUseStn) {							continue;						}						if (!mStationRegion.isStnInRegion(sh)) {							continue;						}						if (!firstStnFound) {							firstStnFound = true;						}						v = pTopMargin;						if (mOffset == JOAConstants.OFFSET_SEQUENCE) {							h = (int)(pLeftMargin + (stnCnt++ * mStationRegion.getXScale()));						}						else if (mOffset == JOAConstants.OFFSET_DISTANCE) {							h = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset())));						}						else if (mOffset == JOAConstants.OFFSET_LATITUDE) {							if (!mNtoSSection) {								h = pLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());							}							else {								h = pLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());							}						}						else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {							// lon must increase to the right							double lon = sh.mLon;							if (mStationRegion.getLeftLon() < 0) {								if (lon < 0 && lon < mStationRegion.getLeftLon()) {									lon += 360.0;								}							}							else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {								lon += 360.0;							}							h = (int)(pLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));						}						else if (mOffset == JOAConstants.OFFSET_TIME) {							h = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion							    .getMinTime())));						}						g.drawLine(h, v, h, v - 4);						g.drawLine(h, bottom, h, bottom + 4);						if (sc % (mPlotSpec.getSkipXAxisLabels() + 1) == 0) {							// draw the label							String sTemp = sh.getStn().trim() + " (" + sh.getCast() + ")";							if (mPlotSpec.getXAxisLabels() == ContourPlotSpecification.LAT_OFFSET_PARAMETER) {								sTemp = JOAFormulas.formatLat(sh.getLat(), 2);							}							else if (mPlotSpec.getXAxisLabels() == ContourPlotSpecification.LON_OFFSET_PARAMETER) {								sTemp = JOAFormulas.formatLon(sh.getLon(), 2);							}							JOAFormulas.drawStyledString(sTemp, h - 5, bottom + 10, g, -90.0, JOAConstants.DEFAULT_AXIS_VALUE_FONT,							    JOAConstants.DEFAULT_AXIS_VALUE_SIZE - 1, JOAConstants.DEFAULT_AXIS_VALUE_STYLE,							    JOAConstants.DEFAULT_AXIS_VALUE_COLOR);						}						sc++;					}				}			}		}		public UVCoordinate[] analyzeXAxis() {			// return an array of x axis segments			return null;		}		@SuppressWarnings("deprecation")		public void plotXAxis(Graphics2D g) {			int maxY = this.getSize().height - pBottomMargin;			g.setColor(Color.black);			int bottom = maxY;			int left = pLeftMargin;			// draw the station tic marks first			int stnCnt = 0;			boolean firstStnFound = false;			for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {				OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.elementAt(fc);				// loop over the sections				for (int sec = 0; sec < of.mNumSections; sec++) {					Section sech = (Section)of.mSections.elementAt(sec);					if (sech.mNumCasts == 0) {						continue;					}					// loop over the stations					int v = pTopMargin;					int h = pLeftMargin;					for (int stc = 0; stc < sech.mStations.size(); stc++) {						Station sh = (Station)sech.mStations.elementAt(stc);						if (!sh.mUseStn) {							continue;						}						if (!mStationRegion.isStnInRegion(sh)) {							continue;						}						if (!firstStnFound) {							firstStnFound = true;						}						v = pTopMargin;						if (mOffset == JOAConstants.OFFSET_SEQUENCE) {							h = (int)(pLeftMargin + (stnCnt++ * mStationRegion.getXScale()));						}						else if (mOffset == JOAConstants.OFFSET_DISTANCE) {							h = (int)(pLeftMargin + (mStationRegion.getXScale() * sh.getCumDistInKM()));						}						else if (mOffset == JOAConstants.OFFSET_LATITUDE) {							if (!mNtoSSection) {								h = pLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());							}							else {								h = pLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());							}						}						else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {							// lon must increase to the right							double lon = sh.mLon;							if (mStationRegion.getLeftLon() < 0) {								if (lon < 0 && lon < mStationRegion.getLeftLon()) {									lon += 360.0;								}							}							else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {								lon += 360.0;							}							// if (mFileViewer.mStnFilterActive) {							// if (mFileViewer.mFilteredDataCross180) {							// if (lon < 0) {							// lon += 360.0;							// }							// }							// }							// else {							// if (mFileViewer.mUnFilteredDataCross180) {							// if (lon < 0) {							// lon += 360.0;							// }							// }							// }							h = (int)(pLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));						}						else if (mOffset == JOAConstants.OFFSET_TIME) {							h = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion							    .getMinTime())));						}						g.drawLine(h, v, h, v - 4);					}				}			}			if (mOffset == JOAConstants.OFFSET_SEQUENCE || mOffset == JOAConstants.OFFSET_DISTANCE) {				// need distance between stations				double distKM = mStationRegion.getDeltaDistance();				double leftDist = mStationRegion.getStartStation().mCumDist;				int right = (int)(pLeftMargin + (mStationRegion.getXScale() * mStationRegion.getDeltaDistance()));				if (mOffset == JOAConstants.OFFSET_SEQUENCE) {					right = panelWidth - pRightMargin;				}				Triplet prettyNums = JOAFormulas.GetPrettyRange(0, distKM);				double mXInc = prettyNums.getVal3();				double xDiff = distKM;				int majorXTicks = (int)(xDiff / mXInc);				double xInc = (double)(right - left) / (xDiff / mXInc);				double minorXInc = xInc / ((double)mPlotSpec.getXTics() + 1);				// draw the X axis				bottom = maxY;				g.drawLine(left, bottom, right, bottom);				// draw the X tic marks				for (int i = 0; i <= majorXTicks; i++) {					int h = (int)(left + (i * xInc));					if (h <= right) {						g.drawLine(h, bottom + 5, h, bottom);					}					// plot the minor ticks					if (i <= majorXTicks) {						for (int hh = 0; hh < mPlotSpec.getXTics() + 1; hh++) {							int newH = (int)(h + (hh * minorXInc));							if (newH <= right) {								g.drawLine(newH, bottom + 3, newH, bottom);							}						}					}				}				// set the X precision				int numPlaces = JOAFormulas.GetDisplayPrecision(mXInc);				// label the x axis				int loffset = 5;				Font font = new Font(JOAConstants.DEFAULT_AXIS_VALUE_FONT, JOAConstants.DEFAULT_AXIS_VALUE_STYLE,				    JOAConstants.DEFAULT_AXIS_VALUE_SIZE);				g.setFont(font);				FontMetrics fm = Toolkit.getDefaultToolkit().getFontMetrics(font);				double vOrigin = leftDist;				String sTemp = null;				for (int i = 0; i <= majorXTicks; i++) {					double myVal = vOrigin + (i * mXInc);					if (myVal == -0.0) {						myVal = 0.0;					}					int h = (int)((left - loffset) + (i * xInc));					if (numPlaces > 0) {						sTemp = JOAFormulas.formatDouble(String.valueOf(myVal), numPlaces, false);					}					else {						sTemp = String.valueOf((int)myVal);					}					int maxh = h + fm.stringWidth(sTemp) / 2;					int maxv = fm.getHeight();					int hoffset = bottom + 5 + 2 + maxv;					if (maxh < right) {						JOAFormulas.drawStyledString(sTemp, h - (fm.stringWidth(sTemp.substring(0, sTemp.length() - 1)) / 2),						    hoffset, g, 0.0, JOAConstants.DEFAULT_AXIS_VALUE_FONT, JOAConstants.DEFAULT_AXIS_VALUE_SIZE,						    JOAConstants.DEFAULT_AXIS_VALUE_STYLE, JOAConstants.DEFAULT_AXIS_VALUE_COLOR);					}				}			}			else if (mOffset == JOAConstants.OFFSET_LATITUDE || mOffset == JOAConstants.OFFSET_LONGITUDE) {				// label by latitude or longitude				double totalDegs = 0.0;				double axisCtr = 0.0;				double mXInc = 0.0;				FontMetrics fm = g.getFontMetrics();				String sTemp = null;				int right = this.getSize().width - pRightMargin;				int width = this.getSize().width - pRightMargin - pLeftMargin;				// find the center lat/lon of the axis				if (mOffset == JOAConstants.OFFSET_LATITUDE) {					totalDegs = mStationRegion.getDeltaLat();					axisCtr = (mStationRegion.getMaxLat() + mStationRegion.getMinLat()) / 2.0;					if (totalDegs <= 1.0) {						mXInc = 0.10;					}					else if (totalDegs <= 10.0) {						mXInc = 1.0;					}					else if (totalDegs <= 45.0) {						mXInc = 5.0;					}					else if (totalDegs <= 90.0) {						mXInc = 10.0;					}					else {						mXInc = 15.0;					}				}				else {					totalDegs = mStationRegion.getDeltaLon();					axisCtr = mStationRegion.getLeftLon() + (totalDegs / 2.0);					if (mStationRegion.getLeftLon() < 0) {						if (axisCtr < 0 && axisCtr < mStationRegion.getLeftLon()) {							axisCtr += 360.0;						}						else if (mStationRegion.getLeftLon() >= 0 && axisCtr < 0) {							axisCtr += 360.0;						}					}					if (totalDegs <= 1.0) {						mXInc = 0.10;					}					else if (totalDegs <= 10.0) {						mXInc = 1.0;					}					else if (totalDegs <= 45.0) {						mXInc = 5.0;					}					else if (totalDegs <= 90.0) {						mXInc = 10.0;					}					else if (totalDegs <= 180.0) {						mXInc = 20.0;					}					else {						mXInc = 30.0;					}				}				int majorXTicks = (int)(totalDegs / mXInc);				// if (majorXTicks > 7) {				// mXInc *= 2;				// majorXTicks = (int) (totalDegs / mXInc);				// }				double xInc = (double)(width) / (totalDegs / mXInc); // pixels/deg				double minorXInc = xInc / ((double)mPlotSpec.getXTics() + 1);				// find the closest position in the modulo of the axis increment				double aboveAxisCtr;				double belowAxisCtr;				if (totalDegs <= 1.0) {					aboveAxisCtr = Math.ceil(axisCtr);					belowAxisCtr = Math.floor(axisCtr);				}				else {					aboveAxisCtr = Math.ceil(axisCtr / 10.0) * 10.0;					belowAxisCtr = Math.floor(axisCtr / 10.0) * 10.0;				}				double aboveDiff = Math.abs(axisCtr - aboveAxisCtr);				double belowDiff = Math.abs(axisCtr - belowAxisCtr);				if (aboveDiff < belowDiff) {					axisCtr = aboveAxisCtr;				}				else {					axisCtr = belowAxisCtr;				}				// draw the X axis				bottom = maxY;				g.drawLine(left, bottom, right, bottom);				// set the X precision				int numPlaces = JOAFormulas.GetDisplayPrecision(mXInc);				// plot the points above the axis Ctr				for (int i = 0; i < majorXTicks; i++) {					double newLoc;					if (!mNtoSSection) {						newLoc = axisCtr + (i * mXInc);					}					else {						newLoc = axisCtr - (i * mXInc);					}					int h = 0;					if (mOffset == JOAConstants.OFFSET_LATITUDE) {						if (!mNtoSSection) {							h = pLeftMargin + (int)((newLoc - mStationRegion.getMinLat()) * mStationRegion.getXScale());						}						else {							h = pLeftMargin + (int)((mStationRegion.getMaxLat() - newLoc) * mStationRegion.getXScale());						}					}					else {						h = (int)(pLeftMargin + ((newLoc - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));					}					// draw major tics					if (h >= left && h <= right) {						g.drawLine(h, bottom + 5, h, bottom);					}					// draw minor tics					if (i <= majorXTicks) {						for (int hh = 0; hh < mPlotSpec.getXTics() + 1; hh++) {							int newH = (int)(h + (hh * minorXInc));							if (newH >= left && newH <= right) {								g.drawLine(newH, bottom + 3, newH, bottom);							}						}					}					// label the value					if (mOffset == JOAConstants.OFFSET_LATITUDE) {						sTemp = JOAFormulas.formatLat(newLoc, numPlaces);					}					else {						sTemp = JOAFormulas.formatLon(newLoc, numPlaces);					}					int maxh = h + fm.stringWidth(sTemp) / 2;					int minh = h - fm.stringWidth(sTemp) / 2;					if (minh > left && maxh < right) {						int maxv = fm.getHeight();						int hoffset = bottom + 5 + 2 + maxv;						JOAFormulas.drawStyledString(sTemp, h - (fm.stringWidth(sTemp) / 2), hoffset, g, 0.0,						    JOAConstants.DEFAULT_AXIS_VALUE_FONT, JOAConstants.DEFAULT_AXIS_VALUE_SIZE,						    JOAConstants.DEFAULT_AXIS_VALUE_STYLE, JOAConstants.DEFAULT_AXIS_VALUE_COLOR);					}					// g.drawString(sTemp, h - (fm.stringWidth(sTemp)/2), bottom + 18);				}				// plot the points below the axis Ctr				for (int i = 0; i < majorXTicks; i++) {					double newLoc;					if (!mNtoSSection) {						newLoc = axisCtr - (i * mXInc);					}					else {						newLoc = axisCtr + (i * mXInc);					}					int h = 0;					if (mOffset == JOAConstants.OFFSET_LATITUDE) {						if (!mNtoSSection) {							h = pLeftMargin + (int)((newLoc - mStationRegion.getMinLat()) * mStationRegion.getXScale());						}						else {							h = pLeftMargin + (int)((mStationRegion.getMaxLat() - newLoc) * mStationRegion.getXScale());						}					}					else {						h = (int)(pLeftMargin + ((newLoc - mFirstStation.getLon()) * mStationRegion.getXScale()));					}					// draw major tics					if (h >= left && h <= right) {						g.drawLine(h, bottom + 5, h, bottom);					}					// draw minor tics					if (i <= majorXTicks) {						for (int hh = 0; hh < mPlotSpec.getXTics() + 1; hh++) {							int newH = (int)(h - (hh * minorXInc));							if (newH >= left && newH <= right) {								g.drawLine(newH, bottom + 3, newH, bottom);							}						}					}					// label the value					if (mOffset == JOAConstants.OFFSET_LATITUDE) {						sTemp = JOAFormulas.formatLat(newLoc, numPlaces);					}					else {						sTemp = JOAFormulas.formatLon(newLoc, numPlaces);					}					int maxh = h + fm.stringWidth(sTemp) / 2;					int minh = h - fm.stringWidth(sTemp) / 2;					if (minh > left && maxh < right) {						int maxv = fm.getHeight();						int hoffset = bottom + 5 + 2 + maxv;						JOAFormulas.drawStyledString(sTemp, h - (fm.stringWidth(sTemp) / 2), hoffset, g, 0.0,						    JOAConstants.DEFAULT_AXIS_VALUE_FONT, JOAConstants.DEFAULT_AXIS_VALUE_SIZE,						    JOAConstants.DEFAULT_AXIS_VALUE_STYLE, JOAConstants.DEFAULT_AXIS_VALUE_COLOR);					}					// g.drawString(sTemp, h - (fm.stringWidth(sTemp)/2), bottom + 18);				}			}			else {				// instantiate a time axis object				TimeAxis tAxis = new TimeAxis(TimeAxis.AUTO);				// set the time range for the axis				tAxis.setRangeU(new SoTRange.GeoDate(mStationRegion.getStartStation().getDate(), mStationRegion.getEndStation()				    .getDate()));				// set the fonts for the axis				tAxis.setFont(JOAConstants.DEFAULT_AXIS_VALUE_FONT, JOAConstants.DEFAULT_AXIS_VALUE_STYLE,				    JOAConstants.DEFAULT_AXIS_VALUE_SIZE, JOAConstants.DEFAULT_AXIS_VALUE_COLOR);				// set the starting location of the axis				tAxis.setAxisOrigin(left, bottom);				// set the length of the axis				tAxis.setAxisLength(this.getSize().width - pLeftMargin - pRightMargin);				// draw the axis				tAxis.draw(g);			}			// x-axis label			if (mOffset == JOAConstants.OFFSET_SEQUENCE || mOffset == JOAConstants.OFFSET_DISTANCE) {				Font font = new Font(JOAConstants.DEFAULT_AXIS_LABEL_FONT, JOAConstants.DEFAULT_AXIS_LABEL_STYLE,				    JOAConstants.DEFAULT_AXIS_LABEL_SIZE);				g.setFont(font);				int right = panelWidth - pRightMargin;				FontMetrics fm = g.getFontMetrics();				ResourceBundle b = ResourceBundle.getBundle("javaoceanatlas.resources.JOAResources");				int strWidth = fm.stringWidth(b.getString("kDistanceLegend"));				String axisLabel = new String();				if (mOffset == JOAConstants.OFFSET_SEQUENCE) {					strWidth = fm.stringWidth(b.getString("kDistanceLegend"));					axisLabel = b.getString("kDistanceLegend");				}				else if (mOffset == JOAConstants.OFFSET_DISTANCE) {					strWidth = fm.stringWidth(b.getString("kDistanceLegend"));					axisLabel = b.getString("kDistanceLegend");				}				/*				 * else if (mOffset == JOAConstants.OFFSET_LATITUDE) { strWidth =				 * fm.stringWidth(b.getString("kLatitudeLegend")); axisLabel =				 * b.getString("kLatitudeLegend"); } else if (mOffset ==				 * JOAConstants.OFFSET_LONGITUDE) { strWidth =				 * fm.stringWidth(b.getString("kLongitudeLegend")); axisLabel =				 * b.getString("kLongitudeLegend"); }				 */				JOAFormulas.drawStyledString(axisLabel, pLeftMargin + ((right - left) / 2 - strWidth / 2), bottom + 40, g, 0,				    JOAConstants.DEFAULT_AXIS_LABEL_FONT, JOAConstants.DEFAULT_AXIS_LABEL_SIZE,				    JOAConstants.DEFAULT_AXIS_LABEL_STYLE, JOAConstants.DEFAULT_AXIS_LABEL_COLOR);			}		}		public void plotContours(Graphics2D g) {			numContours = mColorBar.getNumLevels();			colors = mColorBar.getColors();			contourValues = mColorBar.getValues();			// compute the start and end levels			int maxY = this.getSize().height - pBottomMargin - pTopMargin;			int minLevel = 0;			int maxLevel = nz;			boolean fmax = false;			for (int i = 0; i < nz - 1; i++) {				if (surfaceValues[i] <= mPlotMin) {					minLevel = i; // < nz-1 ? i + 1 : i;				}				if (surfaceValues[i] >= mPlotMax && !fmax) {					maxLevel = i < nz - 1 ? i + 1 : i;					fmax = true;				}			}			if (maxLevel > nz) {				maxLevel = nz;			}			// System.out.println("nz = " + nz);			int numActualLevels = maxLevel - minLevel;			// System.out.println("numActualLevels = " + numActualLevels);			// compute the coordinates of the y grid			double[] y = new double[numActualLevels];			for (int i = 0; i < numActualLevels; i++) {				y[i] = Double.NaN;			}			int c = 0;			for (int i = minLevel; i < maxLevel; i++) {				// System.out.println(" surfaceValues[c] = " + surfaceValues[c]);				y[c] = (surfaceValues[i] - yOrigin) * yScale;				y[c] = maxY - y[c];				y[c] = pTopMargin + y[c];				c++;				// System.out.println(" y[i] = " + y[i]);			}			// get the number of actually used stations			int numStnsInRgn = mStationRegion.getNumStns();			// compute the coordinates of the x grid			double[] x = new double[numStnsInRgn];			for (int i = 0; i < numStnsInRgn; i++) {				x[i] = Double.NaN;			}			double minTime = mStationRegion.getMinTime();			double xScale = mStationRegion.getXScale();			// assign x coordinates			if (mInterpolation instanceof LinearInterpolation) {				scaleAxes();				int j = 0;				for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {					OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.elementAt(fc);					// loop over the sections					for (int sec = 0; sec < of.mNumSections; sec++) {						Section sech = (Section)of.mSections.elementAt(sec);						if (sech.mNumCasts == 0) {							continue;						}						// loop over the stations						for (int stc = 0; stc < sech.mStations.size(); stc++) {							Station sh = (Station)sech.mStations.elementAt(stc);							if (!sh.mUseStn) {								continue;							}							if (!mStationRegion.isStnInRegion(sh)) {								continue;							}							if (mOffset == JOAConstants.OFFSET_SEQUENCE) {								x[j] = pLeftMargin + (xScale * j);							}							else if (mOffset == JOAConstants.OFFSET_DISTANCE) {								x[j] = pLeftMargin + (xScale * (sh.getCumDistInKM() - mStationRegion.getXOffset()));							}							else if (mOffset == JOAConstants.OFFSET_LATITUDE) {								if (!mNtoSSection) {									x[j] = pLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * xScale);								}								else {									x[j] = pLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * xScale);								}							}							else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {								// lon must increase to the right								double lon = sh.mLon;								if (mStationRegion.getLeftLon() < 0) {									if (lon < 0 && lon < mStationRegion.getLeftLon()) {										lon += 360.0;									}								}								else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {									lon += 360.0;								}								x[j] = pLeftMargin + ((lon - mStationRegion.getLeftLon()) * xScale);							}							else if (mOffset == JOAConstants.OFFSET_TIME) {								x[j] = (int)(pLeftMargin + (xScale * (sh.getDate().getTime() - minTime)));							}							// System.out.println(" x[j] = " + x[j]);							j++;						}					}				}			}			else {				scaleAxes();				double dx = mInterpolation.getTotalDistance() / (double)mInterpolation.getNumStns();				for (int j = 0; j < nsta; j++) {					if (mOffset == JOAConstants.OFFSET_SEQUENCE) {						x[j] = pLeftMargin + (mStationRegion.getXScale() * j);					}					else if (mOffset == JOAConstants.OFFSET_DISTANCE) {						x[j] = pLeftMargin + (mStationRegion.getXScale() * (j * dx));					}					// else if (mOffset == JOAConstants.OFFSET_LATITUDE) {					// if (!mNtoSSection) {					// x[j] = pLeftMargin + ((sh.mLat - mFileViewer.mLatMin) *					// pixelsPerUnit);					// }					// else {					// x[j] = pLeftMargin + ((mFileViewer.mLatMax - sh.mLat) *					// pixelsPerUnit);					// }					// }					// else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {					// // lon must increase to the right					// double lon = sh.mLon;					// if (leftLon < 0) {					// if (lon < 0 && lon < leftLon) {					// lon += 360.0;					// }					// }					// x[j] = pLeftMargin + ((lon - leftLon) * pixelsPerUnit);					// }					// else if (mOffset == JOAConstants.OFFSET_TIME) {					// x[j] = (int) (pLeftMargin + (pixelsPerUnit *					// (sh.getDate().getTime() - minDate)));					// }				}			}			// System.out.println(" j= " + j);			// plot the contours			double[] zBox = new double[4];			double z1 = 0.0;			double z2 = 0.0;			double z3 = 0.0;			double z4 = 0.0;			int nFoul = 0;			double yDelta = 0.0;			int lowerX = 0;			int upperX = 0;			int numXPixels = 0;			double xDelta = 0.0;			double delta = 0.0;			int newX = 0;			double val = 0.0;			int newY = 0;			int startX = 0;			int startY = 0;			int colorIndex = 0;			int oldColorIndex = 0;			double t, u;			// System.out.println("maxLevel = " + maxLevel);			// System.out.println("minLevel = " + minLevel);			c = 0;			int start = mStationRegion.getMinOrd() - 1;			int end = start + mStationRegion.getNumStns() - 1;			if (mStyle == JOAConstants.STYLE_FILLED || mStyle == JOAConstants.STYLE_FILLED_CONTOURS) {				for (int j1 = minLevel; j1 < maxLevel - 1; j1++) {					int lowerY = (int)y[c];					int upperY = (int)y[c + 1];										// flip if necessary										int numYPixels = upperY - lowerY;					if (numYPixels == 0) {						numYPixels = 1;					}					if (numYPixels < 0) {						numYPixels = -numYPixels;						upperY = (int)y[c];						lowerY = (int)y[c + 1];					}					yDelta = upperY - lowerY;										int xc = 0;					for (int i1 = start; i1 < end; i1++) {						z1 = interpValues[j1][i1];						z2 = interpValues[j1][i1 + 1];						z3 = interpValues[j1 + 1][i1 + 1];						z4 = interpValues[j1 + 1][i1];						zBox[0] = z1;						zBox[1] = z2;						zBox[2] = z3;						zBox[3] = z4;						nFoul = 0;						for (int i = 0; i < 4; i++) {							if (zBox[i] == JOAConstants.MISSINGVALUE) {								nFoul++;							}						}						lowerX = (int)x[i1 - start];						upperX = (int)x[i1 - start + 1];						// compute the number of new pixels in each direction						numXPixels = upperX - lowerX;						if (numXPixels == 0) {							numXPixels = 1;						}						xDelta = upperX - lowerX;						if (nFoul == 4) {							// can't paint anything							continue;						}						else if (nFoul == 3) {							// just paint the non missing pixel							if (z1 != JOAConstants.MISSINGVALUE) {								val = z1;								g.setColor(colors[mColorBar.getColorIndex(val)]);								int localY = upperY;								if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {									localY = maxY - upperY + 2 * pTopMargin;								}								g.fillRect(lowerX, localY, numXPixels / 2, numYPixels / 2);							}							else if (z2 != JOAConstants.MISSINGVALUE) {								val = z2;								g.setColor(colors[mColorBar.getColorIndex(val)]);								int localY = lowerY;								if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {									localY = maxY - lowerY + 2 * pTopMargin;								}								g.fillRect(upperX - numXPixels / 2, localY, numXPixels / 2, numYPixels / 2);							}							else if (z3 != JOAConstants.MISSINGVALUE) {								val = z3;								g.setColor(colors[mColorBar.getColorIndex(val)]);								int localY = upperY;								if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {									localY = maxY - upperY + 2 * pTopMargin;								}								g.fillRect(upperX - numXPixels / 2, localY - numYPixels / 2, numXPixels / 2, numYPixels / 2);							}							else if (z4 != JOAConstants.MISSINGVALUE) {								val = z4;								g.setColor(colors[mColorBar.getColorIndex(val)]);								int localY = upperY;								if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {									localY = maxY - upperY + 2 * pTopMargin;								}								g.fillRect(upperX, localY - numYPixels / 2, numXPixels / 2, numYPixels / 2);							}							continue;						}						else if (nFoul == 2) {							if (z1 != JOAConstants.MISSINGVALUE && z2 != JOAConstants.MISSINGVALUE) {								if (numXPixels > 1) {									// interpolate along the column									delta = (z2 - z1) / numXPixels;									for (int jj = 0; jj < numXPixels; jj++) {										newX = lowerX + jj;										val = z2 + jj * delta;										int localY = lowerY;										if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {											localY = maxY - lowerY + 2 * pTopMargin;										}										if (mColorBar.getColorIndex(val) != JOAConstants.MISSINGVALUE) {											g.setColor(colors[mColorBar.getColorIndex(val)]);										}										else {											g.setColor(Color.white);										}										g.fillRect(newX - 1, localY - 1, 2, numYPixels / 2 + 1);									}								}								else {									val = z2;									g.setColor(colors[mColorBar.getColorIndex(val)]);									int localY = lowerY;									if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {										localY = maxY - lowerY + 2 * pTopMargin;									}									g.fillRect(lowerX - 1, localY - 1, 2, numYPixels / 2 + 1);								}							}							else if (z3 != JOAConstants.MISSINGVALUE && z4 != JOAConstants.MISSINGVALUE) {								if (numXPixels > 1) {									// interpolate along the column									delta = (z3 - z4) / numXPixels;									for (int jj = 0; jj < numXPixels; jj++) {										newX = lowerX + jj;										val = z4 + jj * delta;										int localY = upperY;										if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {											localY = maxY - upperY + 2 * pTopMargin;										}										if (mColorBar.getColorIndex(val) != JOAConstants.MISSINGVALUE) {											g.setColor(colors[mColorBar.getColorIndex(val)]);										}										else {											g.setColor(Color.white);										}										g.fillRect(newX - 1, localY - numYPixels / 2 - 1, 1, numYPixels / 2 + 1);									}								}								else {									val = z4;									g.setColor(colors[mColorBar.getColorIndex(val)]);									int localY = upperY;									if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {										localY = maxY - upperY + 2 * pTopMargin;									}									g.fillRect(lowerX - 1, localY - numYPixels / 2 - 1, 1, numYPixels / 2 + 1);								}							}							else if (z3 != JOAConstants.MISSINGVALUE && z2 != JOAConstants.MISSINGVALUE) {								if (numYPixels > 1) {									// interpolate along the column									delta = (z3 - z2) / numYPixels;									for (int ii = 0; ii < numYPixels; ii++) {										newY = lowerY + ii;										val = z2 + ii * delta;										int localY = newY;										if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {											localY = maxY - newY + 2 * pTopMargin;										}										if (mColorBar.getColorIndex(val) != JOAConstants.MISSINGVALUE) {											g.setColor(colors[mColorBar.getColorIndex(val)]);										}										else {											g.setColor(Color.white);										}										g.fillRect(upperX - numXPixels / 2 + 1, localY - 1, numXPixels / 2 + 1, 2);									}								}								else if (z2 != JOAConstants.MISSINGVALUE) {									val = z2;									g.setColor(colors[mColorBar.getColorIndex(val)]);									int localY = upperY;									if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {										localY = maxY - upperY + 2 * pTopMargin;									}									g.fillRect(upperX - numXPixels / 2 + 1, localY - 1, numXPixels / 2 + 1, 2);								}							}							else if (z1 != JOAConstants.MISSINGVALUE && z4 != JOAConstants.MISSINGVALUE) {								if (numYPixels > 1) {									// interpolate along the column									delta = (z4 - z1) / numYPixels;									for (int ii = 0; ii < numYPixels; ii++) {										newY = lowerY + ii;										val = z1 + ii * delta;										int localY = newY;										if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {											localY = maxY - newY + 2 * pTopMargin;										}										if (mColorBar.getColorIndex(val) != JOAConstants.MISSINGVALUE) {											g.setColor(colors[mColorBar.getColorIndex(val)]);										}										else {											g.setColor(Color.white);										}										g.fillRect(lowerX - 1, localY - 1, numXPixels / 2 + 1, 2);									}								}								else {									val = z2;									g.setColor(colors[mColorBar.getColorIndex(val)]);									int localY = upperY;									if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {										localY = maxY - upperY + 2 * pTopMargin;									}									g.fillRect(lowerX - 1, localY - 1, numXPixels / 2 + 1, 2);								}							}							// triangle cases go here							// o x							// x o							// x o							// o x							continue;						}						else if (nFoul == 1) {							if (z1 == JOAConstants.MISSINGVALUE) {								if (numYPixels == 1) {									delta = (z3 - z4) / numXPixels;									for (int jj = 0; jj < numXPixels; jj++) {										newX = lowerX + jj;										val = z2 + jj * delta;										int localY = lowerY;										if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {											localY = maxY - lowerY + 2 * pTopMargin;										}										if (mColorBar.getColorIndex(val) != JOAConstants.MISSINGVALUE) {											g.setColor(colors[mColorBar.getColorIndex(val)]);										}										else {											g.setColor(Color.white);										}										g.drawLine(newX, localY, newX, localY);									}								}								else if (numXPixels == 1) {									// interpolate along the column									delta = (z3 - z2) / numYPixels;									for (int ii = 0; ii < numYPixels; ii++) {										newY = lowerY + ii;										val = z2 + ii * delta;										int localY = newY;										if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {											localY = maxY - newY + 2 * pTopMargin;										}										if (mColorBar.getColorIndex(val) != JOAConstants.MISSINGVALUE) {											g.setColor(colors[mColorBar.getColorIndex(val)]);										}										else {											g.setColor(Color.white);										}										g.drawLine(lowerX, localY, lowerX, localY);									}								}								else {									// color the triangle									double y0 = (upperY + 1) / (double)this.getHeight();									double y1 = (lowerY - 1) / (double)this.getHeight();									double y2 = (upperY + 1) / (double)this.getHeight();									double x0 = (lowerX - 1) / (double)this.getWidth();									double x1 = (upperX + 1) / (double)this.getWidth();									double x2 = (upperX + 1) / (double)this.getWidth();									// Bounding rectangle									int minx = lowerX - 1;									int maxx = upperX + 1;									int miny = lowerY - 1;									int maxy = upperY + 1;									double f12x0y0 = (y1 - y2) * x0 + (x2 - x1) * y0 + x1 * y2 - x2 * y1;									double f20x1y1 = (y2 - y0) * x1 + (x0 - x2) * y1 + x2 * y0 - x0 * y2;									double f01x2y2 = (y0 - y1) * x2 + (x1 - x0) * y2 + x0 * y1 - x1 * y0;									// Scan through bounding rectangle									for (int yy = miny; yy < maxy; yy++) {										for (int xx = minx; xx < maxx; xx++) {											double xxn = xx / (double)this.getWidth();											double yyn = yy / (double)this.getHeight();											double f12xy = (y1 - y2) * xxn + (x2 - x1) * yyn + x1 * y2 - x2 * y1;											double f20xy = (y2 - y0) * xxn + (x0 - x2) * yyn + x2 * y0 - x0 * y2;											double f01xy = (y0 - y1) * xxn + (x1 - x0) * yyn + x0 * y1 - x1 * y0;											double alpha = f12xy / f12x0y0;											double beta = f20xy / f20x1y1;											double gamma = f01xy / f01x2y2;											if (alpha >= 0.0 && alpha <= 1.0 && beta >= 0.0 && beta <= 1.0 && gamma >= 0.0 && gamma <= 1.0) {												double pixVal = alpha * z4 + beta * z3 + gamma * z2;												g.setColor(colors[mColorBar.getColorIndex(pixVal)]);												int localY = yy;												if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {													localY = maxY - yy + 2 * pTopMargin;												}												g.fillRect(xx, localY, 2, 2);											}										}									}								}							}							else if (z2 == JOAConstants.MISSINGVALUE) {								if (numYPixels == 1) {									delta = (z3 - z4) / numXPixels;									for (int jj = 0; jj < numXPixels; jj++) {										newX = lowerX + jj;										val = z1 + jj * delta;										int localY = lowerY;										if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {											localY = maxY - lowerY + 2 * pTopMargin;										}										if (mColorBar.getColorIndex(val) != JOAConstants.MISSINGVALUE) {											g.setColor(colors[mColorBar.getColorIndex(val)]);										}										else {											g.setColor(Color.white);										}										g.drawLine(newX, localY, newX, localY);									}								}								else if (numXPixels == 1) {									// interpolate along the column									delta = (z4 - z1) / numYPixels;									for (int ii = 0; ii < numYPixels; ii++) {										newY = lowerY + ii;										val = z1 + ii * delta;										int localY = newY;										if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {											localY = maxY - newY + 2 * pTopMargin;										}										if (mColorBar.getColorIndex(val) != JOAConstants.MISSINGVALUE) {											g.setColor(colors[mColorBar.getColorIndex(val)]);										}										else {											g.setColor(Color.white);										}										g.drawLine(lowerX, localY, lowerX, localY);									}								}								else {									// color the triangle									// Bounding rectangle									int minx = lowerX - 1;									int maxx = upperX + 1;									int miny = lowerY - 1;									int maxy = upperY + 1;									double y0 = maxy / (double)this.getHeight();									double y1 = miny / (double)this.getHeight();									double y2 = maxy / (double)this.getHeight();									double x0 = minx / (double)this.getWidth();									double x1 = minx / (double)this.getWidth();									double x2 = maxx / (double)this.getWidth();									double f12x0y0 = (y1 - y2) * x0 + (x2 - x1) * y0 + x1 * y2 - x2 * y1;									double f20x1y1 = (y2 - y0) * x1 + (x0 - x2) * y1 + x2 * y0 - x0 * y2;									double f01x2y2 = (y0 - y1) * x2 + (x1 - x0) * y2 + x0 * y1 - x1 * y0;									// Scan through bounding rectangle									for (int yy = miny; yy < maxy; yy++) {										for (int xx = minx; xx < maxx; xx++) {											double xxn = xx / (float)this.getWidth();											double yyn = yy / (float)this.getHeight();											double f12xy = (y1 - y2) * xxn + (x2 - x1) * yyn + x1 * y2 - x2 * y1;											double f20xy = (y2 - y0) * xxn + (x0 - x2) * yyn + x2 * y0 - x0 * y2;											double f01xy = (y0 - y1) * xxn + (x1 - x0) * yyn + x0 * y1 - x1 * y0;											double alpha = f12xy / f12x0y0;											double beta = f20xy / f20x1y1;											double gamma = f01xy / f01x2y2;											if (alpha >= 0.0 && alpha <= 1.0 && beta >= 0.0 && beta <= 1.0 && gamma >= 0.0 && gamma <= 1.0) {												double pixVal = alpha * z4 + beta * z1 + gamma * z3;												g.setColor(colors[mColorBar.getColorIndex(pixVal)]);												int localY = yy;												if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {													localY = maxY - yy + 2 * pTopMargin;												}												g.fillRect(xx, localY, 2, 2);											}										}									}								}							}							else if (z3 == JOAConstants.MISSINGVALUE) {								if (numYPixels == 1) {									delta = (z2 - z1) / numXPixels;									for (int jj = 0; jj < numXPixels; jj++) {										newX = lowerX + jj;										val = z1 + jj * delta;										int localY = lowerY;										if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {											localY = maxY - lowerY + 2 * pTopMargin;										}										if (mColorBar.getColorIndex(val) != JOAConstants.MISSINGVALUE) {											g.setColor(colors[mColorBar.getColorIndex(val)]);										}										else {											g.setColor(Color.white);										}										g.drawLine(newX, localY, newX, localY);									}								}								else if (numXPixels == 1) {									// interpolate along the column									delta = (z4 - z1) / numYPixels;									for (int ii = 0; ii < numYPixels; ii++) {										newY = lowerY + ii;										val = z1 + ii * delta;										int localY = newY;										if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {											localY = maxY - newY + 2 * pTopMargin;										}										if (mColorBar.getColorIndex(val) != JOAConstants.MISSINGVALUE) {											g.setColor(colors[mColorBar.getColorIndex(val)]);										}										else {											g.setColor(Color.white);										}										g.drawLine(lowerX, localY, lowerX, localY);									}								}								else {									// color the triangle									// Bounding rectangle									int minx = lowerX - 1;									int maxx = upperX + 1;									int miny = lowerY - 1;									int maxy = upperY + 1;									double y0 = maxy / (float)this.getHeight();									double y1 = miny / (float)this.getHeight();									double y2 = miny / (float)this.getHeight();									double x0 = minx / (float)this.getWidth();									double x1 = minx / (float)this.getWidth();									double x2 = maxx / (float)this.getWidth();									double f12x0y0 = (y1 - y2) * x0 + (x2 - x1) * y0 + x1 * y2 - x2 * y1;									double f20x1y1 = (y2 - y0) * x1 + (x0 - x2) * y1 + x2 * y0 - x0 * y2;									double f01x2y2 = (y0 - y1) * x2 + (x1 - x0) * y2 + x0 * y1 - x1 * y0;									// Scan through bounding rectangle									for (int yy = miny; yy < maxy; yy++) {										for (int xx = minx; xx < maxx; xx++) {											double xxn = xx / (double)this.getWidth();											double yyn = yy / (double)this.getHeight();											double f12xy = (y1 - y2) * xxn + (x2 - x1) * yyn + x1 * y2 - x2 * y1;											double f20xy = (y2 - y0) * xxn + (x0 - x2) * yyn + x2 * y0 - x0 * y2;											double f01xy = (y0 - y1) * xxn + (x1 - x0) * yyn + x0 * y1 - x1 * y0;											double alpha = f12xy / f12x0y0;											double beta = f20xy / f20x1y1;											double gamma = f01xy / f01x2y2;											if (alpha >= 0.0 && alpha <= 1.0 && beta >= 0.0 && beta <= 1.0 && gamma >= 0.0 && gamma <= 1.0) {												double pixVal = alpha * z4 + beta * z1 + gamma * z2;												g.setColor(colors[mColorBar.getColorIndex(pixVal)]);												int localY = yy;												if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {													localY = maxY - yy + 2 * pTopMargin;												}												g.fillRect(xx, localY, 2, 2);											}										}									}								}							}							else if (z4 == JOAConstants.MISSINGVALUE) {								if (numYPixels == 1) {									delta = (z2 - z1) / numXPixels;									for (int jj = 0; jj < numXPixels; jj++) {										newX = lowerX + jj;										val = z1 + jj * delta;										int localY = lowerY;										if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {											localY = maxY - lowerY + 2 * pTopMargin;										}										if (mColorBar.getColorIndex(val) != JOAConstants.MISSINGVALUE) {											g.setColor(colors[mColorBar.getColorIndex(val)]);										}										else {											g.setColor(Color.white);										}										g.drawLine(newX, localY, newX, localY);									}								}								else if (numXPixels == 1) {									// interpolate along the column									delta = (z3 - z2) / numYPixels;									for (int ii = 0; ii < numYPixels; ii++) {										newY = lowerY + ii;										val = z2 + ii * delta;										int localY = newY;										if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {											localY = maxY - newY + 2 * pTopMargin;										}										if (mColorBar.getColorIndex(val) != JOAConstants.MISSINGVALUE) {											g.setColor(colors[mColorBar.getColorIndex(val)]);										}										else {											g.setColor(Color.white);										}										g.drawLine(lowerX, localY, lowerX, localY);									}								}								else {									// color the triangle									// Bounding rectangle									int minx = lowerX - 1;									int maxx = upperX + 1;									int miny = lowerY - 1;									int maxy = upperY + 1;									double y0 = miny / (double)this.getHeight();									double y1 = miny / (double)this.getHeight();									double y2 = maxy / (double)this.getHeight();									double x0 = minx / (double)this.getWidth();									double x1 = maxx / (double)this.getWidth();									double x2 = maxx / (double)this.getWidth();									double f12x0y0 = (y1 - y2) * x0 + (x2 - x1) * y0 + x1 * y2 - x2 * y1;									double f20x1y1 = (y2 - y0) * x1 + (x0 - x2) * y1 + x2 * y0 - x0 * y2;									double f01x2y2 = (y0 - y1) * x2 + (x1 - x0) * y2 + x0 * y1 - x1 * y0;									// Scan through bounding rectangle									for (int yy = miny; yy < maxy; yy++) {										for (int xx = minx; xx < maxx; xx++) {											double xxn = xx / (double)this.getWidth();											double yyn = yy / (double)this.getHeight();											double f12xy = (y1 - y2) * xxn + (x2 - x1) * yyn + x1 * y2 - x2 * y1;											double f20xy = (y2 - y0) * xxn + (x0 - x2) * yyn + x2 * y0 - x0 * y2;											double f01xy = (y0 - y1) * xxn + (x1 - x0) * yyn + x0 * y1 - x1 * y0;											double alpha = f12xy / f12x0y0;											double beta = f20xy / f20x1y1;											double gamma = f01xy / f01x2y2;											if (alpha >= 0.0 && alpha <= 1.0 && beta >= 0.0 && beta <= 1.0 && gamma >= 0.0 && gamma <= 1.0) {												double pixVal = alpha * z1 + beta * z2 + gamma * z3;												g.setColor(colors[mColorBar.getColorIndex(pixVal)]);												int localY = yy;												if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {													localY = maxY - yy + 2 * pTopMargin;												}												g.fillRect(xx, localY, 2, 2);											}										}									}								}							}							continue;						}						// got all four values {						// interpolate						if (numYPixels == 1) {							delta = (z2 - z1) / numXPixels;							// interpolate along the row							for (int jj = 0; jj < numXPixels; jj++) {								newX = lowerX + jj;								val = z1 + jj * delta;								if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {									newY = maxY - newY + 2 * pTopMargin;								}								if (mColorBar.getColorIndex(val) != JOAConstants.MISSINGVALUE) {									g.setColor(colors[mColorBar.getColorIndex(val)]);								}								else {									g.setColor(Color.white);								}								g.drawLine(newX, lowerY, newX, lowerY);							}						}						else if (numXPixels == 1) {							// interpolate along the column							delta = (z4 - z1) / numYPixels;							for (int ii = 0; ii < numYPixels; ii++) {								newY = lowerY + ii;								val = z1 + ii * delta;								if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {									newY = maxY - newY + 2 * pTopMargin;								}								if (mColorBar.getColorIndex(val) != JOAConstants.MISSINGVALUE) {									g.setColor(colors[mColorBar.getColorIndex(val)]);								}								else {									g.setColor(Color.white);								}								g.drawLine(lowerX, newY, lowerX, newY);							}						}						else {							for (int jj = 0; jj < numXPixels; jj++) {								for (int ii = 0; ii < numYPixels; ii++) {									newX = lowerX + jj;									newY = lowerY + ii;									if (newX == 0 && newY == 0) {										continue;									}									t = (newX - lowerX) / xDelta;									u = 0;									if (yDelta > 0) {										u = (newY - lowerY) / yDelta;									}									else {										u = (lowerY - newY) / yDelta;									}									if (!mFileViewer.mAllProperties[surfVarNum].isReverseY()) {										newY = maxY - newY + 2 * pTopMargin;									}									val = (1 - t) * (1 - u) * z1 + t * (1 - u) * z2 + t * u * z3 + (1 - t) * u * z4;									// apply an observation filter here									/*									 * if (mFileViewer.mObsFilterActive) { double c1Val = 0.0,									 * c2Val = 0.0, c3Val = 0.0, c4Val = 0.0; if									 * (mFileViewer.mCurrObsFilter.mCriteria1Active) c1Val =									 * bh.mDValues[c1Pos]; if									 * (mFileViewer.mCurrObsFilter.mCriteria2Active) c2Val =									 * bh.mDValues[c2Pos]; if									 * (mFileViewer.mCurrObsFilter.mCriteria3Active) c3Val =									 * bh.mDValues[c3Pos]; if									 * (mFileViewer.mCurrObsFilter.mCriteria4Active) c4Val =									 * bh.mDValues[c4Pos];									 * 									 * if (!mFileViewer.mCurrObsFilter.testValues(c1Val, c2Val,									 * c3Val, c4Val, 0, 0, 0, 0)) val =									 * 100;//JOAConstants.MISSINGVALUE; }									 */									colorIndex = mColorBar.getColorIndex(val);									if (mColorBar.getColorIndex(val) != JOAConstants.MISSINGVALUE) {										g.setColor(colors[mColorBar.getColorIndex(val)]);									}									else {										g.setColor(Color.white);									}									if (ii == 0) {										oldColorIndex = colorIndex;										startX = newX;										startY = newY;									}									else {										if (colorIndex != oldColorIndex) {											if (oldColorIndex != JOAConstants.MISSINGVALUE) {												g.setColor(colors[oldColorIndex]);											}											else {												g.setColor(Color.white);											}											g.drawLine(startX, startY, newX, newY);											oldColorIndex = colorIndex;											startX = newX;											startY = newY;										}									}								}								// finish the line								if (oldColorIndex != JOAConstants.MISSINGVALUE) {									g.setColor(colors[oldColorIndex]);								}								else {									g.setColor(Color.white);								}								g.drawLine(startX, startY, newX, newY);							}						}					}					c++;				}			}			if (mStyle == JOAConstants.STYLE_CONTOURS || mStyle == JOAConstants.STYLE_FILLED_CONTOURS) {				// the z values go in this flattened array				double[] zgrid = new double[numActualLevels * numStnsInRgn];				// System.out.println(" numActualLevels= " + numActualLevels);				// assign values to the flattened a array				c = 0;				int endVal = 0;				if (end + 1 > numStnsInRgn)					endVal = end;				else {					endVal = end + 1;				}				for (int i = start; i < endVal; i++) {					// for (int i=0; i<numStnsInRgn; i++) {					for (int l = minLevel; l < maxLevel; l++) {						zgrid[c++] = Double.NaN;					}				}				c = 0;				for (int i = start; i < endVal; i++) {					if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {						 for (int l = minLevel; l < maxLevel; l++) {							val = interpValues[l][i];							if (val != JOAConstants.MISSINGVALUE)								zgrid[c] = val;							else								zgrid[c] = Double.NaN;							// System.out.println(" zgrid[c]= " + zgrid[c]);							c++;						}					}					else {						for (int l = maxLevel - 1; l >= minLevel; l--) {							val = interpValues[l][i];							if (val != JOAConstants.MISSINGVALUE)								zgrid[c] = val;							else								zgrid[c] = Double.NaN;							// System.out.println(" zgrid[c]= " + zgrid[c]);							c++;						}					}				}				// System.out.println(" c= " + c);				// System.out.println(" zgrid= " + zgrid.length);				// create a SimpleGrid from the x and y grids, the zgrid is a flattened				// 2D array				SimpleGrid grid = new SimpleGrid(zgrid, x, y, "title");				// create a contour levels array				ContourLevels cLevels = new ContourLevels();				NewColorBar ncb = mPlotSpec.getColorBar();				int ncl = ncb.getNumLevels();				// todo: built in colorbars have to have the contour attribute defined				if (mPlotEveryNthContour <= 0)					mPlotEveryNthContour = 1;				for (int k = 0; k < ncl; k += mPlotEveryNthContour) {					ContourLineAttribute attr = ncb.getContourAttributes(k);					if (attr == null) {						if (ncb.getDoubleValue(k) < 0.0) {							if (JOAConstants.THICKEN_CONTOUR_LINES) {								ContourLineAttribute tattr = new ContourLineAttribute(ContourLineAttribute.DASHED);								attr = new ContourLineAttribute(ContourLineAttribute.STROKE);								attr.setWidth((float)(tattr.getWidth() * 1.5));								attr.setWidthOverridden(true);								attr.setDashArray(tattr.getDashArray());								attr.setDashPhase(tattr.getDashPhase());								attr.setDashArrayOverridden(true);								attr.setDashPhaseOverridden(true);							}							else {								attr = new ContourLineAttribute(ContourLineAttribute.DASHED);							}						}						else if (ncb.getDoubleValue(k) > 0.0) {							if (JOAConstants.THICKEN_CONTOUR_LINES) {								ContourLineAttribute tattr = new ContourLineAttribute(ContourLineAttribute.SOLID);								attr = new ContourLineAttribute(ContourLineAttribute.STROKE);								attr.setWidth((float)(tattr.getWidth() * 1.5));								attr.setWidthOverridden(true);								attr.setDashArray(tattr.getDashArray());								attr.setDashPhase(tattr.getDashPhase());								attr.setDashArrayOverridden(true);								attr.setDashPhaseOverridden(true);							}							else {								attr = new ContourLineAttribute(ContourLineAttribute.SOLID);							}						}						else {							if (JOAConstants.THICKEN_CONTOUR_LINES) {								ContourLineAttribute tattr = new ContourLineAttribute(ContourLineAttribute.HEAVY);								attr = new ContourLineAttribute(ContourLineAttribute.STROKE);								attr.setWidth((float)(tattr.getWidth() * 2.5));								attr.setWidthOverridden(true);								attr.setDashArray(tattr.getDashArray());								attr.setDashPhase(tattr.getDashPhase());								attr.setDashArrayOverridden(true);								attr.setDashPhaseOverridden(true);							}							else {								attr = new ContourLineAttribute(ContourLineAttribute.HEAVY);							}						}						attr.setStyleOverridden(true);						double labelSize = (double)JOAConstants.DEFAULT_ISOPYCNAL_LABEL_SIZE;						attr.setLabelHeightP(labelSize);						attr.setLabelHeightPOverridden(true);						Hashtable<TextAttribute, Serializable> map = new Hashtable<TextAttribute, Serializable>();						map.put(TextAttribute.FAMILY, JOAConstants.DEFAULT_ISOPYCNAL_LABEL_FONT);						map.put(TextAttribute.SIZE, new Float(JOAConstants.DEFAULT_ISOPYCNAL_LABEL_SIZE));						if (JOAConstants.DEFAULT_ISOPYCNAL_LABEL_STYLE == Font.BOLD						    || JOAConstants.DEFAULT_ISOPYCNAL_LABEL_STYLE == (Font.BOLD | Font.ITALIC)) {							map.put(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD);						}						if (JOAConstants.DEFAULT_ISOPYCNAL_LABEL_STYLE == Font.ITALIC						    || JOAConstants.DEFAULT_ISOPYCNAL_LABEL_STYLE == (Font.BOLD | Font.ITALIC)) {							map.put(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE);						}						map.put(TextAttribute.FOREGROUND, JOAConstants.DEFAULT_ISOPYCNAL_LABEL_COLOR);						Font lblFont = new Font(map);						attr.setLabelFont(lblFont);						attr.setLabelFontOverridden(true);						if (mPlotSpec.isColorLines())							attr.setColor(ncb.getColorValue(k));						else							attr.setColor(Color.black);						cLevels.addLevel(ncb.getDoubleValue(k), attr);					}					else {						if (ncb.getDoubleValue(k) < 0.0) {							if (JOAConstants.THICKEN_CONTOUR_LINES) {								ContourLineAttribute tattr = new ContourLineAttribute(ContourLineAttribute.DASHED);								attr = new ContourLineAttribute(ContourLineAttribute.STROKE);								attr.setWidth((float)(tattr.getWidth() * 1.5));								attr.setWidthOverridden(true);								attr.setDashArray(tattr.getDashArray());								attr.setDashPhase(tattr.getDashPhase());								attr.setDashArrayOverridden(true);								attr.setDashPhaseOverridden(true);							}							else {								attr = new ContourLineAttribute(ContourLineAttribute.DASHED);							}						}						else if (ncb.getDoubleValue(k) > 0.0) {							if (JOAConstants.THICKEN_CONTOUR_LINES) {								ContourLineAttribute tattr = new ContourLineAttribute(ContourLineAttribute.SOLID);								attr = new ContourLineAttribute(ContourLineAttribute.STROKE);								attr.setWidth((float)(tattr.getWidth() * 1.5));								float[] newDashes = { 12.0f, 0.0f };								attr.setWidthOverridden(true);								attr.setDashArray(newDashes);								attr.setDashPhase(0.0f);								attr.setDashArrayOverridden(true);								attr.setDashPhaseOverridden(true);							}							else {								attr = new ContourLineAttribute(ContourLineAttribute.SOLID);							}						}						else {							if (JOAConstants.THICKEN_CONTOUR_LINES) {								ContourLineAttribute tattr = new ContourLineAttribute(ContourLineAttribute.HEAVY);								attr = new ContourLineAttribute(ContourLineAttribute.STROKE);								attr.setWidth((float)(tattr.getWidth() * 2.5));								float[] newDashes = { 12.0f, 0.0f };								attr.setWidthOverridden(true);								attr.setDashArray(newDashes);								attr.setDashPhase(0.0f);								attr.setDashArrayOverridden(true);								attr.setDashPhaseOverridden(true);							}							else {								attr = new ContourLineAttribute(ContourLineAttribute.HEAVY);							}						}						attr.setStyleOverridden(true);						double labelSize = (double)JOAConstants.DEFAULT_ISOPYCNAL_LABEL_SIZE;						attr.setLabelHeightP(labelSize);						attr.setLabelHeightPOverridden(true);						attr.setLabelColor(JOAConstants.DEFAULT_ISOPYCNAL_LABEL_COLOR);						attr.setLabelColorOverridden(true);						Hashtable<TextAttribute, Serializable> map = new Hashtable<TextAttribute, Serializable>();						map.put(TextAttribute.FAMILY, JOAConstants.DEFAULT_ISOPYCNAL_LABEL_FONT);						map.put(TextAttribute.SIZE, new Float(JOAConstants.DEFAULT_ISOPYCNAL_LABEL_SIZE));						if (JOAConstants.DEFAULT_ISOPYCNAL_LABEL_STYLE == Font.BOLD						    || JOAConstants.DEFAULT_ISOPYCNAL_LABEL_STYLE == (Font.BOLD | Font.ITALIC)) {							map.put(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD);						}						if (JOAConstants.DEFAULT_ISOPYCNAL_LABEL_STYLE == Font.ITALIC						    || JOAConstants.DEFAULT_ISOPYCNAL_LABEL_STYLE == (Font.BOLD | Font.ITALIC)) {							map.put(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE);						}						map.put(TextAttribute.FOREGROUND, JOAConstants.DEFAULT_ISOPYCNAL_LABEL_COLOR);						Font lblFont = new Font(map);						attr.setLabelFont(lblFont);						attr.setLabelFontOverridden(true);						if (mPlotSpec.isColorLines())							attr.setColor(ncb.getColorValue(k));						else							attr.setColor(Color.black);						cLevels.addLevel(ncb.getDoubleValue(k), attr);					}				}				// have SGT create the contour lines				Contour cont = new Contour(this, grid, cLevels, mPlotSpec.getLabelPrecision());				cont.generateContourLines();				cont.generateContourLabels(g);				Enumeration<?> myenum = cont.elements();				while (myenum.hasMoreElements()) {					ContourLine cl = (ContourLine)myenum.nextElement();					cl.draw(g);				}			}		}		public void plotOverlayContours(Graphics2D g) {			mOverlayColorBar = mPlotSpec.getOverlayColorBar();			mOverlayColorBar.getNumLevels();			colors = mOverlayColorBar.getColors();			mOverlayColorBar.getValues();			double[][] ovlInterpValues = mPlotSpec.getOverlayInterp().getValues();			int ovlnsta = mOverlayInterpolation.getNumStns();			// compute the start and end levels			int maxY = this.getSize().height - pBottomMargin - pTopMargin;			int minLevel = 0;			int maxLevel = nz;			boolean fmax = false;			for (int i = 0; i < nz - 1; i++) {				if (surfaceValues[i] <= mPlotMin) {					minLevel = i; // < nz-1 ? i + 1 : i;				}				if (surfaceValues[i] >= mPlotMax && !fmax) {					maxLevel = i < nz - 1 ? i + 1 : i;					fmax = true;				}			}			if (maxLevel > nz) {				maxLevel = nz;			}			int numActualLevels = maxLevel - minLevel;			// compute the coordinates of the y grid			double[] y = new double[numActualLevels];			for (int i = 0; i < numActualLevels; i++) {				y[i] = JOAConstants.MISSINGVALUE;			}			int c = 0;			for (int i = minLevel; i < maxLevel; i++) {				y[c] = (surfaceValues[i] - yOrigin) * yScale;				y[c] = maxY - y[c];				y[c] = pTopMargin + y[c];				c++;			}			// compute the coordinates of the x grid			double[] x = new double[ovlnsta];			for (int i = 0; i < ovlnsta; i++) {				x[i] = Double.NaN;			}			int numStnsTrim = 0;			int j = 0;			for (int fc = 0; fc < mOverlayFileViewer.mNumOpenFiles; fc++) {				OpenDataFile of = (OpenDataFile)mOverlayFileViewer.mOpenFiles.elementAt(fc);				// loop over the sections				for (int sec = 0; sec < of.mNumSections; sec++) {					Section sech = (Section)of.mSections.elementAt(sec);					if (sech.mNumCasts == 0) {						continue;					}					// loop over the stations					for (int stc = 0; stc < sech.mStations.size(); stc++) {						Station sh = (Station)sech.mStations.elementAt(stc);						if (!sh.mUseStn) {							continue;						}						if (!mStationRegion.isStnInRegion(sh)) {							numStnsTrim++;							continue;						}						if (mOffset == JOAConstants.OFFSET_SEQUENCE) {							x[j] = pLeftMargin + (mStationRegion.getXScale() * j);						}						else if (mOffset == JOAConstants.OFFSET_DISTANCE) {							x[j] = pLeftMargin + (mStationRegion.getXScale() * sh.getCumDistInKM());						}						else if (mOffset == JOAConstants.OFFSET_LATITUDE) {							if (!mNtoSSection) {								x[j] = pLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());							}							else {								x[j] = pLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());							}						}						else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {							// lon must increase to the right							double lon = sh.mLon;							if (mStationRegion.getLeftLon() < 0) {								if (lon < 0 && lon < mStationRegion.getLeftLon()) {									lon += 360.0;								}							}							else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {								lon += 360.0;							}							// if (mOverlayFileViewer.mStnFilterActive) {							// if (mOverlayFileViewer.mFilteredDataCross180) {							// if (lon < 0) {							// lon += 360.0;							// }							// }							// }							// else {							// if (mOverlayFileViewer.mUnFilteredDataCross180) {							// if (lon < 0) {							// lon += 360.0;							// }							// }							// }							x[j] = pLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale());						}						else if (mOffset == JOAConstants.OFFSET_TIME) {							x[j] = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion							    .getMinTime())));						}						j++;					}				}			}			// the z values go in this flattened array			double[] zgrid = new double[numActualLevels * (ovlnsta - numStnsTrim)];			// System.out.println(" numActualLevels= " + numActualLevels);			// assign values to the flattened a array			c = 0;			for (int i = 0; i < (ovlnsta - numStnsTrim); i++) {				for (int l = minLevel; l < maxLevel; l++) {					double val = ovlInterpValues[l][i];					if (val != JOAConstants.MISSINGVALUE) {						zgrid[c] = val;					}					else {						zgrid[c] = Double.NaN;					}					// System.out.println(" zgrid[c]= " + zgrid[c]);					c++;				}			}			double[] trimmedx = new double[(ovlnsta - numStnsTrim)];			for (int i = 0; i < (ovlnsta - numStnsTrim); i++) {				trimmedx[i] = x[i];			}			// System.out.println(" c= " + c);			// System.out.println(" zgrid= " + zgrid.length);			// create a SimpleGrid from the x and y grids, the zgrid is a flattened 2D			// array			SimpleGrid grid = new SimpleGrid(zgrid, trimmedx, y, "title");			// create a contour levels array			ContourLevels cLevels = new ContourLevels();			NewColorBar ncb = mPlotSpec.getOverlayColorBar();			int ncl = ncb.getNumLevels();			Color contColor = null;			boolean contoursAreBlack = mPlotSpec.getOverlayContourColor() instanceof Color			    && JOAFormulas.isSameColor((Color)mPlotSpec.getOverlayContourColor(), Color.black);			boolean contoursAreWhite = mPlotSpec.getOverlayContourColor() instanceof Color			    && JOAFormulas.isSameColor((Color)mPlotSpec.getOverlayContourColor(), Color.white);			boolean contoursAreCustom = mPlotSpec.getOverlayContourColor() instanceof Color && !contoursAreBlack			    && !contoursAreWhite;			if (contoursAreCustom) {				contColor = (Color)mPlotSpec.getOverlayContourColor();			}			else if (contoursAreBlack) {				contColor = Color.black;			}			else if (contoursAreWhite) {				contColor = Color.white;			}			/**			 * @todo built in colorbars have to have the contour attribute defined			 */			if (mPlotEveryNthOvlContour <= 0) {				mPlotEveryNthOvlContour = 1;			}			for (int k = 0; k < ncl; k += mPlotEveryNthOvlContour) {				ContourLineAttribute attr = ncb.getContourAttributes(k);				if (attr == null) {					if (ncb.getDoubleValue(k) < 0.0) {						if (JOAConstants.THICKEN_OVERLAY_CONTOUR_LINES) {							ContourLineAttribute tattr = new ContourLineAttribute(ContourLineAttribute.DASHED);							attr = new ContourLineAttribute(ContourLineAttribute.STROKE);							attr.setWidth((float)(tattr.getWidth() * 1.5));							attr.setWidthOverridden(true);							attr.setDashArray(tattr.getDashArray());							attr.setDashPhase(tattr.getDashPhase());							attr.setDashArrayOverridden(true);							attr.setDashPhaseOverridden(true);						}						else {							attr = new ContourLineAttribute(ContourLineAttribute.DASHED);						}					}					else if (ncb.getDoubleValue(k) > 0.0) {						if (JOAConstants.THICKEN_OVERLAY_CONTOUR_LINES) {							ContourLineAttribute tattr = new ContourLineAttribute(ContourLineAttribute.SOLID);							attr = new ContourLineAttribute(ContourLineAttribute.STROKE);							attr.setWidth((float)(tattr.getWidth() * 1.5));							attr.setWidthOverridden(true);							attr.setDashArray(tattr.getDashArray());							attr.setDashPhase(tattr.getDashPhase());							attr.setDashArrayOverridden(true);							attr.setDashPhaseOverridden(true);						}						else {							attr = new ContourLineAttribute(ContourLineAttribute.SOLID);						}					}					else {						if (JOAConstants.THICKEN_OVERLAY_CONTOUR_LINES) {							ContourLineAttribute tattr = new ContourLineAttribute(ContourLineAttribute.HEAVY);							attr = new ContourLineAttribute(ContourLineAttribute.STROKE);							attr.setWidth((float)(tattr.getWidth() * 2.5));							attr.setWidthOverridden(true);							attr.setDashArray(tattr.getDashArray());							attr.setDashPhase(tattr.getDashPhase());							attr.setDashArrayOverridden(true);							attr.setDashPhaseOverridden(true);						}						else {							attr = new ContourLineAttribute(ContourLineAttribute.HEAVY);						}					}					attr.setStyleOverridden(true);					double labelSize = (double)JOAConstants.DEFAULT_ISOPYCNAL_LABEL_SIZE;					attr.setLabelHeightP(labelSize);					attr.setLabelHeightPOverridden(true);					Hashtable<TextAttribute, Serializable> map = new Hashtable<TextAttribute, Serializable>();					map.put(TextAttribute.FAMILY, JOAConstants.DEFAULT_ISOPYCNAL_LABEL_FONT);					map.put(TextAttribute.SIZE, new Float(JOAConstants.DEFAULT_ISOPYCNAL_LABEL_SIZE));					if (JOAConstants.DEFAULT_ISOPYCNAL_LABEL_STYLE == Font.BOLD					    || JOAConstants.DEFAULT_ISOPYCNAL_LABEL_STYLE == (Font.BOLD | Font.ITALIC)) {						map.put(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD);					}					if (JOAConstants.DEFAULT_ISOPYCNAL_LABEL_STYLE == Font.ITALIC					    || JOAConstants.DEFAULT_ISOPYCNAL_LABEL_STYLE == (Font.BOLD | Font.ITALIC)) {						map.put(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE);					}					map.put(TextAttribute.FOREGROUND, JOAConstants.DEFAULT_ISOPYCNAL_LABEL_COLOR);					Font lblFont = new Font(map);					attr.setLabelFont(lblFont);					attr.setLabelFontOverridden(true);					if (contColor != null) {						attr.setColor(contColor);					}					else {						attr.setColor(ncb.getColorValue(k));					}					cLevels.addLevel(ncb.getDoubleValue(k), attr);				}				else {					if (ncb.getDoubleValue(k) < 0.0) {						if (JOAConstants.THICKEN_OVERLAY_CONTOUR_LINES) {							ContourLineAttribute tattr = new ContourLineAttribute(ContourLineAttribute.DASHED);							attr = new ContourLineAttribute(ContourLineAttribute.STROKE);							attr.setWidth((float)(tattr.getWidth() * 1.5));							attr.setWidthOverridden(true);							attr.setDashArray(tattr.getDashArray());							attr.setDashPhase(tattr.getDashPhase());							attr.setDashArrayOverridden(true);							attr.setDashPhaseOverridden(true);						}						else {							attr = new ContourLineAttribute(ContourLineAttribute.DASHED);						}					}					else if (ncb.getDoubleValue(k) > 0.0) {						if (JOAConstants.THICKEN_OVERLAY_CONTOUR_LINES) {							ContourLineAttribute tattr = new ContourLineAttribute(ContourLineAttribute.SOLID);							attr = new ContourLineAttribute(ContourLineAttribute.STROKE);							attr.setWidth((float)(tattr.getWidth() * 1.5));							float[] newDashes = { 12.0f, 0.0f };							attr.setWidthOverridden(true);							attr.setDashArray(newDashes);							attr.setDashPhase(0.0f);							attr.setDashArrayOverridden(true);							attr.setDashPhaseOverridden(true);						}						else {							attr = new ContourLineAttribute(ContourLineAttribute.SOLID);						}					}					else {						if (JOAConstants.THICKEN_OVERLAY_CONTOUR_LINES) {							ContourLineAttribute tattr = new ContourLineAttribute(ContourLineAttribute.HEAVY);							attr = new ContourLineAttribute(ContourLineAttribute.STROKE);							attr.setWidth((float)(tattr.getWidth() * 2.5));							float[] newDashes = { 12.0f, 0.0f };							attr.setWidthOverridden(true);							attr.setDashArray(newDashes);							attr.setDashPhase(0.0f);							attr.setDashArrayOverridden(true);							attr.setDashPhaseOverridden(true);						}						else {							attr = new ContourLineAttribute(ContourLineAttribute.HEAVY);						}					}					attr.setStyleOverridden(true);					double labelSize = (double)JOAConstants.DEFAULT_ISOPYCNAL_LABEL_SIZE;					attr.setLabelHeightP(labelSize);					attr.setLabelHeightPOverridden(true);					attr.setLabelColor(JOAConstants.DEFAULT_ISOPYCNAL_LABEL_COLOR);					attr.setLabelColorOverridden(true);					Hashtable<TextAttribute, Serializable> map = new Hashtable<TextAttribute, Serializable>();					map.put(TextAttribute.FAMILY, JOAConstants.DEFAULT_ISOPYCNAL_LABEL_FONT);					map.put(TextAttribute.SIZE, new Float(JOAConstants.DEFAULT_ISOPYCNAL_LABEL_SIZE));					if (JOAConstants.DEFAULT_ISOPYCNAL_LABEL_STYLE == Font.BOLD					    || JOAConstants.DEFAULT_ISOPYCNAL_LABEL_STYLE == (Font.BOLD | Font.ITALIC)) {						map.put(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD);					}					if (JOAConstants.DEFAULT_ISOPYCNAL_LABEL_STYLE == Font.ITALIC					    || JOAConstants.DEFAULT_ISOPYCNAL_LABEL_STYLE == (Font.BOLD | Font.ITALIC)) {						map.put(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE);					}					map.put(TextAttribute.FOREGROUND, JOAConstants.DEFAULT_ISOPYCNAL_LABEL_COLOR);					Font lblFont = new Font(map);					attr.setLabelFont(lblFont);					attr.setLabelFontOverridden(true);					if (contColor != null) {						attr.setColor(contColor);					}					else {						attr.setColor(ncb.getColorValue(k));					}					cLevels.addLevel(ncb.getDoubleValue(k), attr);				}				// ContourLineAttribute attr = ncb.getContourAttributes(k);				// if (attr == null) {				// attr = new ContourLineAttribute();				// if (contColor != null) {				// attr.setColor(contColor);				// }				// else {				// attr.setColor(ncb.getColorValue(k));				// }				// cLevels.addLevel(ncb.getDoubleValue(k), attr);				// }				// else {				// if (contColor != null) {				// attr.setColor(contColor);				// }				// else {				// attr.setColor(ncb.getColorValue(k));				// }				// cLevels.addLevel(ncb.getDoubleValue(k), attr);				// }			}			// have SGT create the contour lines			Contour cont = new Contour(this, grid, cLevels, mPlotSpec.getOvlLabelPrecision());			cont.generateContourLines();			cont.generateContourLabels(g);			Enumeration<?> myenum = cont.elements();			while (myenum.hasMoreElements()) {				ContourLine cl = (ContourLine)myenum.nextElement();				cl.draw(g);			}		}		public UVCoordinate intersect(double level, double x1, double y1, double v1, double x2, double y2, double v2) {			double s, minV, maxV, Oms;			double xCross, yCross;			if (v1 == JOAConstants.MISSINGVALUE || v2 == JOAConstants.MISSINGVALUE) { return null; }			minV = (v1 < v2) ? v1 : v2;			maxV = (v1 > v2) ? v1 : v2;			if (!(minV <= level && level < maxV)) { return null; }			s = (level - minV) / Math.abs(v1 - v2);			Oms = 1 - s;			if (v1 < v2) {				xCross = s * x2 + Oms * x1;				yCross = s * y2 + Oms * y1;			}			else {				xCross = s * x1 + Oms * x2;				yCross = s * y1 + Oms * y2;			}			return new UVCoordinate(xCross, yCross);		}		public void plotBottom(Graphics2D g) {			int maxY = this.getSize().height - pBottomMargin - pTopMargin;			double y0;			g.setClip(pRightMargin, pTopMargin, this.getSize().width, this.getSize().height - pBottomMargin - pTopMargin);			if (mStyle == JOAConstants.STYLE_CONTOURS) {				if (mPlotSpec.getBGColor() == JOAConstants.DEFAULT_CONTENTS_COLOR) {					g.setColor(Color.black);				}				else if (mPlotSpec.getBGColor() == Color.black) {					g.setColor(Color.gray);				}				else if (mPlotSpec.getBGColor() == Color.gray) {					g.setColor(Color.black);				}				else {					g.setColor(JOAFormulas.getContrastingColor(mPlotSpec.getBGColor()));				}			}			else {				g.setColor(Color.black);			}			OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.elementAt(0);			Section sech = (Section)of.mSections.elementAt(0);			Station sh = null;			// this appears to find the first used stations			int cnt = 0;			while (true) {				sh = (Station)sech.mStations.elementAt(cnt);				if (sh.mUseStn || ++cnt > mFileViewer.mTotalStations) {					break;				}			}			// initialize plotting			if (sh.mBottomDepthInDBARS != JOAConstants.MISSINGVALUE && sh.mBottomDepthInDBARS > 0) {				y0 = sh.mBottomDepthInDBARS;				y0 = JOAFormulas.zToPres((double)sh.mBottomDepthInDBARS);				y0 = (y0 - yOrigin) * yScale;				y0 = maxY - y0;				y0 = pTopMargin + y0;			}			else {				y0 = pTopMargin + maxY;			}			int v = pTopMargin;			int h = pLeftMargin;			int oldh = pLeftMargin;			int oldv = pTopMargin;			for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {				of = (OpenDataFile)mFileViewer.mOpenFiles.elementAt(fc);				// loop over the sections				int stnCnt = 0;				for (int sec = 0; sec < of.mNumSections; sec++) {					sech = (Section)of.mSections.elementAt(sec);					if (sech.mNumCasts == 0) {						continue;					}					// loop over the stations					for (int stc = 0; stc < sech.mStations.size(); stc++) {						sh = (Station)sech.mStations.elementAt(stc);						if (!sh.mUseStn) {							continue;						}						if (!mStationRegion.isStnInRegion(sh)) {							continue;						}						/* look to see if bottom is recorded */						if (sh.mBottomDepthInDBARS != JOAConstants.MISSINGVALUE && sh.mBottomDepthInDBARS > 0) {							double bottom = sh.mBottomDepthInDBARS;							if (mPlotMax > bottom) {								v = (int)(JOAFormulas.zToPres(bottom));								v = (int)((v - yOrigin) * yScale);								v = maxY - v;								v = pTopMargin + v;							}							else {								v = maxY + pTopMargin;							}							if (v > maxY + pTopMargin) {								v = maxY + pTopMargin;							}							if (mOffset == JOAConstants.OFFSET_SEQUENCE) {								h = (int)(pLeftMargin + (stnCnt * mStationRegion.getXScale()));							}							else if (mOffset == JOAConstants.OFFSET_DISTANCE) {								h = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset())));							}							else if (mOffset == JOAConstants.OFFSET_LATITUDE) {								if (!mNtoSSection) {									h = pLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());								}								else {									h = pLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());								}							}							else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {								// lon must increase to the right								double lon = sh.mLon;								if (mStationRegion.getLeftLon() < 0) {									if (lon < 0 && lon < mStationRegion.getLeftLon()) {										lon += 360.0;									}								}								else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {									lon += 360.0;								}								// if (mFileViewer.mStnFilterActive) {								// if (mFileViewer.mFilteredDataCross180) {								// if (lon < 0) {								// lon += 360.0;								// }								// }								// }								// else {								// if (mFileViewer.mUnFilteredDataCross180) {								// if (lon < 0) {								// lon += 360.0;								// }								// }								// }								double offsetLon = lon - mStationRegion.getLeftLon();								h = (int)(pLeftMargin + offsetLon * mStationRegion.getXScale());							}							else if (mOffset == JOAConstants.OFFSET_TIME) {								h = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion								    .getMinTime())));							}							if (oldh != JOAConstants.MISSINGVALUE && oldv != JOAConstants.MISSINGVALUE) {								g.drawLine(oldh, oldv, h, v);								int[] xpoints = { oldh, h, h, oldh };								int[] ypoints = { oldv, v, pTopMargin + maxY + 1, pTopMargin + maxY + 1 };								g.fillPolygon(xpoints, ypoints, 4);								oldh = h;								oldv = v;							}							else {								oldh = h;								oldv = v;							}							stnCnt++;						}						else {							stnCnt++;							oldh = JOAConstants.MISSINGVALUE;							oldv = JOAConstants.MISSINGVALUE;						}					}				}			}			if (!mPlotSpec.isAutoScaleXAxis()) {				int width = (int)((mStationRegion.getXScale() * mFileViewer.mTotMercDist));				g.drawLine(pLeftMargin, maxY + pTopMargin, width, maxY + pTopMargin);			}			else {				g.drawLine(pLeftMargin, maxY + pTopMargin, this.getSize().width - pRightMargin, maxY + pTopMargin);			}			g.setClip(0, 0, 2000, 2000);		}		public void PlotOverlayBottom(Graphics2D g) {			int maxY = this.getSize().height - pBottomMargin - pTopMargin;			double y0;			g.setClip(pRightMargin, pTopMargin, this.getSize().width, this.getSize().height - pBottomMargin - pTopMargin);			g.setColor(Color.gray.darker());			int p = mOverlayFileViewer.getPRESPropertyPos();			OpenDataFile of = (OpenDataFile)mOverlayFileViewer.mOpenFiles.elementAt(0);			Section sech = (Section)of.mSections.elementAt(0);			Station sh = null;			int cnt = 0;			while (true) {				sh = (Station)sech.mStations.elementAt(0);				if (sh.mUseStn || ++cnt > mOverlayFileViewer.mTotalStations) {					break;				}			}			if (sh.mBottomDepthInDBARS != JOAConstants.MISSINGVALUE && sh.mBottomDepthInDBARS > 0) {				y0 = sh.mBottomDepthInDBARS;				y0 = JOAFormulas.zToPres((double)sh.mBottomDepthInDBARS);				y0 = (y0 - yOrigin) * yScale;				y0 = maxY - y0;				y0 = pTopMargin + y0;			}			else {				y0 = pTopMargin + maxY;			}			int v = pTopMargin;			int h = pLeftMargin;			int oldh = pLeftMargin;			int oldv = pTopMargin;			// longitude plots are wrt to the underlying axis			for (int fc = 0; fc < mOverlayFileViewer.mNumOpenFiles; fc++) {				of = (OpenDataFile)mOverlayFileViewer.mOpenFiles.elementAt(fc);				// loop over the sections				int stnCnt = 0;				for (int sec = 0; sec < of.mNumSections; sec++) {					sech = (Section)of.mSections.elementAt(sec);					if (sech.mNumCasts == 0) {						continue;					}					// loop over the stations					for (int stc = 0; stc < sech.mStations.size(); stc++) {						sh = (Station)sech.mStations.elementAt(stc);						if (!sh.mUseStn) {							continue;						}						if (!mStationRegion.isStnInRegion(sh)) {							continue;						}						// look to see if bottom is recorded						if (sh.mBottomDepthInDBARS != JOAConstants.MISSINGVALUE && sh.mBottomDepthInDBARS > 0) {							double bottom = sh.mBottomDepthInDBARS * mOverlayFileViewer.mAllProperties[p].getActScale()							    + mOverlayFileViewer.mAllProperties[p].getActOrigin();							if (mPlotMax > bottom) {								v = (int)(JOAFormulas.zToPres(bottom));								v = (int)((v - yOrigin) * yScale);								v = maxY - v;								v = pTopMargin + v;							}							else {								v = maxY + pTopMargin;							}							if (v > maxY + pTopMargin) {								v = maxY + pTopMargin;							}							if (mOffset == JOAConstants.OFFSET_SEQUENCE) {								h = (int)(pLeftMargin + (stnCnt * mStationRegion.getXScale()));							}							else if (mOffset == JOAConstants.OFFSET_DISTANCE) {								h = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset())));							}							else if (mOffset == JOAConstants.OFFSET_LATITUDE) {								if (!mNtoSSection) {									h = pLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());								}								else {									h = pLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());								}							}							else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {								// lon must increase to the right								double lon = sh.mLon;								if (mStationRegion.getLeftLon() < 0) {									if (lon < 0 && lon < mStationRegion.getLeftLon()) {										lon += 360.0;									}								}								else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {									lon += 360.0;								}								// if (mOverlayFileViewer.mStnFilterActive) {								// if (mOverlayFileViewer.mFilteredDataCross180) {								// if (lon < 0) {								// lon += 360.0;								// }								// }								// }								// else {								// if (mOverlayFileViewer.mUnFilteredDataCross180) {								// if (lon < 0) {								// lon += 360.0;								// }								// }								// }								h = (int)(pLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));							}							else if (mOffset == JOAConstants.OFFSET_TIME) {								h = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion								    .getMinTime())));							}							if (oldh != JOAConstants.MISSINGVALUE && oldv != JOAConstants.MISSINGVALUE) {								g.drawLine(oldh, oldv, h, v);								int[] xpoints = { oldh, h, h, oldh };								int[] ypoints = { oldv, v, pTopMargin + maxY + 1, pTopMargin + maxY + 1 };								g.fillPolygon(xpoints, ypoints, 4);								oldh = h;								oldv = v;							}							else {								oldh = h;								oldv = v;							}							stnCnt++;						}						else {							stnCnt++;							oldh = JOAConstants.MISSINGVALUE;							oldv = JOAConstants.MISSINGVALUE;						}					}				}			}			if (!mPlotSpec.isAutoScaleXAxis()) {				int width = (int)((mStationRegion.getXScale() * mOverlayFileViewer.mTotMercDist));				g.drawLine(pLeftMargin, maxY + pTopMargin, width, maxY + pTopMargin);			}			else {				g.drawLine(pLeftMargin, maxY + pTopMargin, this.getSize().width - pRightMargin, maxY + pTopMargin);			}			g.setClip(0, 0, 2000, 2000);		}		public void drawSectionPoints(Graphics2D g) {			int maxY = this.getSize().height - pBottomMargin - pTopMargin;			int h = 0, v;			int stnCnt = 0;			for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {				OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.elementAt(fc);				for (int sec = 0; sec < of.mNumSections; sec++) {					Section sech = (Section)of.mSections.elementAt(sec);					if (sech.mNumCasts == 0) {						continue;					}					int iPos = sech.getVarPos(interpVar.getVarName(), false);					int sPos = sech.getVarPos(mFileViewer.mAllProperties[surfVarNum].getVarLabel(), false);					if (sPos < 0 || iPos < 0) {						continue;					}					for (int stc = 0; stc < sech.mStations.size(); stc++) {						Station sh = (Station)sech.mStations.elementAt(stc);						if (!sh.mUseStn) {							continue;						}						if (!mStationRegion.isStnInRegion(sh)) {							continue;						}						if (mOffset == JOAConstants.OFFSET_SEQUENCE) {							h = (int)(pLeftMargin + (stnCnt++ * mStationRegion.getXScale()));						}						else if (mOffset == JOAConstants.OFFSET_DISTANCE) {							h = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset())));						}						else if (mOffset == JOAConstants.OFFSET_LATITUDE) {							if (!mNtoSSection) {								h = pLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());							}							else {								h = pLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());							}						}						else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {							// lon must increase to the right							double lon = sh.mLon;							if (mStationRegion.getLeftLon() < 0) {								if (lon < 0 && lon < mStationRegion.getLeftLon()) {									lon += 360.0;								}							}							else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {								lon += 360.0;							}							// if (mFileViewer.mStnFilterActive) {							// if (mFileViewer.mFilteredDataCross180) {							// if (lon < 0) {							// lon += 360.0;							// }							// }							// }							// else {							// if (mFileViewer.mUnFilteredDataCross180) {							// if (lon < 0) {							// lon += 360.0;							// }							// }							// }							h = (int)(pLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));						}						else if (mOffset == JOAConstants.OFFSET_TIME) {							h = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion							    .getMinTime())));						}						for (int b = 0; b < sh.mNumBottles; b++) {							Bottle bh = (Bottle)sh.mBottles.elementAt(b);							double val = bh.mDValues[sPos];							double ival = bh.mDValues[iPos];							if (ival == JOAConstants.MISSINGVALUE) {								continue;							}							if (val >= mPlotSpec.getWinYPlotMin() && val <= mPlotSpec.getWinYPlotMax()) {								v = (int)((val - yOrigin) * yScale);								if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {									v = maxY - v;								}								v = pTopMargin + v;								if (bh.mDValues[iPos] != JOAConstants.MISSINGVALUE) {									if (mPlotSpec.getBGColor() == JOAConstants.DEFAULT_CONTENTS_COLOR) {										g.setColor(Color.black);									}									else if (mPlotSpec.getBGColor() == Color.black) {										g.setColor(Color.gray);									}									else if (mPlotSpec.getBGColor() == Color.gray) {										g.setColor(Color.black);									}									else {										g.setColor(JOAFormulas.getContrastingColor(mPlotSpec.getBGColor()));									}								}								else {									if (mPlotSpec.getBGColor() == JOAConstants.DEFAULT_CONTENTS_COLOR) {										g.setColor(Color.black);									}									else if (mPlotSpec.getBGColor() == Color.black) {										g.setColor(Color.gray);									}									else if (mPlotSpec.getBGColor() == Color.gray) {										g.setColor(Color.black);									}									else {										g.setColor(JOAFormulas.getContrastingColor(mPlotSpec.getBGColor()));									}								}								g.setColor(mPlotSpec.getSymbolColor());								g.fillRect(h - mMarkerSize / 2, v - mMarkerSize / 2, mMarkerSize, mMarkerSize);							}						}					}				}			}		}		public void drawLevelsPoints(Graphics2D g) {			int maxY = this.getSize().height - pBottomMargin - pTopMargin;			int secx0 = 0, y0;			if (mPlotSpec.getBGColor() == JOAConstants.DEFAULT_CONTENTS_COLOR) {				g.setColor(Color.black);			}			else if (mPlotSpec.getBGColor() == Color.black) {				g.setColor(Color.gray);			}			else if (mPlotSpec.getBGColor() == Color.gray) {				g.setColor(Color.black);			}			else {				g.setColor(JOAFormulas.getContrastingColor(mPlotSpec.getBGColor()));			}			g.setColor(mPlotSpec.getSymbolColor());			// loop on the number of stations in the interpolated array			if (mInterpolation instanceof LinearInterpolation) {				int stnCnt = 0;				for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {					OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.elementAt(fc);					for (int sec = 0; sec < of.mNumSections; sec++) {						Section sech = (Section)of.mSections.elementAt(sec);						if (sech.mNumCasts == 0) {							continue;						}						for (int stc = 0; stc < sech.mStations.size(); stc++) {							Station sh = (Station)sech.mStations.elementAt(stc);							if (!sh.mUseStn) {								continue;							}							if (!mStationRegion.isStnInRegion(sh)) {								continue;							}							if (mOffset == JOAConstants.OFFSET_SEQUENCE) {								secx0 = (int)(pLeftMargin + (stnCnt++ * mStationRegion.getXScale()));							}							else if (mOffset == JOAConstants.OFFSET_DISTANCE) {								secx0 = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset())));							}							else if (mOffset == JOAConstants.OFFSET_LATITUDE) {								if (!mNtoSSection) {									secx0 = pLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());								}								else {									secx0 = pLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());								}							}							else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {								// lon must increase to the right								double lon = sh.mLon;								if (mStationRegion.getLeftLon() < 0) {									if (lon < 0 && lon < mStationRegion.getLeftLon()) {										lon += 360.0;									}								}								else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {									lon += 360.0;								}								// if (mFileViewer.mStnFilterActive) {								// if (mFileViewer.mFilteredDataCross180) {								// if (lon < 0) {								// lon += 360.0;								// }								// }								// }								// else {								// if (mFileViewer.mUnFilteredDataCross180) {								// if (lon < 0) {								// lon += 360.0;								// }								// }								// }								secx0 = (int)(pLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));							}							else if (mOffset == JOAConstants.OFFSET_TIME) {								secx0 = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion								    .getMinTime())));							}							// now loop on the number of interpolated levels							for (int l = 0; l < nz; l++) {								double val = surfaceValues[l];								if (val >= mPlotSpec.getWinYPlotMin() && val <= mPlotSpec.getWinYPlotMax()) {									y0 = (int)((val - yOrigin) * yScale);									if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {										y0 = maxY - y0;									}									y0 = pTopMargin + y0;									// test whether either of these is a missing value									if (y0 != JOAConstants.MISSINGVALUE) {										// plot level										g.fillRect(secx0 - mMarkerSize / 2, y0 - mMarkerSize / 2, mMarkerSize, mMarkerSize);									}								}							}						}					}				}			}			else {				ZGridInterpolation zgi = (ZGridInterpolation)mInterpolation;				int numCols = zgi.getNumStns();				int nl = zgi.getLevels();				double[] zgl = zgi.getGridLevels();				for (int i = 0; i < numCols; i++) {					if (mOffset == JOAConstants.OFFSET_SEQUENCE) {						secx0 = (int)(pLeftMargin + (i * mStationRegion.getXScale()));					}					else if (mOffset == JOAConstants.OFFSET_DISTANCE) {						secx0 = (int)(pLeftMargin + (mStationRegion.getXScale() * (i * zgi.getDX())));					}					// else if (mOffset == JOAConstants.OFFSET_LATITUDE) {					// if (!mNtoSSection) {					// secx0 = pLeftMargin + (int) ((sh.mLat - mFileViewer.mLatMin) *					// pixelsPerUnit);					// }					// else {					// secx0 = pLeftMargin + (int) ((mFileViewer.mLatMax - sh.mLat) *					// pixelsPerUnit);					// }					// }					// else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {					// // lon must increase to the right					// double lon = sh.mLon;					// if (leftLon < 0) {					// if (lon < 0 && lon < leftLon) {					// lon += 360.0;					// }					// }					// }					// now loop on the number of interpolated levels					for (int l = 0; l < zgl.length; l++) {						double val = zgl[l];						if (val >= mPlotSpec.getWinYPlotMin() && val <= mPlotSpec.getWinYPlotMax()) {							y0 = (int)((val - yOrigin) * yScale);							if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {								y0 = maxY - y0;							}							y0 = pTopMargin + y0;							// plot level							g.fillRect(secx0 - mMarkerSize / 2, y0 - mMarkerSize / 2, mMarkerSize, mMarkerSize);						}					}				}			}		}		public void drawOverlaySectionPoints(Graphics2D g) {			int maxY = this.getSize().height - pBottomMargin - pTopMargin;			int h = 0, v;			// fileviewer comes from the overlay parameter			int markSize = mPlotSpec.getOverlayMarkerSize();			int stnCnt = 0;			for (int fc = 0; fc < mOverlayFileViewer.mNumOpenFiles; fc++) {				OpenDataFile of = (OpenDataFile)mOverlayFileViewer.mOpenFiles.elementAt(fc);				for (int sec = 0; sec < of.mNumSections; sec++) {					Section sech = (Section)of.mSections.elementAt(sec);					if (sech.mNumCasts == 0) {						continue;					}					int iPos = sech.getVarPos(interpVar.getVarName(), false);					int sPos = sech.getVarPos(mOverlayFileViewer.mAllProperties[surfVarNum].getVarLabel(), false);					if (sPos < 0 || iPos < 0) {						continue;					}					for (int stc = 0; stc < sech.mStations.size(); stc++) {						Station sh = (Station)sech.mStations.elementAt(stc);						if (!sh.mUseStn) {							continue;						}						if (!mStationRegion.isStnInRegion(sh)) {							continue;						}						if (mOffset == JOAConstants.OFFSET_SEQUENCE) {							h = (int)(pLeftMargin + (stnCnt++ * mStationRegion.getXScale()));						}						else if (mOffset == JOAConstants.OFFSET_DISTANCE) {							h = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset())));						}						else if (mOffset == JOAConstants.OFFSET_LATITUDE) {							if (!mNtoSSection) {								h = pLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());							}							else {								h = pLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());							}						}						else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {							// lon must increase to the right							double lon = sh.mLon;							if (mStationRegion.getLeftLon() < 0) {								if (lon < 0 && lon < mStationRegion.getLeftLon()) {									lon += 360.0;								}							}							else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {								lon += 360.0;							}							// if (mOverlayFileViewer.mStnFilterActive) {							// if (mOverlayFileViewer.mFilteredDataCross180) {							// if (lon < 0) {							// lon += 360.0;							// }							// }							// }							// else {							// if (mOverlayFileViewer.mUnFilteredDataCross180) {							// if (lon < 0) {							// lon += 360.0;							// }							// }							// }							h = (int)(pLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));						}						else if (mOffset == JOAConstants.OFFSET_TIME) {							h = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion							    .getMinTime())));						}						for (int b = 0; b < sh.mNumBottles; b++) {							Bottle bh = (Bottle)sh.mBottles.elementAt(b);							double val = bh.mDValues[sPos];							double ival = bh.mDValues[iPos];							if (ival == JOAConstants.MISSINGVALUE) {								continue;							}							if (val >= mPlotSpec.getWinYPlotMin() && val <= mPlotSpec.getWinYPlotMax()) {								v = (int)((val - yOrigin) * yScale);								if (mOverlayFileViewer.mAllProperties[surfVarNum].isReverseY()) {									v = maxY - v;								}								v = pTopMargin + v;								if (bh.mDValues[iPos] != JOAConstants.MISSINGVALUE) {									if (mPlotSpec.getBGColor() == JOAConstants.DEFAULT_CONTENTS_COLOR) {										g.setColor(Color.black);									}									else if (mPlotSpec.getBGColor() == Color.black) {										g.setColor(Color.gray);									}									else if (mPlotSpec.getBGColor() == Color.gray) {										g.setColor(Color.black);									}									else {										g.setColor(JOAFormulas.getContrastingColor(mPlotSpec.getBGColor()));									}								}								else {									if (mPlotSpec.getBGColor() == JOAConstants.DEFAULT_CONTENTS_COLOR) {										g.setColor(Color.black);									}									else if (mPlotSpec.getBGColor() == Color.black) {										g.setColor(Color.gray);									}									else if (mPlotSpec.getBGColor() == Color.gray) {										g.setColor(Color.black);									}									else {										g.setColor(JOAFormulas.getContrastingColor(mPlotSpec.getBGColor()));									}								}								g.setColor(mPlotSpec.getOverlaySymbolColor());								g.fillRect(h - markSize / 2, v - markSize / 2, markSize, markSize);							}						}					}				}			}		}		public void drawOverlayLevelsPoints(Graphics2D g) {			int maxY = this.getSize().height - pBottomMargin - pTopMargin;			int secx0 = 0, y0;			g.setColor(mPlotSpec.getOverlaySymbolColor());			// loop on the number of stations in the interpolated array			int markSize = mPlotSpec.getOverlayMarkerSize();			int stnCnt = 0;			for (int fc = 0; fc < mOverlayFileViewer.mNumOpenFiles; fc++) {				OpenDataFile of = (OpenDataFile)mOverlayFileViewer.mOpenFiles.elementAt(fc);				for (int sec = 0; sec < of.mNumSections; sec++) {					Section sech = (Section)of.mSections.elementAt(sec);					if (sech.mNumCasts == 0) {						continue;					}					for (int stc = 0; stc < sech.mStations.size(); stc++) {						Station sh = (Station)sech.mStations.elementAt(stc);						if (!sh.mUseStn) {							continue;						}						if (!mStationRegion.isStnInRegion(sh)) {							continue;						}						if (mOffset == JOAConstants.OFFSET_SEQUENCE) {							secx0 = (int)(pLeftMargin + (stnCnt++ * mStationRegion.getXScale()));						}						else if (mOffset == JOAConstants.OFFSET_DISTANCE) {							secx0 = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset())));						}						else if (mOffset == JOAConstants.OFFSET_LATITUDE) {							if (!mNtoSSection) {								secx0 = pLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());							}							else {								secx0 = pLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());							}						}						else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {							// lon must increase to the right							double lon = sh.mLon;							if (mStationRegion.getLeftLon() < 0) {								if (lon < 0 && lon < mStationRegion.getLeftLon()) {									lon += 360.0;								}							}							else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {								lon += 360.0;							}							// if (mOverlayFileViewer.mStnFilterActive) {							// if (mOverlayFileViewer.mFilteredDataCross180) {							// if (lon < 0) {							// lon += 360.0;							// }							// }							// }							// else {							// if (mOverlayFileViewer.mUnFilteredDataCross180) {							// if (lon < 0) {							// lon += 360.0;							// }							// }							// }							secx0 = (int)(pLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));						}						else if (mOffset == JOAConstants.OFFSET_TIME) {							secx0 = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion							    .getMinTime())));						}						// now loop on the number of interpolated levels						for (int l = 0; l < nz; l++) {							double val = surfaceValues[l];							if (val >= mPlotSpec.getWinYPlotMin() && val <= mPlotSpec.getWinYPlotMax()) {								y0 = (int)((val - yOrigin) * yScale);								if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {									y0 = maxY - y0;								}								y0 = pTopMargin + y0;								// test whether either of these is a missing value								if (y0 != JOAConstants.MISSINGVALUE) {									// plot level									g.fillRect(secx0 - markSize / 2, y0 - markSize / 2, markSize, markSize);								}							}						}					}				}			}		}		public void obsChanged(ObsChangedEvent evt) {			if (mWindowIsLocked) { return; }			if (mIgnore) {				mIgnore = false;				return;			}			// display the current station			Station sh = evt.getFoundStation();			Section sech = evt.getFoundSection();			Bottle bh = evt.getFoundBottle();			// kludge to work around memory leak			try {				setRecord(sech, sh, bh);			}			catch (Exception ex) {				ex.printStackTrace();			}		}		public void initDataSpot() {			// init the data spot			int width = this.getSize().width - pRightMargin;			int maxY = this.getSize().height - pBottomMargin - pTopMargin;			OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.currElement();			Section sech = (Section)of.mSections.currElement();			Station sh = (Station)sech.mStations.currElement();			Bottle bh = (Bottle)sh.mBottles.currElement();			int sPos = sech.getVarPos(mFileViewer.mAllProperties[surfVarNum].getVarLabel(), false);			int secx = 0;			int secy = pTopMargin;			if (mOffset == JOAConstants.OFFSET_SEQUENCE) {				if (sh.mOrdinal >= 1) {					secx = (int)(pLeftMargin + ((sh.mOrdinal - 1) * mStationRegion.getXScale()));				}				else {					secx = pLeftMargin;				}			}			else if (mOffset == JOAConstants.OFFSET_DISTANCE) {				secx = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset())));			}			else if (mOffset == JOAConstants.OFFSET_LATITUDE) {				if (!mNtoSSection) {					secx = pLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());				}				else {					secx = pLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());				}			}			else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {				// lon must increase to the right				double lon = sh.mLon;				if (mStationRegion.getLeftLon() < 0) {					if (lon < 0 && lon < mStationRegion.getLeftLon()) {						lon += 360.0;					}				}				else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {					lon += 360.0;				}				// if (mFileViewer.mStnFilterActive) {				// if (mFileViewer.mFilteredDataCross180) {				// if (lon < 0) {				// lon += 360.0;				// }				// }				// }				// else {				// if (mFileViewer.mUnFilteredDataCross180) {				// if (lon < 0) {				// lon += 360.0;				// }				// }				// }				secx = (int)(pLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));			}			else if (mOffset == JOAConstants.OFFSET_TIME) {				secx = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion.getMinTime())));			}			// look for a matching level to the current depth			double testPres = bh.mDValues[sPos];			for (int l = 0; l < nz; l++) {				double val = surfaceValues[l];				if (val >= testPres) {					secy = (int)((val - yOrigin) * yScale);					if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {						secy = maxY - secy;					}					secy = pTopMargin + secy;					mCurrLevel = l;					break;				}			}			if (mAxes && !mCrossSections) {				mObsMarker = new ObsMarker(secx, secy, JOAConstants.DEFAULT_CURSOR_SIZE);			}			else if (mAxes || mCrossSections) {				if (!mPlotSpec.isAutoScaleXAxis()) {					width = (int)(pLeftMargin + (mStationRegion.getXScale() * mFileViewer.mTotMercDist));				}				else {					width = this.getSize().width - pRightMargin;				}				mObsMarker = new CrossMarker(secx, secy, pTopMargin, pLeftMargin, this.getSize().height - pBottomMargin, width,				    JOAConstants.DEFAULT_CURSOR_SIZE);			}			else {				mObsMarker = new ObsMarker(secx, secy, JOAConstants.DEFAULT_CURSOR_SIZE);			}			// update any other local browsing panels			if (mLevelDisplay != null) {				mLevelDisplay.obsChanged(sh);			}		}		public void setRecord(Section sech, Station sh, Bottle bh) {			if (sh == null) { return; }			int maxY = this.getSize().height - pBottomMargin - pTopMargin;			int sPos = sech.getVarPos(mFileViewer.mAllProperties[surfVarNum].getVarLabel(), false);			int secx = 0;			int secy = pTopMargin;			if (mOffset == JOAConstants.OFFSET_SEQUENCE) {				secx = (int)(pLeftMargin + ((sh.mOrdinal - 1) * mStationRegion.getXScale()));			}			else if (mOffset == JOAConstants.OFFSET_DISTANCE) {				secx = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset())));			}			else if (mOffset == JOAConstants.OFFSET_LATITUDE) {				if (!mNtoSSection) {					secx = pLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());				}				else {					secx = pLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());				}			}			else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {				// lon must increase to the right				double lon = sh.mLon;				if (mStationRegion.getLeftLon() < 0) {					if (lon < 0 && lon < mStationRegion.getLeftLon()) {						lon += 360.0;					}				}				else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {					lon += 360.0;				}				// if (mFileViewer.mStnFilterActive) {				// if (mFileViewer.mFilteredDataCross180) {				// if (lon < 0) {				// lon += 360.0;				// }				// }				// }				// else {				// if (mFileViewer.mUnFilteredDataCross180) {				// if (lon < 0) {				// lon += 360.0;				// }				// }				// }				secx = (int)(pLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));			}			else if (mOffset == JOAConstants.OFFSET_TIME) {				secx = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion.getMinTime())));			}			// look for a matching level to the current depth			double testPres = bh.mDValues[sPos];			for (int l = 0; l < nz; l++) {				mCurrLevel = l;				double val = surfaceValues[l];				if (val >= testPres) {					secy = (int)((val - yOrigin) * yScale);					if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {						secy = maxY - secy;					}					secy = pTopMargin + secy;					break;				}			}			// update any other local browsing panels			if (mVXsec != null) {				mVXsec.obsChanged(sh);			}			if (mHXsec != null) {				mHXsec.obsChanged(sh);			}			if (mLevelDisplay != null) {				mLevelDisplay.obsChanged(sh);			}			if (mCbarDisplay != null) {				mCbarDisplay.obsChanged(sh);			}			mObsMarker.setNewPos(secx, secy);			Graphics g = getGraphics();			g.setClip(pRightMargin, pTopMargin, this.getSize().width, this.getSize().height - pBottomMargin - pTopMargin);			paintImmediately(new Rectangle(0, 0, 2000, 2000));			g.setClip(0, 0, 2000, 2000);		}		public void setRecordLocal(Station sh) {			int maxY = this.getSize().height - pBottomMargin - pTopMargin;			int secx = 0;			int secy = pTopMargin;			if (mOffset == JOAConstants.OFFSET_SEQUENCE) {				secx = (int)(pLeftMargin + ((sh.mOrdinal - 1) * mStationRegion.getXScale()));			}			else if (mOffset == JOAConstants.OFFSET_DISTANCE) {				secx = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset())));			}			else if (mOffset == JOAConstants.OFFSET_LATITUDE) {				if (!mNtoSSection) {					secx = pLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());				}				else {					secx = pLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());				}			}			else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {				// lon must increase to the right				double lon = sh.mLon;				if (mStationRegion.getLeftLon() < 0) {					if (lon < 0 && lon < mStationRegion.getLeftLon()) {						lon += 360.0;					}				}				else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {					lon += 360.0;				}				// if (mFileViewer.mStnFilterActive) {				// if (mFileViewer.mFilteredDataCross180) {				// if (lon < 0) {				// lon += 360.0;				// }				// }				// }				// else {				// if (mFileViewer.mUnFilteredDataCross180) {				// if (lon < 0) {				// lon += 360.0;				// }				// }				// }				secx = (int)(pLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));			}			else if (mOffset == JOAConstants.OFFSET_TIME) {				secx = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion.getMinTime())));			}			double val = surfaceValues[mCurrLevel];			secy = (int)((val - yOrigin) * yScale);			if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {				secy = maxY - secy;			}			secy = pTopMargin + secy;			mObsMarker.setNewPos(secx, secy);			paintImmediately(new Rectangle(0, 0, 2000, 2000));		}		public void findByXY(int x, int y) {			if (!mSpotable) { return; }			int maxY = this.getSize().height - pBottomMargin - pTopMargin;			int pPos = mFileViewer.getPRESPropertyPos();			int y0 = pTopMargin;			int closestLevel = 0;			int searchRectTop = y - 1;			int searchRectBottom = y + 1;			if (searchRectTop > searchRectBottom) {				int temp = searchRectTop;				searchRectTop = searchRectBottom;				searchRectBottom = temp;			}			int minLevel = 0;			int maxLevel = nz;			boolean fmax = false;			for (int i = 0; i < nz - 1; i++) {				if (surfaceValues[i] <= mPlotMin) {					minLevel = i; // < nz-1 ? i + 1 : i;				}				if (surfaceValues[i] >= mPlotMax && !fmax) {					maxLevel = i < nz - 1 ? i + 1 : i;					fmax = true;				}			}			if (maxLevel > nz) {				maxLevel = nz;			}			// look for a matching y			int[] delta = { 100000, 100000, 100000, 100000 };			double matchingSurfaceVal = 0.0;			closestLevel = minLevel;			for (int l = minLevel; l < maxLevel; l++) {				matchingSurfaceVal = surfaceValues[l];				y0 = (int)((matchingSurfaceVal - yOrigin) * yScale);				if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {					y0 = maxY - y0;				}				// test the interpolated value is a missing				if (y0 != JOAConstants.MISSINGVALUE) {					y0 = pTopMargin + y0;					if (Math.abs(y0 - searchRectBottom) <= delta[0]) {						delta[0] = Math.abs(y0 - searchRectBottom);						closestLevel = l;						matchingSurfaceVal = surfaceValues[closestLevel];					}					if (Math.abs(y0 - searchRectTop) <= delta[1]) {						delta[1] = Math.abs(y0 - searchRectTop);						closestLevel = l;						matchingSurfaceVal = surfaceValues[closestLevel];					}					if (y0 <= searchRectBottom && y0 >= searchRectTop) {						closestLevel = l;						matchingSurfaceVal = surfaceValues[closestLevel];						// break;					}				}			}			matchingSurfaceVal = surfaceValues[closestLevel];			mCurrLevel = closestLevel;			FoundBundle foundStuff = findStnByX(x, matchingSurfaceVal);			// post event so other components will update			if (foundStuff != null && foundStuff.getFoundBottle() != null) {				JOAConstants.currTestPres = foundStuff.getFoundBottle().mDValues[pPos];				mFileViewer.mOpenFiles.setCurrElement(foundStuff.getFoundFile());				foundStuff.getFoundFile().mSections.setCurrElement(foundStuff.getFoundSection());				foundStuff.getFoundSection().mStations.setCurrElement(foundStuff.getFoundStn());				foundStuff.getFoundStn().mBottles.setCurrElement(foundStuff.getFoundBottle());				ObsChangedEvent oce = new ObsChangedEvent(mFileViewer);				oce.setFoundObs(foundStuff.getFoundFile(), foundStuff.getFoundSection(), foundStuff.getFoundStn(), foundStuff				    .getFoundBottle(), this);				oce.setSendToMyself(false);				Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(oce);				if (mVXsec != null) {					mVXsec.obsChanged(foundStuff.getFoundStn());				}				if (mHXsec != null) {					mHXsec.obsChanged(foundStuff.getFoundStn());				}				if (mLevelDisplay != null) {					mLevelDisplay.obsChanged(foundStuff.getFoundStn());				}				if (mCbarDisplay != null) {					mCbarDisplay.obsChanged(foundStuff.getFoundStn());				}				// pPos = mFileViewer.getPropertyPos("PRES", false);				// if (mInterpolation.getSurfParamNum() == pPos) {				// this panel wants to ignore the event and set it's browser spot				// explicitly				setRecordLocal(foundStuff.getFoundStn());				// mIgnore = true;				// }			}			// else {			// Toolkit.getDefaultToolkit().beep();			// }		}		private class FoundBundle {			private OpenDataFile mFoundFile = null;			private Section mFoundSection = null;			private Station mFoundStn = null;			private Bottle mFoundBottle = null;			public FoundBundle() {			}			public FoundBundle(OpenDataFile foundFile, Section foundSection, Station foundStn, Bottle foundBottle) {				mFoundFile = foundFile;				mFoundSection = foundSection;				mFoundStn = foundStn;				mFoundBottle = foundBottle;			}			public void setFoundFile(OpenDataFile mFoundFile) {				this.mFoundFile = mFoundFile;			}			public OpenDataFile getFoundFile() {				return mFoundFile;			}			public void setFoundSection(Section mFoundSection) {				this.mFoundSection = mFoundSection;			}			public Section getFoundSection() {				return mFoundSection;			}			public void setFoundStn(Station mFoundStn) {				this.mFoundStn = mFoundStn;			}			public Station getFoundStn() {				return mFoundStn;			}			public void setFoundBottle(Bottle mFoundBottle) {				this.mFoundBottle = mFoundBottle;			}			public Bottle getFoundBottle() {				return mFoundBottle;			}		}		public FoundBundle findStnByX(int x, double matchingSurfaceVal) {			boolean found = false;			double minOffset = 10000000.0;			FoundBundle foundStuff = new FoundBundle();			for (int fc = 0; fc < mFileViewer.mNumOpenFiles && !found; fc++) {				OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.elementAt(fc);				for (int sec = 0; sec < of.mNumSections && !found; sec++) {					Section sech = (Section)of.mSections.elementAt(sec);					if (sech.mNumCasts == 0) {						continue;					}					int sPos = sech.getVarPos(mFileViewer.mAllProperties[surfVarNum].getVarLabel(), false);					for (int stc = 0; stc < sech.mStations.size() && !found; stc++) {						Station sh = (Station)sech.mStations.elementAt(stc);						if (!sh.mUseStn) {							continue;						}						if (!mStationRegion.isStnInRegion(sh)) {							continue;						}						double xOfObs = 0;						if (mOffset == JOAConstants.OFFSET_SEQUENCE) {							xOfObs = pLeftMargin + (sh.mOrdinal * mStationRegion.getXScale());						}						else if (mOffset == JOAConstants.OFFSET_DISTANCE) {							xOfObs = pLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset()));						}						else if (mOffset == JOAConstants.OFFSET_LATITUDE) {							if (!mNtoSSection) {								xOfObs = pLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());							}							else {								xOfObs = pLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());							}						}						else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {							// lon must increase to the right							double lon = sh.mLon;							if (mStationRegion.getLeftLon() < 0) {								if (lon < 0 && lon < mStationRegion.getLeftLon()) {									lon += 360.0;								}							}							else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {								lon += 360.0;							}							// if (mFileViewer.mStnFilterActive) {							// if (mFileViewer.mFilteredDataCross180) {							// if (lon < 0) {							// lon += 360.0;							// }							// }							// }							// else {							// if (mFileViewer.mUnFilteredDataCross180) {							// if (lon < 0) {							// lon += 360.0;							// }							// }							// }							xOfObs = pLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale());						}						else if (mOffset == JOAConstants.OFFSET_TIME) {							xOfObs = (int)(pLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion							    .getMinTime())));						}						double diff = Math.abs(x - xOfObs);						if (diff < minOffset) {							foundStuff.setFoundStn(sh);							foundStuff.setFoundSection(sech);							foundStuff.setFoundFile(of);							minOffset = diff;							// look for a matching bottle at this station							// find the value of the surface variable closest to the							// matchingSurfaceVal							if (matchingSurfaceVal >= 0) {								double surfOffset = 100000;								for (int b = 0; b < sh.mNumBottles; b++) {									Bottle bh = (Bottle)sh.mBottles.elementAt(b);									double bval = bh.mDValues[sPos];									double diff2 = Math.abs(bval - matchingSurfaceVal);									if (diff2 < surfOffset) {										foundStuff.setFoundBottle(bh);										surfOffset = diff2;									}								}							}						}					}				}			}			return foundStuff;		}		public boolean findByArrowKey(Integer direction) {			if (mWindowIsLocked) { return false; }			OpenDataFile foundFile = null;			Section foundSection = null;			Station foundStation = null;			Bottle foundBottle = null;			int pPos = mFileViewer.getPRESPropertyPos();			OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.currElement();			Section sech = (Section)of.mSections.currElement();			Station sh = (Station)sech.mStations.currElement();			Bottle bh = (Bottle)sh.mBottles.currElement();			// TODO define nz here by interpolation type			// set the test pressure			if (mInterpolation.getSurfParamNum() == pPos) {				JOAConstants.currTestPres = surfaceValues[mCurrLevel];			}			else {				JOAConstants.currTestPres = bh.mDValues[pPos];			}			// find new observation			boolean found = false;			switch (direction.intValue()) {				case 1: // JOAConstants.NEXTSTN:					// go to next station					foundStation = (Station)sech.mStations.nextElement();					if (foundStation == null) {						// go to next section						foundSection = (Section)of.mSections.nextElement();						foundFile = of;						if (foundSection != null) {							foundSection.mStations.setCurrElementToFirst();							foundStation = (Station)foundSection.mStations.currElement();							foundBottle = JOAFormulas.findBottleByPres(mFileViewer, foundStation);							if (foundBottle != null) {								found = true;							}						}						else {							// look in next file							foundFile = (OpenDataFile)mFileViewer.mOpenFiles.nextElement();							if (foundFile != null) {								foundSection = (Section)foundFile.mSections.currElement();								foundStation = (Station)foundSection.mStations.currElement();								foundBottle = JOAFormulas.findBottleByPres(mFileViewer, foundStation);								if (foundBottle != null) {									found = true;								}							}						}					}					else {						foundSection = sech;						foundFile = of;						// search for bottle by pressure						foundBottle = JOAFormulas.findBottleByPres(mFileViewer, foundStation);						if (foundBottle != null) {							found = true;						}					}					break;				case 2: // JOAConstants.PREVSTN:					// go to prev station					foundStation = (Station)sech.mStations.prevElement();					if (foundStation == null) {						// go to next section						foundSection = (Section)of.mSections.prevElement();						foundFile = of;						if (foundSection != null) {							foundSection.mStations.setCurrElementToLast();							foundStation = (Station)foundSection.mStations.currElement();							foundBottle = JOAFormulas.findBottleByPres(mFileViewer, foundStation);							if (foundBottle != null) {								found = true;							}						}						else {							// look in next file							foundFile = (OpenDataFile)mFileViewer.mOpenFiles.prevElement();							if (foundFile != null) {								foundSection = (Section)foundFile.mSections.currElement();								foundStation = (Station)foundSection.mStations.currElement();								foundBottle = JOAFormulas.findBottleByPres(mFileViewer, foundStation);								if (foundBottle != null) {									found = true;								}							}						}					}					else {						foundSection = sech;						foundFile = of;						// search for bottle by pressure						foundBottle = JOAFormulas.findBottleByPres(mFileViewer, foundStation);						if (foundBottle != null) {							found = true;						}					}					break;				case 3: // JOAConstants.NEXTOBS:					// go to next bottle					if (mCurrLevel + 1 < nz) {						mCurrLevel++;						if (mInterpolation.getSurfParamNum() == pPos) {							JOAConstants.currTestPres = surfaceValues[mCurrLevel];							foundBottle = JOAFormulas.findBottleByPres(mFileViewer, sh);						}						else {							foundBottle = (Bottle)sh.mBottles.nextElement();						}						if (foundBottle != null) {							foundStation = sh;							foundSection = sech;							foundFile = of;							found = true;						}					}					else {						found = false;					}					break;				case 4: // JOAConstants.PREVOBS:					// go to previous bottle					// refactor currlevel to the interpolation					// add getter and setter of level to the					if (mCurrLevel - 1 >= 0) {						mCurrLevel--;						if (mInterpolation.getSurfParamNum() == pPos) {							// surfacae vakue should be gotten from the							JOAConstants.currTestPres = surfaceValues[mCurrLevel];							foundBottle = JOAFormulas.findBottleByPres(mFileViewer, sh);						}						else {							foundBottle = (Bottle)sh.mBottles.prevElement();						}						if (foundBottle != null) {							foundStation = sh;							foundSection = sech;							foundFile = of;							found = true;						}					}					else {						found = false;					}					break;			}			// post event so other components will update			if (found) {				// update any other local browsing panels				if (mVXsec != null) {					mVXsec.obsChanged(foundStation);				}				if (mHXsec != null) {					mHXsec.obsChanged(foundStation);				}				if (mLevelDisplay != null) {					mLevelDisplay.obsChanged(foundStation);				}				if (mCbarDisplay != null) {					mCbarDisplay.obsChanged(foundStation);				}				// other listeners still want a reference to a bottle				mFileViewer.mOpenFiles.setCurrElement(foundFile);				foundFile.mSections.setCurrElement(foundSection);				foundSection.mStations.setCurrElement(foundStation);				foundStation.mBottles.setCurrElement(foundBottle);				ObsChangedEvent oce = new ObsChangedEvent(mFileViewer);				oce.setFoundObs(foundFile, foundSection, foundStation, foundBottle, this);				oce.setSendToMyself(false);				Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(oce);				// if (mInterpolation.getSurfParamNum() == pPos) {				// this panel wants to ignore the event and set it's browser spot				// explicitly				setRecordLocal(foundStation);				// mIgnore = true;				// }				return true;			}			else {				Toolkit.getDefaultToolkit().beep();				return false;			}		}		public void dialogDismissed(JDialog d) {			mPlotSpec = ((ConfigContourPlotDC)d).createPlotSpec();			try {				mPlotSpec.writeToLog("Edited existing plot: " + mParent.getTitle());			}			catch (Exception ex) {			}			boolean cbChanged = ((ConfigContourPlotDC)d).isColorBarChanged();			mInterpolation = mPlotSpec.getInterp();			mColorBar = mPlotSpec.getColorBar();			mWidth = mPlotSpec.getWidth();			mHeight = mPlotSpec.getHeight();			mWinTitle = mPlotSpec.getWinTitle();			mPlotMin = mPlotSpec.getWinYPlotMin();			mPlotMax = mPlotSpec.getWinYPlotMax();			mStyle = mPlotSpec.getStyle();			mOffset = mPlotSpec.getOffset();			mMarkers = mPlotSpec.getMarkers();			mMarkerSize = mPlotSpec.getMarkerSize();			mOverlayInterpolation = mPlotSpec.getOverlayInterp();			mOverlayColorBar = mPlotSpec.getOverlayColorBar();			mOverlayMarkers = mPlotSpec.getOverlayMarkers();			mOverlayMarkerSize = mPlotSpec.getOverlayMarkerSize();			mOverlayContours = mPlotSpec.isOverlayContours();			mLegend = mPlotSpec.isIncludeCBAR();			// mIncludeObsPanel = mPlotSpec.mIncludeObsPanel;			mAxes = mPlotSpec.isPlotAxes();			mCrossSections = mPlotSpec.isBrowsingEnabled();			mPlotEveryNthContour = mPlotSpec.getPlotEveryNthContour();			mLabelEveryNthContour = mPlotSpec.getLabelEveryNthContour();			if (mVXsec != null) {				mVXsec.scaleAxes();				mVXsec.computeLevelVals();				mVXsec.obsMarker = null;				mVXsec.obsMarker2 = null;			}			if (mHXsec != null) {				mHXsec.obsMarker = null;				mHXsec.obsMarker2 = null;			}			// handle changes in window layout			if (((ConfigContourPlotDC)d).removingColorLegend() && ((ConfigContourPlotDC)d).removingBrowsing()) {				// System.out.println("removing legend and removing xsec");				mEastContainer.remove(mCbarDisplay);				mEastContainer.remove(mVXsec);				mSouthContainer.remove(mHXsec);				mSouthContainer.remove(mLevelDisplay);				mContents.remove(mEastContainer);				mContents.remove(mSouthContainer);				mEastContainer = null;				mSouthContainer = null;				mVXsec = null;				mHXsec = null;				mLevelDisplay = null;				mCbarDisplay = null;				mContPlot.setSize(mContPlot.getSize().width + 200, mContPlot.getSize().height + 100);			}			else if (((ConfigContourPlotDC)d).addingColorLegend() && ((ConfigContourPlotDC)d).addingBrowsing()) {				// System.out.println("adding legend and adding xsec");				mEastContainer = new JPanel();				mEastContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);				mEastContainer.setLayout(new BorderLayout(0, 0));				mVXsec = new VerticalXSecPanel(150, mHeight);				mEastContainer.add(mVXsec, "West");				mCbarDisplay = new ColorBarDisplay(120, mHeight);				mEastContainer.add(mCbarDisplay, "East");				mContents.add(mEastContainer, "East");				mHXsec = new HorizontalXSecPanel(mWidth - 80, 110);				mLevelDisplay = new LevelDataPanel(250, 80);				mSouthContainer = new JPanel();				mSouthContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);				mSouthContainer.setLayout(new BorderLayout(0, 0));				mSouthContainer.add(mHXsec, "Center");				mSouthContainer.add(mLevelDisplay, "East");				mContents.add(mSouthContainer, "South");				mContPlot.setSize(mContPlot.getSize().width - 200, mContPlot.getSize().height - 100);			}			else if (!mCrossSections && ((ConfigContourPlotDC)d).addingColorLegend()) {				// System.out.println("adding legend with no xsecs");				mCbarDisplay = new ColorBarDisplay(120, mHeight);				mContents.add(mCbarDisplay, "East");				mContPlot.setSize(mContPlot.getSize().width - 100, mContPlot.getSize().height);			}			else if (mCrossSections && ((ConfigContourPlotDC)d).removingColorLegend()) {				// System.out.println("removing legend with xsecs");				if (mEastContainer != null) {					mEastContainer.remove(mCbarDisplay);					mCbarDisplay = null;					mContPlot.setSize(mContPlot.getSize().width + 100, mContPlot.getSize().height);				}			}			else if (!mCrossSections && ((ConfigContourPlotDC)d).removingColorLegend()) {				// System.out.println("removing legend with no xsecs");				mContents.remove(mCbarDisplay);				mCbarDisplay = null;				mContPlot.setSize(mContPlot.getSize().width - 100, mContPlot.getSize().height);			}			else if (mCrossSections && ((ConfigContourPlotDC)d).addingColorLegend()) {				// System.out.println("adding legend with xsecs");				mCbarDisplay = new ColorBarDisplay(120, mHeight);				mEastContainer.add(mCbarDisplay, "East");				mContPlot.setSize(mContPlot.getSize().width - 100, mContPlot.getSize().height);			}			else if (mLegend && ((ConfigContourPlotDC)d).addingBrowsing()) {				// System.out.println("adding Xsez with legend");				// first remove color legend from original location				mContents.remove(mCbarDisplay);				mCbarDisplay = null;				// add browsing and then re-add color bar				mEastContainer = new JPanel();				mEastContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);				mEastContainer.setLayout(new BorderLayout(0, 0));				mVXsec = new VerticalXSecPanel(150, mHeight);				mEastContainer.add(mVXsec, "West");				mCbarDisplay = new ColorBarDisplay(120, mHeight);				mEastContainer.add(mCbarDisplay, "East");				mContents.add(mEastContainer, "East");				mHXsec = new HorizontalXSecPanel(mWidth - 80, 110);				mLevelDisplay = new LevelDataPanel(250, 80);				mSouthContainer = new JPanel();				mSouthContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);				mSouthContainer.setLayout(new BorderLayout(0, 0));				mSouthContainer.add(mHXsec, "Center");				mSouthContainer.add(mLevelDisplay, "East");				mContents.add(mSouthContainer, "South");				mContPlot.setSize(mContPlot.getSize().width - 100, mContPlot.getSize().height - 100);			}			else if (mLegend && ((ConfigContourPlotDC)d).removingBrowsing()) {				// System.out.println("removing Xsec with legend");				// first remove color legend from original location				mEastContainer.remove(mCbarDisplay);				mEastContainer.remove(mVXsec);				mSouthContainer.remove(mHXsec);				mSouthContainer.remove(mLevelDisplay);				mContents.remove(mEastContainer);				mContents.remove(mSouthContainer);				mVXsec = null;				mLevelDisplay = null;				mHXsec = null;				mCbarDisplay = null;				// re-add color legend				mCbarDisplay = new ColorBarDisplay(120, mHeight);				mContents.add(mCbarDisplay, "East");				mContPlot.setSize(mContPlot.getSize().width + 120, mContPlot.getSize().height + 100);			}			else if (!mLegend && ((ConfigContourPlotDC)d).removingBrowsing()) {				// System.out.println("removing Xsec with no legend");				if (mEastContainer != null) {					mEastContainer.remove(mVXsec);					mContents.remove(mEastContainer);					mEastContainer = null;				}				else {					mContents.remove(mVXsec);				}				mSouthContainer.remove(mHXsec);				mSouthContainer.remove(mLevelDisplay);				mContents.remove(mSouthContainer);				mVXsec = null;				mLevelDisplay = null;				mHXsec = null;				mContPlot.setSize(mContPlot.getSize().width + 100, mContPlot.getSize().height + 100);			}			else if (!mLegend && ((ConfigContourPlotDC)d).addingBrowsing()) {				// System.out.println("adding Xsec with no legend");				mEastContainer = new JPanel();				mEastContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);				mEastContainer.setLayout(new BorderLayout(0, 0));				mVXsec = new VerticalXSecPanel(150, mHeight);				mEastContainer.add(mVXsec, "West");				mContents.add(mEastContainer, "East");				mHXsec = new HorizontalXSecPanel(mWidth - 80, 110);				mLevelDisplay = new LevelDataPanel(250, 80);				mSouthContainer = new JPanel();				mSouthContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);				mSouthContainer.setLayout(new BorderLayout(0, 0));				mSouthContainer.add(mHXsec, "Center");				mSouthContainer.add(mLevelDisplay, "East");				mContents.add(mSouthContainer, "South");				mContPlot.setSize(mContPlot.getSize().width - 100, mContPlot.getSize().height - 100);			}			else if (cbChanged) {				if (mEastContainer != null) {					mEastContainer.remove(mCbarDisplay);					mCbarDisplay = null;					mCbarDisplay = new ColorBarDisplay(120, mHeight);					mEastContainer.add(mCbarDisplay, "East");				}				else {					mContents.remove(mCbarDisplay);					mCbarDisplay = null;					mCbarDisplay = new ColorBarDisplay(120, mHeight);					mContents.add(mCbarDisplay, "East");				}				mContents.invalidate();				mContents.validate();			}			// mOffScreen = null;			// mObsMarker = null;			mFrame.setSize(mFrame.getSize().width + 1, mFrame.getSize().height);			mFrame.setSize(mFrame.getSize().width - 1, mFrame.getSize().height);			mStationRegion.setPlotSpec(mPlotSpec);			mStationRegion.update(mContPlot);			mFrame.invalidate();			mFrame.validate();			invalidate();			paintComponent(this.getGraphics());		}		// Cancel button		public void dialogCancelled(JDialog d) {			// restore the original specification			ContourPlotSpecification newPlotSpec = ((ConfigContourPlotDC)d).createPlotSpec();			mPlotSpec = ((ConfigContourPlotDC)d).getOrigPlotSpec();			// restore any NewColorBar changes			((ConfigContourPlotDC)d).restoreOriginalColorBar(mPlotSpec);			// restore other fields			mInterpolation = mPlotSpec.getInterp();			mColorBar = mPlotSpec.getColorBar();			mWidth = mPlotSpec.getWidth();			mHeight = mPlotSpec.getHeight();			mWinTitle = mPlotSpec.getWinTitle();			mPlotMin = mPlotSpec.getWinYPlotMin();			mPlotMax = mPlotSpec.getWinYPlotMax();			mStyle = mPlotSpec.getStyle();			mOffset = mPlotSpec.getOffset();			mMarkers = mPlotSpec.getMarkers();			mMarkerSize = mPlotSpec.getMarkerSize();			mLegend = mPlotSpec.isIncludeCBAR();			// mIncludeObsPanel = mPlotSpec.mIncludeObsPanel;			mAxes = mPlotSpec.isPlotAxes();			mCrossSections = mPlotSpec.isBrowsingEnabled();			mPlotEveryNthContour = mPlotSpec.getPlotEveryNthContour();			mLabelEveryNthContour = mPlotSpec.getLabelEveryNthContour();			mOverlayInterpolation = mPlotSpec.getOverlayInterp();			mOverlayColorBar = mPlotSpec.getOverlayColorBar();			mOverlayMarkers = mPlotSpec.getOverlayMarkers();			mOverlayMarkerSize = mPlotSpec.getOverlayMarkerSize();			mOverlayContours = mPlotSpec.isOverlayContours();			if (mVXsec != null) {				mVXsec.scaleAxes();				mVXsec.computeLevelVals();				mVXsec.obsMarker = null;				mVXsec.obsMarker2 = null;			}			if (mHXsec != null) {				mHXsec.obsMarker = null;				mHXsec.obsMarker2 = null;			}			if (((ConfigContourPlotDC)d).isLayoutChanged()) {				// restore window layout				if (!mPlotSpec.isBrowsingEnabled() && newPlotSpec.isBrowsingEnabled() && !mPlotSpec.isIncludeCBAR()				    && newPlotSpec.isIncludeCBAR()) {					// System.out.println("remove both a new legend and a new xsec");					mEastContainer.remove(mCbarDisplay);					mEastContainer.remove(mVXsec);					mSouthContainer.remove(mHXsec);					mSouthContainer.remove(mLevelDisplay);					mContents.remove(mEastContainer);					mContents.remove(mSouthContainer);					mEastContainer = null;					mSouthContainer = null;					mVXsec = null;					mHXsec = null;					mLevelDisplay = null;					mCbarDisplay = null;					mContPlot.setSize(mContPlot.getSize().width + 200, mContPlot.getSize().height + 100);					mFrame.setSize(mFrame.getSize().width + 1, mFrame.getSize().height);					mFrame.setSize(mFrame.getSize().width - 1, mFrame.getSize().height);				}				else if (!mPlotSpec.isBrowsingEnabled() && newPlotSpec.isBrowsingEnabled() && mPlotSpec.isIncludeCBAR()				    && newPlotSpec.isIncludeCBAR()) {					// System.out.println("remove new xsecs");					mEastContainer.remove(mVXsec);					mSouthContainer.remove(mHXsec);					mSouthContainer.remove(mLevelDisplay);					mContents.remove(mSouthContainer);					mSouthContainer = null;					mVXsec = null;					mHXsec = null;					mLevelDisplay = null;					mContPlot.setSize(mContPlot.getSize().width + 200, mContPlot.getSize().height + 100);					mFrame.setSize(mFrame.getSize().width + 1, mFrame.getSize().height);					mFrame.setSize(mFrame.getSize().width - 1, mFrame.getSize().height);				}				else if (mPlotSpec.isBrowsingEnabled() && !newPlotSpec.isBrowsingEnabled() && mPlotSpec.isIncludeCBAR()				    && !newPlotSpec.isIncludeCBAR()) {					// System.out.println("put back legend and xsec that have been					// removed");					mEastContainer = new JPanel();					mEastContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);					mEastContainer.setLayout(new BorderLayout(0, 0));					mVXsec = new VerticalXSecPanel(150, mHeight);					mEastContainer.add(mVXsec, "West");					mCbarDisplay = new ColorBarDisplay(120, mHeight);					mEastContainer.add(mCbarDisplay, "East");					mContents.add(mEastContainer, "East");					mHXsec = new HorizontalXSecPanel(mWidth - 80, 110);					mLevelDisplay = new LevelDataPanel(250, 80);					mSouthContainer = new JPanel();					mSouthContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);					mSouthContainer.setLayout(new BorderLayout(0, 0));					mSouthContainer.add(mHXsec, "Center");					mSouthContainer.add(mLevelDisplay, "East");					mContents.add(mSouthContainer, "South");					mContPlot.setSize(mContPlot.getSize().width - 200, mContPlot.getSize().height - 100);					mFrame.setSize(mFrame.getSize().width + 1, mFrame.getSize().height);					mFrame.setSize(mFrame.getSize().width - 1, mFrame.getSize().height);				}				else if (!mPlotSpec.isBrowsingEnabled() && !newPlotSpec.isBrowsingEnabled() && mPlotSpec.isIncludeCBAR()				    && !newPlotSpec.isIncludeCBAR()) {					// System.out.println("put back legend");					mEastContainer = new JPanel();					mEastContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);					mEastContainer.setLayout(new BorderLayout(0, 0));					mCbarDisplay = new ColorBarDisplay(120, mHeight);					mEastContainer.add(mCbarDisplay, "East");					mContents.add(mEastContainer, "East");					mContPlot.setSize(mContPlot.getSize().width - 200, mContPlot.getSize().height - 100);					mFrame.setSize(mFrame.getSize().width + 1, mFrame.getSize().height);					mFrame.setSize(mFrame.getSize().width - 1, mFrame.getSize().height);				}				else if (!mPlotSpec.isBrowsingEnabled() && !newPlotSpec.isBrowsingEnabled() && newPlotSpec.isIncludeCBAR()) {					// System.out.println("remove a new legend with no xsecs");					mCbarDisplay = new ColorBarDisplay(120, mHeight);					mContents.add(mCbarDisplay, "East");					mContPlot.setSize(mContPlot.getSize().width - 100, mContPlot.getSize().height);					mFrame.setSize(mFrame.getSize().width + 1, mFrame.getSize().height);					mFrame.setSize(mFrame.getSize().width - 1, mFrame.getSize().height);				}				else if (mPlotSpec.isBrowsingEnabled() && newPlotSpec.isBrowsingEnabled() && newPlotSpec.isIncludeCBAR()) {					// System.out.println("remove a new legend with xsecs");					mEastContainer.remove(mCbarDisplay);					mCbarDisplay = null;					mContPlot.setSize(mContPlot.getSize().width + 100, mContPlot.getSize().height);					mFrame.setSize(mFrame.getSize().width + 1, mFrame.getSize().height);					mFrame.setSize(mFrame.getSize().width - 1, mFrame.getSize().height);				}				/*				 * else if (mCrossSections &&				 * ((ConfigContourPlotDC)d).addingColorLegend()) {				 * //System.out.println("adding legend with xsecs"); mCbarDisplay = new				 * ColorBarDisplay(mColorBar, 100, mHeight);				 * mEastContainer.add(mCbarDisplay, "East");				 * mContPlot.setSize(mContPlot.getSize().width-100,				 * mContPlot.getSize().height); mFrame.setSize(mFrame.getSize().width+1,				 * mFrame.getSize().height); mFrame.setSize(mFrame.getSize().width-1,				 * mFrame.getSize().height);				 * ((ConfigContourPlotDC)d).addedColorLegend(); } else if (mLegend &&				 * ((ConfigContourPlotDC)d).addingBrowsing()) {				 * //System.out.println("adding Xsez with legend"); // first remove				 * color legend from original location mContents.remove(mCbarDisplay);				 * mCbarDisplay = null; // add browsing and then re-add color bar				 * mEastContainer = new JPanel();				 * mEastContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);				 * mEastContainer.setLayout(new BorderLayout(0, 0)); mVXsec = new				 * VerticalXSecPanel(150, mHeight); mEastContainer.add(mVXsec, "West");				 * mCbarDisplay = new ColorBarDisplay(mColorBar, 100, mHeight);				 * mEastContainer.add(mCbarDisplay, "East");				 * mContents.add(mEastContainer, "East"); mHXsec = new				 * HorizontalXSecPanel(mWidth - 100, 110); mLevelDisplay = new				 * LevelDataPanel(250, 80); mSouthContainer = new JPanel();				 * mSouthContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);				 * mSouthContainer.setLayout(new BorderLayout(0, 0));				 * mSouthContainer.add(mHXsec, "Center");				 * mSouthContainer.add(mLevelDisplay, "East");				 * mContents.add(mSouthContainer, "South");				 * 				 * mContPlot.setSize(mContPlot.getSize().width-100,				 * mContPlot.getSize().height-100);				 * mFrame.setSize(mFrame.getSize().width+1, mFrame.getSize().height);				 * mFrame.setSize(mFrame.getSize().width-1, mFrame.getSize().height);				 * ((ConfigContourPlotDC)d).addedBrowsing(); } else if (mLegend &&				 * ((ConfigContourPlotDC)d).removingBrowsing()) {				 * //System.out.println("removing Xsec with legend"); // first remove				 * color legend from original location				 * mEastContainer.remove(mCbarDisplay);				 * 				 * mEastContainer.remove(mVXsec); mSouthContainer.remove(mHXsec);				 * mSouthContainer.remove(mLevelDisplay);				 * mContents.remove(mEastContainer); mContents.remove(mSouthContainer);				 * mVXsec = null; mLevelDisplay = null; mHXsec = null; mCbarDisplay =				 * null; // re-add color legend mCbarDisplay = new				 * ColorBarDisplay(mColorBar, 100, mHeight); mContents.add(mCbarDisplay,				 * "East");				 * 				 * mContPlot.setSize(mContPlot.getSize().width+100,				 * mContPlot.getSize().height+100);				 * mFrame.setSize(mFrame.getSize().width+1, mFrame.getSize().height);				 * mFrame.setSize(mFrame.getSize().width-1, mFrame.getSize().height);				 * ((ConfigContourPlotDC)d).removedBrowsing(); } else if (!mLegend &&				 * ((ConfigContourPlotDC)d).removingBrowsing()) {				 * //System.out.println("removing Xsec with no legend");				 * mContents.remove(mVXsec); mSouthContainer.remove(mHXsec);				 * mSouthContainer.remove(mLevelDisplay);				 * mContents.remove(mSouthContainer); mVXsec = null; mLevelDisplay =				 * null; mHXsec = null;				 * 				 * mContPlot.setSize(mContPlot.getSize().width+100,				 * mContPlot.getSize().height+100);				 * mFrame.setSize(mFrame.getSize().width+1, mFrame.getSize().height);				 * mFrame.setSize(mFrame.getSize().width-1, mFrame.getSize().height);				 * ((ConfigContourPlotDC)d).removedBrowsing(); } else if (!mLegend &&				 * ((ConfigContourPlotDC)d).addingBrowsing()) {				 * //System.out.println("adding Xsec with no legend"); mEastContainer =				 * new JPanel();				 * mEastContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);				 * mEastContainer.setLayout(new BorderLayout(0, 0)); mVXsec = new				 * VerticalXSecPanel(150, mHeight); mEastContainer.add(mVXsec, "West");				 * mContents.add(mEastContainer, "East"); mHXsec = new				 * HorizontalXSecPanel(mWidth - 100, 110); mLevelDisplay = new				 * LevelDataPanel(250, 80); mSouthContainer = new JPanel();				 * mSouthContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);				 * mSouthContainer.setLayout(new BorderLayout(0, 0));				 * mSouthContainer.add(mHXsec, "Center");				 * mSouthContainer.add(mLevelDisplay, "East");				 * mContents.add(mSouthContainer, "South");				 * mContPlot.setSize(mContPlot.getSize().width-100,				 * mContPlot.getSize().height-100);				 * mFrame.setSize(mFrame.getSize().width+1, mFrame.getSize().height);				 * mFrame.setSize(mFrame.getSize().width-1, mFrame.getSize().height);				 * ((ConfigContourPlotDC)d).addedBrowsing(); } else {				 * ;//System.out.println("in else"); }				 */			}			// mOffScreen = null;			// mObsMarker = null;			invalidate();			paintComponent(this.getGraphics());		}		// something other than the OK button		public void dialogDismissedTwo(JDialog d) {			;		}		public void dialogApplyTwo(Object d) {		}		// Apply button, OK w/o dismissing the dialog		public void dialogApply(JDialog d) {			mPlotSpec = ((ConfigContourPlotDC)d).createPlotSpec();			try {				mPlotSpec.writeToLog("Edited existing plot: " + mParent.getTitle());			}			catch (Exception ex) {			}			boolean cbChanged = ((ConfigContourPlotDC)d).isColorBarChanged();			mInterpolation = mPlotSpec.getInterp();			mColorBar = mPlotSpec.getColorBar();			mWidth = mPlotSpec.getWidth();			mHeight = mPlotSpec.getHeight();			mWinTitle = mPlotSpec.getWinTitle();			mPlotMin = mPlotSpec.getWinYPlotMin();			mPlotMax = mPlotSpec.getWinYPlotMax();			mStyle = mPlotSpec.getStyle();			mOffset = mPlotSpec.getOffset();			mMarkers = mPlotSpec.getMarkers();			mMarkerSize = mPlotSpec.getMarkerSize();			mLegend = mPlotSpec.isIncludeCBAR();			// mIncludeObsPanel = mPlotSpec.mIncludeObsPanel;			mAxes = mPlotSpec.isPlotAxes();			mCrossSections = mPlotSpec.isBrowsingEnabled();			mPlotEveryNthContour = mPlotSpec.getPlotEveryNthContour();			mLabelEveryNthContour = mPlotSpec.getLabelEveryNthContour();			mPlotEveryNthOvlContour = mPlotSpec.getPlotEveryNthOvlContour();			mOverlayInterpolation = mPlotSpec.getOverlayInterp();			mOverlayColorBar = mPlotSpec.getOverlayColorBar();			mOverlayMarkers = mPlotSpec.getOverlayMarkers();			mOverlayMarkerSize = mPlotSpec.getOverlayMarkerSize();			mOverlayContours = mPlotSpec.isOverlayContours();			if (mVXsec != null) {				mVXsec.scaleAxes();				mVXsec.computeLevelVals();				mVXsec.obsMarker = null;				mVXsec.obsMarker2 = null;			}			if (mHXsec != null) {				mHXsec.obsMarker = null;				mHXsec.obsMarker2 = null;			}			// handle changes in window layout			if (((ConfigContourPlotDC)d).removingColorLegend() && ((ConfigContourPlotDC)d).removingBrowsing()) {				// System.out.println("removing legend and removing xsec");				mEastContainer.remove(mCbarDisplay);				mEastContainer.remove(mVXsec);				mSouthContainer.remove(mHXsec);				mSouthContainer.remove(mLevelDisplay);				mContents.remove(mEastContainer);				mContents.remove(mSouthContainer);				mEastContainer = null;				mSouthContainer = null;				mVXsec = null;				mHXsec = null;				mLevelDisplay = null;				mCbarDisplay = null;				mContPlot.setSize(mContPlot.getSize().width + 200, mContPlot.getSize().height + 100);				((ConfigContourPlotDC)d).removedColorLegend();				((ConfigContourPlotDC)d).removedBrowsing();			}			else if (((ConfigContourPlotDC)d).addingColorLegend() && ((ConfigContourPlotDC)d).addingBrowsing()) {				// System.out.println("adding legend and adding xsec");				mEastContainer = new JPanel();				mEastContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);				mEastContainer.setLayout(new BorderLayout(0, 0));				mVXsec = new VerticalXSecPanel(150, mHeight);				mEastContainer.add(mVXsec, "West");				mCbarDisplay = new ColorBarDisplay(120, mHeight);				mEastContainer.add(mCbarDisplay, "East");				mContents.add(mEastContainer, "East");				mHXsec = new HorizontalXSecPanel(mWidth - 80, 110);				mLevelDisplay = new LevelDataPanel(250, 80);				mSouthContainer = new JPanel();				mSouthContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);				mSouthContainer.setLayout(new BorderLayout(0, 0));				mSouthContainer.add(mHXsec, "Center");				mSouthContainer.add(mLevelDisplay, "East");				mContents.add(mSouthContainer, "South");				mContPlot.setSize(mContPlot.getSize().width - 200, mContPlot.getSize().height - 100);				((ConfigContourPlotDC)d).addedColorLegend();				((ConfigContourPlotDC)d).addedBrowsing();			}			else if (!mCrossSections && ((ConfigContourPlotDC)d).addingColorLegend()) {				// System.out.println("adding legend with no xsecs");				mCbarDisplay = new ColorBarDisplay(120, mHeight);				mContents.add(mCbarDisplay, "East");				mContPlot.setSize(mContPlot.getSize().width - 100, mContPlot.getSize().height);				((ConfigContourPlotDC)d).addedColorLegend();			}			else if (mCrossSections && ((ConfigContourPlotDC)d).removingColorLegend()) {				// System.out.println("removing legend with xsecs");				mEastContainer.remove(mCbarDisplay);				mCbarDisplay = null;				mContPlot.setSize(mContPlot.getSize().width + 100, mContPlot.getSize().height);				((ConfigContourPlotDC)d).removedColorLegend();			}			else if (!mCrossSections && ((ConfigContourPlotDC)d).removingColorLegend()) {				// System.out.println("removing legend with no xsecs");				mContents.remove(mCbarDisplay);				mCbarDisplay = null;				mContPlot.setSize(mContPlot.getSize().width - 100, mContPlot.getSize().height);				((ConfigContourPlotDC)d).removedColorLegend();			}			else if (mCrossSections && ((ConfigContourPlotDC)d).addingColorLegend()) {				// System.out.println("adding legend with xsecs");				mCbarDisplay = new ColorBarDisplay(100, mHeight);				mEastContainer.add(mCbarDisplay, "120");				mContPlot.setSize(mContPlot.getSize().width - 100, mContPlot.getSize().height);				((ConfigContourPlotDC)d).addedColorLegend();			}			else if (mLegend && ((ConfigContourPlotDC)d).addingBrowsing()) {				// System.out.println("adding Xsez with legend");				// first remove color legend from original location				mContents.remove(mCbarDisplay);				mCbarDisplay = null;				// add browsing and then re-add color bar				mEastContainer = new JPanel();				mEastContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);				mEastContainer.setLayout(new BorderLayout(0, 0));				mVXsec = new VerticalXSecPanel(150, mHeight);				mEastContainer.add(mVXsec, "West");				mCbarDisplay = new ColorBarDisplay(120, mHeight);				mEastContainer.add(mCbarDisplay, "East");				mContents.add(mEastContainer, "East");				mHXsec = new HorizontalXSecPanel(mWidth - 80, 110);				mLevelDisplay = new LevelDataPanel(250, 80);				mSouthContainer = new JPanel();				mSouthContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);				mSouthContainer.setLayout(new BorderLayout(0, 0));				mSouthContainer.add(mHXsec, "Center");				mSouthContainer.add(mLevelDisplay, "East");				mContents.add(mSouthContainer, "South");				mContPlot.setSize(mContPlot.getSize().width - 100, mContPlot.getSize().height - 100);				((ConfigContourPlotDC)d).addedBrowsing();			}			else if (mLegend && ((ConfigContourPlotDC)d).removingBrowsing()) {				// System.out.println("removing Xsec with legend");				// first remove color legend from original location				mEastContainer.remove(mCbarDisplay);				mEastContainer.remove(mVXsec);				mSouthContainer.remove(mHXsec);				mSouthContainer.remove(mLevelDisplay);				mContents.remove(mEastContainer);				mContents.remove(mSouthContainer);				mVXsec = null;				mLevelDisplay = null;				mHXsec = null;				mCbarDisplay = null;				// re-add color legend				mCbarDisplay = new ColorBarDisplay(120, mHeight);				mContents.add(mCbarDisplay, "East");				mContPlot.setSize(mContPlot.getSize().width + 100, mContPlot.getSize().height + 100);				((ConfigContourPlotDC)d).removedBrowsing();			}			else if (!mLegend && ((ConfigContourPlotDC)d).removingBrowsing()) {				// System.out.println("removing Xsec with no legend");				if (mEastContainer != null) {					mEastContainer.remove(mVXsec);					mContents.remove(mEastContainer);					mEastContainer = null;				}				else {					mContents.remove(mVXsec);				}				mSouthContainer.remove(mHXsec);				mSouthContainer.remove(mLevelDisplay);				mContents.remove(mSouthContainer);				mVXsec = null;				mLevelDisplay = null;				mHXsec = null;				mContPlot.setSize(mContPlot.getSize().width + 100, mContPlot.getSize().height + 100);				((ConfigContourPlotDC)d).removedBrowsing();			}			else if (!mLegend && ((ConfigContourPlotDC)d).addingBrowsing()) {				// System.out.println("adding Xsec with no legend");				mEastContainer = new JPanel();				mEastContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);				mEastContainer.setLayout(new BorderLayout(0, 0));				mVXsec = new VerticalXSecPanel(150, mHeight);				mEastContainer.add(mVXsec, "West");				mContents.add(mEastContainer, "East");				mHXsec = new HorizontalXSecPanel(mWidth - 80, 110);				mLevelDisplay = new LevelDataPanel(250, 80);				mSouthContainer = new JPanel();				mSouthContainer.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);				mSouthContainer.setLayout(new BorderLayout(0, 0));				mSouthContainer.add(mHXsec, "Center");				mSouthContainer.add(mLevelDisplay, "East");				mContents.add(mSouthContainer, "South");				mContPlot.setSize(mContPlot.getSize().width - 100, mContPlot.getSize().height - 100);				((ConfigContourPlotDC)d).addedBrowsing();			}			else if (cbChanged) {				if (mEastContainer != null) {					mEastContainer.remove(mCbarDisplay);					mCbarDisplay = null;					mCbarDisplay = new ColorBarDisplay(120, mHeight);					mEastContainer.add(mCbarDisplay, "East");				}				else {					mContents.remove(mCbarDisplay);					mCbarDisplay = null;					mCbarDisplay = new ColorBarDisplay(120, mHeight);					mContents.add(mCbarDisplay, "East");				}				mContents.invalidate();				mContents.validate();			}			// mOffScreen = null;			// mObsMarker = null;			// mObsMarker = null;			mFrame.setSize(mFrame.getSize().width + 1, mFrame.getSize().height);			mFrame.setSize(mFrame.getSize().width - 1, mFrame.getSize().height);			mStationRegion.setPlotSpec(mPlotSpec);			mStationRegion.update(mContPlot);			mFrame.invalidate();			mFrame.validate();			invalidate();			paintComponent(this.getGraphics());		}		public UVCoordinate getCorrectedXY(int x, int y) {			// boolean reverseY = mFileViewer.mAllProperties[mYVarCode].isReverseY();			double dy = (double)y;			double dx = (double)x;			/*			 * if (y < getMinY() || y > getMaxY() || x < getMinX() || x > getMaxX()) {			 * dy = Double.NaN; dx = Double.NaN; return new UVCoordinate(dx, dy); }			 * 			 * if (mPlotAxes) { dx -= PVPLEFT; }			 * 			 * if (mPlotAxes && !reverseY) { dy -= PVPTOP; } else if (mPlotAxes &&			 * reverseY) { dy = mHeightCurrWindow - y; } else if (reverseY) { dy =			 * mHeightCurrWindow - y; }			 */			return new UVCoordinate(dx, dy);		}		public double[] getInvTransformedX(double x) {			double[] xvals = new double[1];			xvals[0] = Double.NaN;			return xvals;		}		public double[] getInvTransformedY(double y) {			double[] yvals = new double[1];			yvals[0] = Double.NaN; // y/mWinYScale + mWinYOrigin;			return yvals;		}	}	private class VerticalXSecPanel extends JPanel implements DialogClient, ActionListener {		Image mOffScreen = null;		int maxY = 0;		double yScale = 0.0;		double xScale = 0.0;		double yOrigin = 0.0;		double xOrigin = 0.0;		double pixelsPerUnit = 0;		int vLeftMargin = 0;		int vBottomMargin = 0;		int vTopMargin = 25;		int vRightMargin = 0;		int panelWidth = 0;		int panelHeight = 0;		double mInterpMin = 0;		double mInterpMax = 0;		double mInterpInc = 1.0;		int minLevel = 0;		int maxLevel = 0;		Station oldStation = null;		ObsMarker obsMarker = null;		ObsMarker obsMarker2 = null;		DialogClient mDialogClient = null;		private JPopupMenu mPopupMenu = null;		double[][] interpOvlValues;		int maxOvlY = 0;		double yOvlScale = 0.0;		double xOvlScale = 0.0;		double yOvlOrigin = 0.0;		double xOvlOrigin = 0.0;		double mOvlInterpMin = 0;		double mOvlInterpMax = 0;		double mOvlInterpInc = 1.0;		ObsMarker obsOvlMarker = null;		ObsMarker obsOvlMarker2 = null;		JOAVariable interpOvlVar;		public VerticalXSecPanel(int inWidth, int inHeight) {			super(false);			this.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);			panelWidth = inWidth;			panelHeight = inHeight;			mDialogClient = this;			addMouseListener(new VXsecMouseHandler());			init();		}		public void createPopup(Point point) {			ResourceBundle b = ResourceBundle.getBundle("javaoceanatlas.resources.JOAResources");			mPopupMenu = new JPopupMenu();			JMenuItem openContextualMenu = new JMenuItem(b.getString("kProperties"));			openContextualMenu.setActionCommand("opencontextual");			openContextualMenu.addActionListener(this);			mPopupMenu.add(openContextualMenu);			mPopupMenu.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));			mPopupMenu.show(this, point.x, point.y);		}		public void showConfigDialog() {			// show configuration dialog			/*			 * double tempYMin =			 * mFileViewer.mAllProperties[mPlotSpec.getYVar().getVariablePos			 * ()].getPlotMin(); double tempYMax =			 * mFileViewer.mAllProperties[mPlotSpec			 * .getYVar().getVariablePos()].getPlotMax(); ConfigVXsec cp = new			 * ConfigVXsec(mFrame, mFileViewer, mDialogClient, mInterpMin, mInterpMax,			 * mInterpInc, tempYMin, tempYMax); cp.pack(); cp.setVisible(true);			 */			// show configuration dialog			double tempYMin = mFileViewer.mAllProperties[mPlotSpec.getYVar().getVariablePos()].getPlotMin();			double tempYMax = mFileViewer.mAllProperties[mPlotSpec.getYVar().getVariablePos()].getPlotMax();			ConfigVXsec cp = null;			if (mOverlayContours) {				double tempOvlYMin = mOverlayFileViewer.mAllProperties[mPlotSpec.getOvlYVar().getVariablePos()].getPlotMin();				double tempOvlYMax = mOverlayFileViewer.mAllProperties[mPlotSpec.getOvlYVar().getVariablePos()].getPlotMax();				cp = new ConfigVXsec(mFrame, mDialogClient, mInterpMin, mInterpMax, mInterpInc, tempYMin, tempYMax,				    mOvlInterpMin, mOvlInterpMax, mOvlInterpInc, tempOvlYMin, tempOvlYMax);			}			else {				cp = new ConfigVXsec(mFrame, mDialogClient, mInterpMin, mInterpMax, mInterpInc, tempYMin, tempYMax);			}			cp.pack();			cp.setVisible(true);		}		public void actionPerformed(ActionEvent e) {			String cmd = e.getActionCommand();			if (cmd.equals("opencontextual")) {				showConfigDialog();			}		}		public class VXsecMouseHandler extends MouseAdapter {			public void mouseClicked(MouseEvent me) {				if (mWindowIsLocked) { return; }				if (me.getClickCount() == 2) {					// show configuration dialog					showConfigDialog();				}			}			public void mouseReleased(MouseEvent me) {				if (mWindowIsLocked) { return; }				super.mouseReleased(me);				if (me.isPopupTrigger()) {					createPopup(me.getPoint());				}			}			public void mousePressed(MouseEvent me) {				if (mWindowIsLocked) { return; }				super.mousePressed(me);				if (me.isPopupTrigger()) {					createPopup(me.getPoint());				}			}		}		public void computeLevelVals() {			// compute the start and end levels			minLevel = 0;			maxLevel = nz;			for (int i = 0; i < nz - 1; i++) {				// get the value of the interp surface at i1				if (mPlotMin >= surfaceValues[i]) {					minLevel = i > 0 ? i - 1 : 0;				}				if (mPlotMax >= surfaceValues[i]) {					maxLevel = i > 0 ? i + 1 : 0;				}			}			if (maxLevel > nz) {				maxLevel = nz;			}		}		public void init() {			// compute the start and end levels			computeLevelVals();			// get the max min values of the interpolated variable			mInterpMin = mInterpolation.getMinValue();			mInterpMax = mInterpolation.getMaxValue();			// get a pretty range			Triplet prettyNums = JOAFormulas.GetPrettyRange(mInterpMin, mInterpMax);			mInterpMin = prettyNums.getVal1();			mInterpMax = prettyNums.getVal2();			mInterpInc = prettyNums.getVal3();			if (mAxes) {				vLeftMargin = 20;				vRightMargin = 20;				vBottomMargin = 50;				vTopMargin = 25;			}			scaleAxes();			if (mOverlayContours) {				interpOvlValues = mOverlayInterpolation.getValues();				interpOvlVar = mOverlayInterpolation.getParam();				// get the max min values of the interpolated variable				if (mSameProperties) {					mOvlInterpMin = mInterpolation.getMinValue();					mOvlInterpMax = mInterpolation.getMaxValue();					// get a pretty range					prettyNums = JOAFormulas.GetPrettyRange(mOvlInterpMin, mOvlInterpMax);					mOvlInterpMin = prettyNums.getVal1();					mOvlInterpMax = prettyNums.getVal2();					mOvlInterpInc = prettyNums.getVal3();				}				else {					mOvlInterpMin = mOverlayInterpolation.getMinValue();					mOvlInterpMax = mOverlayInterpolation.getMaxValue();					// get a pretty range					prettyNums = JOAFormulas.GetPrettyRange(mOvlInterpMin, mOvlInterpMax);					mOvlInterpMin = prettyNums.getVal1();					mOvlInterpMax = prettyNums.getVal2();					mOvlInterpInc = prettyNums.getVal3();				}				scaleOvlAxes();			}		}		public Dimension getPreferredSize() {			return new Dimension(panelWidth, panelHeight);		}		public void invalidate() {			try {				super.invalidate();				obsMarker = null;				obsMarker2 = null;				scaleAxes();				if (mOverlayContours) {					obsOvlMarker = null;					obsOvlMarker2 = null;					scaleOvlAxes();				}			}			catch (Exception e) {				e.printStackTrace();			}		}		public void scaleAxes() {			maxY = this.getSize().height - vBottomMargin - vTopMargin;			yScale = -maxY / (mPlotMax - mPlotMin);			yOrigin = mPlotMax;			double maxX = this.getSize().width - vRightMargin - vLeftMargin;			xScale = maxX / (mInterpMax - mInterpMin);			xOrigin = mInterpMin;		}		public void scaleOvlAxes() {			double maxX = this.getSize().width - vRightMargin - vLeftMargin;			xOvlScale = maxX / (mOvlInterpMax - mOvlInterpMin);			xOvlOrigin = mOvlInterpMin;		}		public void paintComponent(Graphics gin) {			Graphics2D g = (Graphics2D)gin;			super.paintComponent(g);			g.setColor(Color.black);			if (mAxes) {				plotXAxis(g);				if (mOverlayContours) {					plotOvlXAxis(g);				}			}			// plot the observed values			if (!mInterpolation.isResidualInterp()) {				plotObserved(g);			}			// plot the interpolated			plotInterpolated(g);			if (obsMarker == null) {				initDataSpot();			}			if (obsMarker != null) {				// set the clip				g.setClip(vRightMargin, vTopMargin, this.getSize().width - vRightMargin - vLeftMargin, this.getSize().height				    - vBottomMargin - vTopMargin);				obsMarker.drawMarker(g, false);				g.setClip(0, 0, 2000, 2000);			}			if (obsMarker2 != null) {				obsMarker2.drawMarker(g, false);			}			if (obsOvlMarker != null) {				obsOvlMarker.drawMarker(g, false);			}			if (obsOvlMarker2 != null) {				obsOvlMarker2.drawMarker(g, false);			}		}		public void plotObserved(Graphics2D g) {			// set the clip			g.setClip(vRightMargin, vTopMargin, this.getSize().width - vRightMargin - vLeftMargin, this.getSize().height			    - vBottomMargin - vTopMargin);			OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.currElement();			Section sech = (Section)of.mSections.currElement();			Station sh = (Station)sech.mStations.currElement();			int iPos = sech.getVarPos(interpVar.getVarName(), false);			if (mOverlayContours && mSameFV) {			}			int sPos = sech.getVarPos(mFileViewer.mAllProperties[surfVarNum].getVarLabel(), false);			if (iPos < 0 || sPos < 0) { return; }			Color symColor = new Color(255, 153, 153);			// loop on the bottles from the current station			for (int b = 0; b < sh.mNumBottles; b++) {				Bottle bh = (Bottle)sh.mBottles.elementAt(b);				double val = bh.mDValues[sPos];				double ival = bh.mDValues[iPos];				if (ival == JOAConstants.MISSINGVALUE) {					continue;				}				if (val <= mPlotMax) {					int v = (int)((val - yOrigin) * yScale);					if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {						v = maxY - v;					}					v = vTopMargin + v;					val = bh.mDValues[iPos];					int h = (int)((val - xOrigin) * xScale);					h += vLeftMargin;					g.setColor(symColor);					// draw a symbol					int[] xpoints = { h - 2, h, h, h + 2, h + 2, h, h, h - 2 };					int[] ypoints = { v, v - 2, v - 2, v, v, v + 2, v + 2, v };					g.fillPolygon(xpoints, ypoints, 8);					g.drawLine(h - 2, v, h, v - 2);					g.drawLine(h, v - 2, h + 2, v);					g.drawLine(h + 2, v, h, v + 2);					g.drawLine(h, v + 2, h - 2, v);					/*					 * if (mOverlayContours && iOvlPos >= 0) { ival =					 * bh.mDValues[iOvlPos];					 * 					 * if (ival == JOAConstants.MISSINGVALUE) continue;					 * 					 * h = (int)((ival - xOvlOrigin) * xOvlScale); h += vLeftMargin;					 * 					 * g.setColor(symColor); // draw a symbol int[] xpoints2 = {h-2, h, h,					 * h+2, h+2, h, h, h-2}; int[] ypoints2 = {v, v-2, v-2, v, v, v+2,					 * v+2, v}; g.fillPolygon(xpoints2, ypoints2, 8); g.drawLine(h-2, v,					 * h, v-2); g.drawLine(h, v-2, h+2, v); g.drawLine(h+2, v, h, v+2);					 * g.drawLine(h, v+2, h-2, v); }					 */				}			}			g.setClip(0, 0, 2000, 2000);		}		public void plotInterpolated(Graphics2D g) {			OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.currElement();			Section sech = (Section)of.mSections.currElement();			Station sh = (Station)sech.mStations.currElement();			g.setStroke(new BasicStroke(JOAConstants.CONNECT_LINE_WIDTH));			GeneralPath aLine = new GeneralPath();			GeneralPath aOvlLine = new GeneralPath();			// set the clip			g.setClip(vRightMargin, vTopMargin, this.getSize().width - vRightMargin - vLeftMargin, this.getSize().height			    - vBottomMargin - vTopMargin);			int interpCol = sh.mOrdinal - 1;			for (int j1 = minLevel; j1 < maxLevel; j1++) {				// v is computed from the surface at this point				double val = surfaceValues[j1];				int v0 = (int)((val - yOrigin) * yScale);				if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {					v0 = maxY - v0;				}				v0 = vTopMargin + v0;				// val = interpValues[j1][interpCol];				val = mInterpolation.getClosestValue(j1, sh);				// FIX Me--can't pass j1 to a zgrid				if (val == JOAConstants.MISSINGVALUE) {// ||					// mInterpolation.isBelowBottom(j1,					// sh.mBottomDepthInDBARS)) {					continue;				}				int h0 = (int)((val - xOrigin) * xScale);				h0 += vLeftMargin;				val = surfaceValues[j1 + 1];				int v = (int)((val - yOrigin) * yScale);				if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {					v = maxY - v;				}				v = vTopMargin + v;				// val = interpValues[j1 + 1][interpCol];				val = mInterpolation.getClosestValue(j1 + 1, sh);				if (val == JOAConstants.MISSINGVALUE) {// ||					// mInterpolation.isBelowBottom(j1					// + 1, sh.mBottomDepthInDBARS))					// {					continue;				}				int h = (int)((val - xOrigin) * xScale);				h += vLeftMargin;				aLine.moveTo((float)h0, (float)v0);				aLine.lineTo((float)h, (float)v);			}			if (mOverlayContours) {				if (!sh.isOverlayStnAssigned()) {					// have to find the closest matching station in the overlay					// interpolation to the					// browsing spot in the base layer					double bLat = sh.getLat();					double bLon = sh.getLon();					double minDist = 99999.0;					Station nearestOvlStn = null;					boolean search = true;					if (mOffset == JOAConstants.OFFSET_LATITUDE) {						if (bLat < mStationRegion.getMinLat() || bLat > mStationRegion.getMaxLat()) {							search = false;							sh.setOverlayStnAssigned(true);						}					}					else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {						// double maxLon = mOverlayLastStation.getLon();						// double minLon = mOverlayFirstStation.getLon();						// if (minLon < 0) {						// minLon += 360.0;						// }						// if (maxLon < 0) {						// maxLon += 360.0;						// }						// if (bLon < 0) {						// bLon += 360.0;						// }						// if (bLon < minLon || bLon > maxLon) {						// search = false;						// sh.setOverlayStnAssigned(true);						// }					}					if (search) {						for (int fc = 0; fc < mOverlayFileViewer.mNumOpenFiles; fc++) {							OpenDataFile ovlof = (OpenDataFile)mOverlayFileViewer.mOpenFiles.elementAt(fc);							for (int sec = 0; sec < ovlof.mNumSections; sec++) {								Section ovlsech = (Section)ovlof.mSections.elementAt(sec);								if (ovlsech.mNumCasts == 0) {									continue;								}								for (int stc = 0; stc < ovlsech.mStations.size(); stc++) {									Station ovlsh = (Station)ovlsech.mStations.elementAt(stc);									if (!ovlsh.mUseStn) {										continue;									}									double oLat = ovlsh.getLat();									double oLon = ovlsh.getLon();									// compute distance									double dist = JOAFormulas.Mercator(bLat, bLon, oLat, oLon);									if (dist < minDist) {										minDist = dist;										nearestOvlStn = ovlsh;									}								}							}						}						if (nearestOvlStn != null) {							sh.setNearestOverlayStn(nearestOvlStn);							sh.setOverlayStnAssigned(true);						}					}				}				if (sh.isOverlayStnAssigned() && sh.getNearestOverlayStn() != null) {					int ovlInterpCol = sh.getNearestOverlayStn().mOrdinal - 1;					for (int j1 = minLevel; j1 < maxLevel - 1; j1++) {						// v is computed from the surface at this point						double val = surfaceValues[j1];						int v0 = (int)((val - yOrigin) * yScale);						if (mOverlayFileViewer.mAllProperties[surfVarNum].isReverseY()) {							v0 = maxY - v0;						}						v0 = vTopMargin + v0;						val = interpOvlValues[j1][ovlInterpCol];						if (val == JOAConstants.MISSINGVALUE						    || mOverlayInterpolation.isBelowBottom(j1, sh.getNearestOverlayStn().mBottomDepthInDBARS)) {							continue;						}						int h0 = (int)((val - xOvlOrigin) * xOvlScale);						h0 += vLeftMargin;						val = surfaceValues[j1 + 1];						int v = (int)((val - yOrigin) * yScale);						if (mOverlayFileViewer.mAllProperties[surfVarNum].isReverseY()) {							v = maxY - v;						}						v = vTopMargin + v;						val = interpOvlValues[j1 + 1][ovlInterpCol];						if (val == JOAConstants.MISSINGVALUE						    || mOverlayInterpolation.isBelowBottom(j1 + 1, sh.getNearestOverlayStn().mBottomDepthInDBARS)) {							continue;						}						int h = (int)((val - xOvlOrigin) * xOvlScale);						h += vLeftMargin;						aOvlLine.moveTo((float)h0, (float)v0);						aOvlLine.lineTo((float)h, (float)v);					}					try {						aOvlLine.closePath();						g.setColor(Color.red);						g.draw(aOvlLine);					}					catch (Exception ex) {						ex.printStackTrace();					}				}			}			try {				aLine.closePath();				g.setColor(Color.black);				g.draw(aLine);			}			catch (Exception ex) {				// eat java.awt.geom.IllegalPathStateException				// ex.printStackTrace();			}			g.setClip(0, 0, 20000, 2000);		}		public void obsChanged(Station foundStation) {			// display the current station			setRecord(foundStation);		}		public void initDataSpot() {			// init the data spot			OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.currElement();			Section sech = (Section)of.mSections.currElement();			Station sh = (Station)sech.mStations.currElement();			int x, y = 0;			double val = 0.0;			val = surfaceValues[mCurrLevel];			y = (int)((val - yOrigin) * yScale);			if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {				y = maxY - y;			}			y = vTopMargin + y;			// need the value at this level and station for x			int interpCol = sh.mOrdinal - 1;			val = interpValues[mCurrLevel][interpCol];			if (val == JOAConstants.MISSINGVALUE) {				;			}			x = (int)((val - xOrigin) * xScale);			x += vLeftMargin;			int y2 = maxY + vTopMargin;			obsMarker = new ObsMarker(x, y, 8);			obsMarker2 = new ObsMarker(x, y2, 10);			obsMarker.setSymbol(JOAConstants.SYMBOL_HORIZONTAL_BAR_SYMBOL);			obsMarker2.setSymbol(JOAConstants.SYMBOL_DOWN_ARROW_SYMBOL);			if (mOverlayContours && mSameFV) {				val = interpOvlValues[mCurrLevel][interpCol];				if (val == JOAConstants.MISSINGVALUE) {					;				}				x = (int)((val - xOvlOrigin) * xOvlScale);				x += vLeftMargin;				obsOvlMarker = new ObsMarker(x, y, 8, Color.red);				obsOvlMarker2 = new ObsMarker(x, y2 + 25, 10, Color.red);				obsOvlMarker.setSymbol(JOAConstants.SYMBOL_HORIZONTAL_BAR_SYMBOL);				obsOvlMarker2.setSymbol(JOAConstants.SYMBOL_DOWN_ARROW_SYMBOL);			}		}		public void setRecord(Station sh) {			Graphics2D g = (Graphics2D)getGraphics();			// if (sh!= null && sh != oldStation) {			// erase the panel			Color bgColor = this.getBackground();			g.setColor(bgColor);			g.fillRect(0, 0, this.getSize().width, this.getSize().height - vBottomMargin);			g.setColor(Color.black);			// replot the current observation			if (!mInterpolation.isResidualInterp()) {				plotObserved(g);			}			// replot the interpolation trace			plotInterpolated(g);			// replot the spot {			// set the clip			// if (obsMarker != null) {			// obsMarker.drawMarker(g, false);			// obsMarker2.drawMarker(g, false);			// }			// }			oldStation = sh;			// update the marker			// need the value at this level and station for x			int x, y = 0;			double val = 0.0;			val = surfaceValues[mCurrLevel];			y = (int)((val - yOrigin) * yScale);			if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {				y = maxY - y;			}			y = vTopMargin + y;			int interpCol = sh.mOrdinal - 1;			val = interpValues[mCurrLevel][interpCol];			if (val == JOAConstants.MISSINGVALUE) {				;			}			x = (int)((val - xOrigin) * xScale);			x += vLeftMargin;			// compute new location of obsMarker2			int x2 = x;			int y2 = maxY + vTopMargin;			if (obsMarker == null) {				this.initDataSpot();			}			obsMarker.setNewPos(x, y);			obsMarker2.setNewPos(x2, y2);			g.setClip(vRightMargin, vTopMargin, this.getSize().width - vRightMargin - vLeftMargin, this.getSize().height			    - vBottomMargin - vTopMargin);			obsMarker.drawMarker(g, true);			g.setClip(0, 0, 2000, 2000);			obsMarker2.drawMarker(g, true);			if (mOverlayContours && mSameFV) {				val = interpOvlValues[mCurrLevel][interpCol];				if (val != JOAConstants.MISSINGVALUE) {					x = (int)((val - xOvlOrigin) * xOvlScale);					x += vLeftMargin;					g.setColor(bgColor);					g.fillRect(0, y2 + 20, this.getSize().width, 5);					g.setColor(Color.black);					obsOvlMarker.setNewPos(x, y);					obsOvlMarker2.setNewPos(x, y2 + 25);					// paintImmediately(0, 0, 1000, 1000);					obsOvlMarker2.drawMarker((Graphics2D)g, true);					obsOvlMarker.drawMarker((Graphics2D)g, true);				}			}		}		@SuppressWarnings("deprecation")		public void plotXAxis(Graphics2D g) {			g.setColor(Color.black);			int bottom = maxY;			int left = vLeftMargin;			int right = this.getSize().width - vRightMargin;			// compute a pretty increment			double mXInc = mInterpInc;			int mXTics = 2;			double maxX = this.getSize().width - vRightMargin - vLeftMargin;			double xDiff = (mInterpMax - mInterpMin);			int majorXTicks = (int)(xDiff / mXInc);			double xInc = (double)(maxX) / (xDiff / mXInc);			double minorXInc = xInc / ((double)mXTics + 1);			// draw the X axis			bottom = maxY + vTopMargin;			g.drawLine(left, bottom, right, bottom);			// draw the X tic marks			for (int i = 0; i <= majorXTicks; i++) {				int h = (int)(left + (i * xInc));				if (h <= right) {					g.drawLine(h, bottom + 5, h, bottom);				}				// plot the minor ticks				if (i <= majorXTicks) {					for (int hh = 0; hh < mXTics + 1; hh++) {						int newH = (int)(h + (hh * minorXInc));						if (newH <= right) {							g.drawLine(newH, bottom + 3, newH, bottom);						}					}				}			}			// set the X precision--always a pretty range			int numPlaces = JOAFormulas.GetDisplayPrecision(mXInc);			// label the x axis			Font font = new Font(JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_FONT, JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_STYLE,			    JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_SIZE);			g.setFont(font);			FontMetrics fm = Toolkit.getDefaultToolkit().getFontMetrics(font);			int charWidth = fm.charWidth(' ');			double vOrigin = mInterpMin;			String sTemp = null;			for (int i = 0; i <= majorXTicks; i++) {				if (i == 0 || i == majorXTicks) {					double myVal = vOrigin + (i * mXInc);					if (myVal == -0.0) {						myVal = 0.0;					}					int h = (int)((left - 5) + (i * xInc));					if (numPlaces > 0) {						sTemp = JOAFormulas.formatDouble(String.valueOf(myVal), numPlaces, false);					}					else {						sTemp = String.valueOf((int)myVal);					}					g.setColor(JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_COLOR);					g.drawString(sTemp, h - (((sTemp.length() - 1) * charWidth) / 2), bottom + 18);					g.setColor(Color.black);				}			}			// add variable label			font = new Font(JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_FONT, JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_STYLE,			    JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_SIZE);			g.setFont(font);			fm = Toolkit.getDefaultToolkit().getFontMetrics(font);			Color textColor;			textColor = JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_COLOR;			int mXVarCode = mInterpolation.getParam().getVariablePos();			int len = 0;			String axisLabel = null;			if (mFileViewer.mAllProperties[mXVarCode].getUnits() != null			    && mFileViewer.mAllProperties[mXVarCode].getUnits().length() > 0) {				axisLabel = mFileViewer.mAllProperties[mXVarCode].getVarLabel() + " ("				    + mFileViewer.mAllProperties[mXVarCode].getUnits() + ")";				len = fm.stringWidth(axisLabel);			}			else {				axisLabel = mFileViewer.mAllProperties[mXVarCode].getVarLabel();				len = fm.stringWidth(axisLabel);			}			int hh = this.getWidth() / 2 - (len / 2);			JOAFormulas.drawStyledString(axisLabel, hh, bottom + 17, g, 0, JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_FONT,			    JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_SIZE, JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_STYLE, textColor);			g.setColor(Color.black);		}		@SuppressWarnings("deprecation")		public void plotOvlXAxis(Graphics2D g) {			g.setColor(Color.red);			int bottom = maxY;			int left = vLeftMargin;			int right = this.getSize().width - vRightMargin;			// compute a pretty increment			double mXInc = mOvlInterpInc;			int mXTics = 2;			double maxX = this.getSize().width - vRightMargin - vLeftMargin;			double xDiff = (mOvlInterpMax - mOvlInterpMin);			int majorXTicks = (int)(xDiff / mXInc);			double xInc = (double)(maxX) / (xDiff / mXInc);			double minorXInc = xInc / ((double)mXTics + 1);			// draw the X axis			bottom = maxY + vTopMargin + 25;			g.drawLine(left, bottom, right, bottom);			// draw the X tic marks			for (int i = 0; i <= majorXTicks; i++) {				int h = (int)(left + (i * xInc));				if (h <= right) {					g.drawLine(h, bottom + 5, h, bottom);				}				// plot the minor ticks				if (i <= majorXTicks) {					for (int hh = 0; hh < mXTics + 1; hh++) {						int newH = (int)(h + (hh * minorXInc));						if (newH <= right) {							g.drawLine(newH, bottom + 3, newH, bottom);						}					}				}			}			// set the X precision--always a pretty range			int numPlaces = JOAFormulas.GetDisplayPrecision(mXInc);			// label the x axis			Font font = new Font(JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_FONT, JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_STYLE,			    JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_SIZE);			g.setFont(font);			FontMetrics fm = Toolkit.getDefaultToolkit().getFontMetrics(font);			int charWidth = fm.charWidth(' ');			double vOrigin = mOvlInterpMin;			String sTemp = null;			for (int i = 0; i <= majorXTicks; i++) {				if (i == 0 || i == majorXTicks) {					double myVal = vOrigin + (i * mXInc);					if (myVal == -0.0) {						myVal = 0.0;					}					int h = (int)((left - 5) + (i * xInc));					if (numPlaces > 0) {						sTemp = JOAFormulas.formatDouble(String.valueOf(myVal), numPlaces, false);					}					else {						sTemp = String.valueOf((int)myVal);					}					g.setColor(JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_COLOR);					g.drawString(sTemp, h - (((sTemp.length() - 1) * charWidth) / 2), bottom + 18);					g.setColor(Color.black);				}			}			// add variable label			font = new Font(JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_FONT, JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_STYLE,			    JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_SIZE);			g.setFont(font);			fm = Toolkit.getDefaultToolkit().getFontMetrics(font);			int mXVarCode = mOverlayInterpolation.getParam().getVariablePos();			int len = 0;			String axisLabel = null;			if (mOverlayFileViewer.mAllProperties[mXVarCode].getUnits() != null			    && mOverlayFileViewer.mAllProperties[mXVarCode].getUnits().length() > 0) {				axisLabel = mOverlayFileViewer.mAllProperties[mXVarCode].getVarLabel() + " ("				    + mOverlayFileViewer.mAllProperties[mXVarCode].getUnits() + ")";				len = fm.stringWidth(axisLabel);			}			else {				axisLabel = mFileViewer.mAllProperties[mXVarCode].getVarLabel();				len = fm.stringWidth(axisLabel);			}			int hh = this.getWidth() / 2 - (len / 2);			JOAFormulas.drawStyledString(axisLabel, hh, bottom + 17, g, 0, JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_FONT,			    JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_SIZE, JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_STYLE, Color.red);			g.setColor(Color.black);		}		// OK Button		public void dialogDismissed(JDialog d) {			// get new max and min			mInterpMax = ((ConfigVXsec)d).getMax();			mInterpMin = ((ConfigVXsec)d).getMin();			mInterpInc = ((ConfigVXsec)d).getInc();			obsMarker = null;			obsMarker2 = null;			this.scaleAxes();			if (mOverlayContours) {				mOvlInterpMax = ((ConfigVXsec)d).getOvlMax();				mOvlInterpMin = ((ConfigVXsec)d).getOvlMin();				mOvlInterpInc = ((ConfigVXsec)d).getOvlInc();				obsOvlMarker = null;				obsOvlMarker2 = null;				this.scaleOvlAxes();			}			this.paintComponent(this.getGraphics());		}		// Cancel button		public void dialogCancelled(JDialog d) {			mInterpMax = ((ConfigVXsec)d).getOrigMax();			mInterpMin = ((ConfigVXsec)d).getOrigMin();			mInterpInc = ((ConfigVXsec)d).getOrigInc();			obsMarker = null;			obsMarker2 = null;			this.scaleAxes();			if (mOverlayContours) {				mOvlInterpMax = ((ConfigVXsec)d).getOvlOrigMax();				mOvlInterpMin = ((ConfigVXsec)d).getOvlOrigMin();				mOvlInterpInc = ((ConfigVXsec)d).getOvlOrigInc();				obsOvlMarker = null;				obsOvlMarker2 = null;				this.scaleOvlAxes();			}			this.paintComponent(this.getGraphics());		}		// something other than the OK button		public void dialogDismissedTwo(JDialog d) {		}		public void dialogApplyTwo(Object d) {		}		// Applxy button, OK w/o dismissing the dialog		public void dialogApply(JDialog d) {			mInterpMax = ((ConfigVXsec)d).getMax();			mInterpMin = ((ConfigVXsec)d).getMin();			mInterpInc = ((ConfigVXsec)d).getInc();			obsMarker = null;			obsMarker2 = null;			this.scaleAxes();			if (mOverlayContours) {				mOvlInterpMax = ((ConfigVXsec)d).getOvlMax();				mOvlInterpMin = ((ConfigVXsec)d).getOvlMin();				mOvlInterpInc = ((ConfigVXsec)d).getOvlInc();				obsOvlMarker = null;				obsOvlMarker2 = null;				this.scaleOvlAxes();			}			this.paintComponent(this.getGraphics());		}	}	private class HorizontalXSecPanel extends JPanel implements DialogClient, ActionListener {		int maxY = 0;		double yScale = 0.0;		double xScale = 0.0;		double yOrigin = 0.0;		double xOrigin = 0.0;		int hLeftMargin = 0;		int hBottomMargin = 0;		int hTopMargin = 0;		int hRightMargin = 0;		int hRight = 0;		int panelWidth = 0;		int panelHeight = 0;		double mInterpMin = 0;		double mInterpMax = 0;		double mInterpInc = 1.0;		int oldLevel = mCurrLevel;		ObsMarker obsMarker = null;		ObsMarker obsMarker2 = null;		// double pixelsPerUnit = 0;		DialogClient mDialogClient = null;		private JPopupMenu mPopupMenu = null;		double[][] interpOvlValues;		int maxOvlY = 0;		double yOvlScale = 0.0;		double xOvlScale = 0.0;		double yOvlOrigin = 0.0;		double xOvlOrigin = 0.0;		double mOvlInterpMin = 0;		double mOvlInterpMax = 0;		double mOvlInterpInc = 1.0;		double ovlPixelsPerUnit = 0;		ObsMarker obsOvlMarker = null;		ObsMarker obsOvlMarker2 = null;		public HorizontalXSecPanel(int inWidth, int inHeight) {			super(false);			this.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);			hRight = inWidth;			panelWidth = inWidth + 20;			panelHeight = inHeight;			mDialogClient = this;			addMouseListener(new HXsecMouseHandler());			init();		}		public void createPopup(Point point) {			ResourceBundle b = ResourceBundle.getBundle("javaoceanatlas.resources.JOAResources");			mPopupMenu = new JPopupMenu();			JMenuItem openContextualMenu = new JMenuItem(b.getString("kProperties"));			openContextualMenu.setActionCommand("opencontextual");			openContextualMenu.addActionListener(this);			mPopupMenu.add(openContextualMenu);			mPopupMenu.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));			mPopupMenu.show(this, point.x, point.y);		}		public void showConfigDialog() {			// show configuration dialog			double tempYMin = mFileViewer.mAllProperties[mPlotSpec.getYVar().getVariablePos()].getPlotMin();			double tempYMax = mFileViewer.mAllProperties[mPlotSpec.getYVar().getVariablePos()].getPlotMax();			ConfigHXsec cp = null;			if (mOverlayContours) {				double tempOvlYMin = mOverlayFileViewer.mAllProperties[mPlotSpec.getOvlYVar().getVariablePos()].getPlotMin();				double tempOvlYMax = mOverlayFileViewer.mAllProperties[mPlotSpec.getOvlYVar().getVariablePos()].getPlotMax();				cp = new ConfigHXsec(mFrame, mDialogClient, mInterpMin, mInterpMax, mInterpInc, tempYMin, tempYMax,				    mOvlInterpMin, mOvlInterpMax, mOvlInterpInc, tempOvlYMin, tempOvlYMax);			}			else {				cp = new ConfigHXsec(mFrame, mDialogClient, mInterpMin, mInterpMax, mInterpInc, tempYMin, tempYMax);			}			cp.pack();			cp.setVisible(true);		}		public void actionPerformed(ActionEvent e) {			String cmd = e.getActionCommand();			if (cmd.equals("opencontextual")) {				showConfigDialog();			}		}		public class HXsecMouseHandler extends MouseAdapter {			public void mouseClicked(MouseEvent me) {				if (mWindowIsLocked) { return; }				if (me.getClickCount() == 2) {					// show configuration dialog					showConfigDialog();				}			}			public void mouseReleased(MouseEvent me) {				if (mWindowIsLocked) { return; }				super.mouseReleased(me);				if (me.isPopupTrigger()) {					createPopup(me.getPoint());				}			}			public void mousePressed(MouseEvent me) {				if (mWindowIsLocked) { return; }				super.mousePressed(me);				if (me.isPopupTrigger()) {					createPopup(me.getPoint());				}			}		}		public void init() {			// initialize some variables			nz = mInterpolation.getLevels();			nsta = mInterpolation.getNumStns();			surfVarNum = mInterpolation.getSurfParamNum();			interpValues = mInterpolation.getValues();			surface = mInterpolation.getSurface();			surfaceValues = surface.getValues();			contourValues = mColorBar.getValues();			// get the max min values of the interpolated variable			mInterpMin = mInterpolation.getMinValue();			mInterpMax = mInterpolation.getMaxValue();			// get a pretty range			Triplet prettyNums = JOAFormulas.GetPrettyRange(mInterpMin, mInterpMax);			mInterpMin = prettyNums.getVal1();			mInterpMax = prettyNums.getVal2();			mInterpInc = prettyNums.getVal3();			if (mAxes) {				hLeftMargin = 70;				hRightMargin = 0;				hBottomMargin = 5;				hTopMargin = 5;			}			scaleAxes();			if (mOverlayContours) {				interpOvlValues = mOverlayInterpolation.getValues();				if (mSameProperties) {					mOvlInterpMin = mInterpolation.getMinValue();					mOvlInterpMax = mInterpolation.getMaxValue();					// get a pretty range					prettyNums = JOAFormulas.GetPrettyRange(mOvlInterpMin, mOvlInterpMax);					mOvlInterpMin = prettyNums.getVal1();					mOvlInterpMax = prettyNums.getVal2();					mOvlInterpInc = prettyNums.getVal3();				}				else {					// get the max min values of the interpolated variable					mOvlInterpMin = mOverlayInterpolation.getMinValue();					mOvlInterpMax = mOverlayInterpolation.getMaxValue();					// get a pretty range					prettyNums = JOAFormulas.GetPrettyRange(mOvlInterpMin, mOvlInterpMax);					mOvlInterpMin = prettyNums.getVal1();					mOvlInterpMax = prettyNums.getVal2();					mOvlInterpInc = prettyNums.getVal3();					scaleOvlAxes();				}			}		}		public Dimension getPreferredSize() {			return new Dimension(panelWidth + hRightMargin, panelHeight);		}		public void invalidate() {			try {				super.invalidate();				obsMarker = null;				obsMarker2 = null;				scaleAxes();				if (mOverlayContours) {					obsOvlMarker = null;					obsOvlMarker2 = null;					scaleOvlAxes();				}			}			catch (Exception e) {				e.printStackTrace();			}		}		public void paintComponent(Graphics gin) {			Graphics2D g = (Graphics2D)gin;			if (g instanceof PrintGraphics) {				g.setColor(Color.black);				if (mAxes) {					plotYAxis(g);				}				// plot the interpolated values				plotInterpolated(g);				if (mOverlayContours) {					plotOverlayInterpolated(g);				}				if (obsMarker != null) {					Point p = obsMarker.getPos();					g.drawLine(p.x, p.y - 3, p.x, p.y + 3);				}			}			else {				super.paintComponent(g);				g.setColor(Color.black);				if (mAxes) {					plotYAxis(g);					if (mOverlayContours) {						plotOvlYAxis(g);					}				}				// plot the interpolated values				plotInterpolated(g);				if (mOverlayContours) {					plotOverlayInterpolated(g);				}				if (obsMarker == null) {					initDataSpot();				}				if (obsMarker != null) {					obsMarker.drawMarker(g, false);				}				if (obsMarker2 != null) {					obsMarker2.drawMarker(g, false);				}				if (obsOvlMarker != null) {					obsOvlMarker.drawMarker(g, false);				}				if (obsOvlMarker2 != null) {					obsOvlMarker2.drawMarker(g, false);				}			}		}		public void scaleAxes() {			maxY = this.getSize().height - hBottomMargin - hTopMargin;			yScale = -maxY / (mInterpMax - mInterpMin);			yOrigin = mInterpMax;		}		public void scaleOvlAxes() {			maxY = this.getSize().height - hBottomMargin - hTopMargin;			yOvlScale = -maxY / (mOvlInterpMax - mOvlInterpMin);			yOvlOrigin = mOvlInterpMax;		}		public void plotInterpolated(Graphics2D g) {			g.setStroke(new BasicStroke(JOAConstants.CONNECT_LINE_WIDTH));			GeneralPath aLine = new GeneralPath();			int x = 0, x0 = 0, y, y0, oldx = -99, oldy = -99;			for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {				OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.elementAt(fc);				for (int sec = 0; sec < of.mNumSections; sec++) {					Section sech = (Section)of.mSections.elementAt(sec);					if (sech.mNumCasts == 0) {						continue;					}					if (sech.mStations.size() > 1) {						// collect the unfiltered stations						Vector<Station> vizStns = new Vector<Station>();						for (int stc = 0; stc < sech.mStations.size(); stc++) {							Station sh = (Station)sech.mStations.elementAt(stc);							if (sh.mUseStn && mStationRegion.isStnInRegion(sh)) {								vizStns.addElement(sh);							}						}						// plot the visible stations						for (int stc = 0; stc < vizStns.size() - 1; stc++) {							Station sh = vizStns.elementAt(stc);							Station sh2 = vizStns.elementAt(stc + 1);							if (mOffset == JOAConstants.OFFSET_SEQUENCE) {								x0 = (int)(hLeftMargin + ((sh.mOrdinal - 1) * mStationRegion.getXScale()));								x = (int)(hLeftMargin + ((sh2.mOrdinal - 1) * mStationRegion.getXScale()));							}							else if (mOffset == JOAConstants.OFFSET_DISTANCE) {								x0 = (int)(hLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset())));								x = (int)(hLeftMargin + (mStationRegion.getXScale() * (sh2.getCumDistInKM() - mStationRegion.getXOffset())));							}							else if (mOffset == JOAConstants.OFFSET_LATITUDE) {								if (!mNtoSSection) {									x0 = hLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());								}								else {									x0 = hLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());								}								if (!mNtoSSection) {									x = hLeftMargin + (int)((sh2.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());								}								else {									x = hLeftMargin + (int)((mStationRegion.getMaxLat() - sh2.mLat) * mStationRegion.getXScale());								}							}							else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {								double lon = sh.mLon;								if (mStationRegion.getLeftLon() < 0) {									if (lon < 0 && lon < mStationRegion.getLeftLon()) {										lon += 360.0;									}								}								else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {									lon += 360.0;								}								// if (mFileViewer.mStnFilterActive) {								// if (mFileViewer.mFilteredDataCross180) {								// if (lon < 0) {								// lon += 360.0;								// }								// }								// }								// else {								// if (mFileViewer.mUnFilteredDataCross180) {								// if (lon < 0) {								// lon += 360.0;								// }								// }								// }								x0 = (int)(hLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));								// lon must increase to the right								lon = sh2.mLon;								if (mStationRegion.getLeftLon() < 0) {									if (lon < 0 && lon < mStationRegion.getLeftLon()) {										lon += 360.0;									}								}								else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {									lon += 360.0;								}								x = (int)(hLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));							}							else if (mOffset == JOAConstants.OFFSET_TIME) {								x0 = (int)(hLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion								    .getMinTime())));								x = (int)(hLeftMargin + (mStationRegion.getXScale() * (sh2.getDate().getTime() - mStationRegion								    .getMinTime())));							}							// compute first point							double val = interpValues[mCurrLevel][sh.mOrdinal - 1];							if (val == JOAConstants.MISSINGVALUE || mInterpolation.isBelowBottom(mCurrLevel, sh.mBottomDepthInDBARS)) {								continue;							}							y0 = (int)((val - yOrigin) * yScale);							y0 = hTopMargin + y0;							// compute second point							val = interpValues[mCurrLevel][sh2.mOrdinal - 1];							if (val == JOAConstants.MISSINGVALUE || mInterpolation.isBelowBottom(mCurrLevel, sh2.mBottomDepthInDBARS)) {								continue;							}							y = (int)((val - yOrigin) * yScale);							y += hTopMargin;							// System.out.println(mStationRegion.getLeftLon() + "\t" + x0 +							// "\t" + x + "\t" + y);							// draw a line							aLine.moveTo((float)x0, (float)y0);							aLine.lineTo((float)x, (float)y);							oldx = x;							oldy = y;						}					}					else {						Station sh = (Station)sech.mStations.elementAt(0);						if (sh.mUseStn && mStationRegion.isStnInRegion(sh)) {							if (mOffset == JOAConstants.OFFSET_SEQUENCE) {								x0 = (int)(hLeftMargin + ((sh.mOrdinal - 1) * mStationRegion.getXScale()));							}							else if (mOffset == JOAConstants.OFFSET_DISTANCE) {								x0 = (int)(hLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset())));							}							else if (mOffset == JOAConstants.OFFSET_LATITUDE) {								if (!mNtoSSection) {									x0 = hLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());								}								else {									x0 = hLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());								}							}							else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {								// lon must increase to the right								double lon = sh.mLon;								if (mStationRegion.getLeftLon() < 0) {									if (lon < 0 && lon < mStationRegion.getLeftLon()) {										lon += 360.0;									}								}								else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {									lon += 360.0;								}								// if (mFileViewer.mStnFilterActive) {								// if (mFileViewer.mFilteredDataCross180) {								// if (lon < 0) {								// lon += 360.0;								// }								// }								// }								// else {								// if (mFileViewer.mUnFilteredDataCross180) {								// if (lon < 0) {								// lon += 360.0;								// }								// }								// }								x0 = (int)(hLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));							}							else if (mOffset == JOAConstants.OFFSET_TIME) {								x0 = (int)(hLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion								    .getMinTime())));							}							double val = interpValues[mCurrLevel][sh.mOrdinal - 1];							if (val == JOAConstants.MISSINGVALUE) {								continue;							}							y0 = (int)((val - yOrigin) * yScale);							y0 = hTopMargin + y0;							if (oldx != -99) {								aLine.moveTo((float)oldx, (float)oldy);								aLine.lineTo((float)x0, (float)y0);							}							oldx = x0;							oldy = y0;						}					}				}				try {					aLine.closePath();					g.setColor(Color.black);					g.draw(aLine);				}				catch (Exception ex) {					// ex.printStackTrace();				}			}		}		public void plotOverlayInterpolated(Graphics2D g) {			g.setStroke(new BasicStroke(JOAConstants.CONNECT_LINE_WIDTH));			GeneralPath aLine = new GeneralPath();			int x = 0, x0 = 0, y, y0, oldx = -99, oldy = -99;			for (int fc = 0; fc < mOverlayFileViewer.mNumOpenFiles; fc++) {				OpenDataFile of = (OpenDataFile)mOverlayFileViewer.mOpenFiles.elementAt(fc);				for (int sec = 0; sec < of.mNumSections; sec++) {					Section sech = (Section)of.mSections.elementAt(sec);					if (sech.mNumCasts == 0) {						continue;					}					if (sech.mStations.size() > 1) {						// collect the unfiltered stations						Vector<Station> vizStns = new Vector<Station>();						for (int stc = 0; stc < sech.mStations.size(); stc++) {							Station sh = (Station)sech.mStations.elementAt(stc);							if (sh.mUseStn && mStationRegion.isStnInRegion(sh)) {								vizStns.addElement(sh);							}						}						// plot the visible stations						for (int stc = 0; stc < vizStns.size() - 1; stc++) {							Station sh = (Station)vizStns.elementAt(stc);							Station sh2 = (Station)vizStns.elementAt(stc + 1);							if (mOffset == JOAConstants.OFFSET_SEQUENCE) {								x0 = (int)(hLeftMargin + ((sh.mOrdinal - 1) * mStationRegion.getXScale()));								x = (int)(hLeftMargin + ((sh2.mOrdinal - 1) * mStationRegion.getXScale()));							}							else if (mOffset == JOAConstants.OFFSET_DISTANCE) {								x0 = (int)(hLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset())));								x = (int)(hLeftMargin + (mStationRegion.getXScale() * (sh2.getCumDistInKM() - mStationRegion.getXOffset())));							}							else if (mOffset == JOAConstants.OFFSET_LATITUDE) {								if (!mNtoSSection) {									x0 = hLeftMargin + (int)((sh.mLat - mFileViewer.mLatMin) * mStationRegion.getXScale());								}								else {									x0 = hLeftMargin + (int)((mFileViewer.mLatMax - sh.mLat) * mStationRegion.getXScale());								}							}							else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {								double lon = sh.mLon;								if (mStationRegion.getLeftLon() < 0) {									if (lon < 0 && lon < mStationRegion.getLeftLon()) {										lon += 360.0;									}								}								else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {									lon += 360.0;								}								// if (mOverlayFileViewer.mStnFilterActive) {								// if (mOverlayFileViewer.mFilteredDataCross180) {								// if (lon < 0) {								// lon += 360.0;								// }								// }								// }								// else {								// if (mOverlayFileViewer.mUnFilteredDataCross180) {								// if (lon < 0) {								// lon += 360.0;								// }								// }								// }								x0 = (int)(hLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));								// lon must increase to the right								lon = sh2.mLon;								if (mStationRegion.getLeftLon() < 0) {									if (lon < 0 && lon < mStationRegion.getLeftLon()) {										lon += 360.0;									}								}								// if (mOverlayFileViewer.mStnFilterActive) {								// if (mOverlayFileViewer.mFilteredDataCross180) {								// if (lon < 0) {								// lon += 360.0;								// }								// }								// }								// else {								// if (mOverlayFileViewer.mUnFilteredDataCross180) {								// if (lon < 0) {								// lon += 360.0;								// }								// }								// }								x = (int)(hLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));							}							else if (mOffset == JOAConstants.OFFSET_TIME) {								x0 = (int)(hLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion								    .getMinTime())));								x = (int)(hLeftMargin + (mStationRegion.getXScale() * (sh2.getDate().getTime() - mStationRegion								    .getMinTime())));							}							// compute first point							double val = interpOvlValues[mCurrLevel][sh.mOrdinal - 1];							if (val == JOAConstants.MISSINGVALUE							    || mOverlayInterpolation.isBelowBottom(mCurrLevel, sh.mBottomDepthInDBARS)) {								continue;							}							y0 = (int)((val - yOvlOrigin) * yOvlScale);							y0 = hTopMargin + y0;							// compute second point							val = interpOvlValues[mCurrLevel][sh2.mOrdinal - 1];							if (val == JOAConstants.MISSINGVALUE							    || mOverlayInterpolation.isBelowBottom(mCurrLevel, sh2.mBottomDepthInDBARS)) {								continue;							}							y = (int)((val - yOvlOrigin) * yOvlScale);							y += hTopMargin;							// draw a line							aLine.moveTo((float)x0, (float)y0);							aLine.lineTo((float)x, (float)y);							oldx = x;							oldy = y;						}					}					else {						Station sh = (Station)sech.mStations.elementAt(0);						if (sh.mUseStn && mStationRegion.isStnInRegion(sh)) {							if (mOffset == JOAConstants.OFFSET_SEQUENCE) {								x0 = (int)(hLeftMargin + ((sh.mOrdinal - 1) * mStationRegion.getXScale()));							}							else if (mOffset == JOAConstants.OFFSET_DISTANCE) {								x0 = (int)(hLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset())));							}							else if (mOffset == JOAConstants.OFFSET_LATITUDE) {								if (!mNtoSSection) {									x0 = hLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());								}								else {									x0 = hLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());								}							}							else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {								// lon must increase to the right								double lleftLon = mOverlayFirstStation.getLon();								double lon = sh.mLon;								if (lleftLon < 0) {									if (lon < 0 && lon < lleftLon) {										lon += 360.0;									}								}								else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {									lon += 360.0;								}								// if (mOverlayFileViewer.mStnFilterActive) {								// if (mOverlayFileViewer.mFilteredDataCross180) {								// if (lon < 0) {								// lon += 360.0;								// }								// }								// }								// else {								// if (mOverlayFileViewer.mUnFilteredDataCross180) {								// if (lon < 0) {								// lon += 360.0;								// }								// }								// }								x0 = (int)(hLeftMargin + ((lon - lleftLon) * mStationRegion.getXScale()));							}							else if (mOffset == JOAConstants.OFFSET_TIME) {								x0 = (int)(hLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion								    .getMinTime())));							}							double val = interpOvlValues[mCurrLevel][sh.mOrdinal - 1];							if (val == JOAConstants.MISSINGVALUE) {								continue;							}							y0 = (int)((val - yOrigin) * yScale);							y0 = hTopMargin + y0;							if (oldx != -99) {								aLine.moveTo((float)oldx, (float)oldy);								aLine.lineTo((float)x0, (float)y0);							}							oldx = x0;							oldy = y0;						}					}				}			}			try {				aLine.closePath();				g.setColor(Color.red);				g.draw(aLine);			}			catch (Exception ex) {				ex.printStackTrace();			}		}		public void obsChanged(Station sh) {			// display the current station			setRecord(sh);		}		public void initDataSpot() {			OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.currElement();			Section sech = (Section)of.mSections.currElement();			Station sh = (Station)sech.mStations.currElement();			int x = 0, y = 0, ovly = 0;			double val = 0.0;			int interpCol = sh.mOrdinal - 1;			if (mOffset == JOAConstants.OFFSET_SEQUENCE) {				x = (int)(hLeftMargin + ((sh.mOrdinal - 1) * mStationRegion.getXScale()));			}			else if (mOffset == JOAConstants.OFFSET_DISTANCE) {				x = (int)(hLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset())));			}			else if (mOffset == JOAConstants.OFFSET_LATITUDE) {				if (!mNtoSSection) {					x = hLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());				}				else {					x = hLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());				}			}			else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {				// lon must increase to the right				double lon = sh.mLon;				if (mStationRegion.getLeftLon() < 0) {					if (lon < 0 && lon < mStationRegion.getLeftLon()) {						lon += 360.0;					}				}				else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {					lon += 360.0;				}				// if (mFileViewer.mStnFilterActive) {				// if (mFileViewer.mFilteredDataCross180) {				// if (lon < 0) {				// lon += 360.0;				// }				// }				// }				// else {				// if (mFileViewer.mUnFilteredDataCross180) {				// if (lon < 0) {				// lon += 360.0;				// }				// }				// }				x = (int)(hLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));			}			else if (mOffset == JOAConstants.OFFSET_TIME) {				x = (int)(hLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion.getMinTime())));			}			val = interpValues[mCurrLevel][interpCol];			if (val != JOAConstants.MISSINGVALUE) {				y = (int)((val - yOrigin) * yScale);				y = hTopMargin + y;			}			obsMarker = new ObsMarker(x, y, 8);			obsMarker2 = new ObsMarker(hLeftMargin, y, 10);			obsMarker.setSymbol(JOAConstants.SYMBOL_VERTICAL_BAR_SYMBOL);			obsMarker2.setSymbol(JOAConstants.SYMBOL_LEFT_ARROW_SYMBOL);			if (mOverlayContours && mSameFV) {				val = interpOvlValues[mCurrLevel][interpCol];				if (val == JOAConstants.MISSINGVALUE) { return; }				ovly = (int)((val - yOvlOrigin) * yOvlScale);				ovly = hTopMargin + ovly;				obsOvlMarker = new ObsMarker(x, ovly, 8, Color.red);				obsOvlMarker2 = new ObsMarker(hLeftMargin - 35, ovly, 10, Color.red);				obsOvlMarker.setSymbol(JOAConstants.SYMBOL_VERTICAL_BAR_SYMBOL);				obsOvlMarker2.setSymbol(JOAConstants.SYMBOL_LEFT_ARROW_SYMBOL);			}		}		public void setRecord(Station sh) {			if (sh == null) { return; }			Graphics g = this.getGraphics();			// if (mCurrLevel != oldLevel) {			// erase the panel			Color bgColor = this.getBackground();			g.setColor(bgColor);			if (mAxes) {				g.fillRect(hLeftMargin, 0, this.getSize().width - hRightMargin, this.getSize().height + 100);			}			else {				g.fillRect(hLeftMargin - 1, 0, this.getSize().width - hRightMargin + 1, this.getSize().height + 100);			}			g.fillRect(hLeftMargin - 35, 0, 6, this.getSize().height + 100);			g.setColor(Color.black);			// replot the interpolation trace			plotInterpolated((Graphics2D)g);			if (mOverlayContours) {				plotOverlayInterpolated((Graphics2D)g);			}			// }			oldLevel = mCurrLevel;			// update the marker			int x = 0, y = 0;			double val = 0.0;			int interpCol = sh.mOrdinal - 1;			if (mOffset == JOAConstants.OFFSET_SEQUENCE) {				x = (int)(hLeftMargin + ((sh.mOrdinal - 1) * mStationRegion.getXScale()));			}			else if (mOffset == JOAConstants.OFFSET_DISTANCE) {				x = (int)(hLeftMargin + (mStationRegion.getXScale() * (sh.getCumDistInKM() - mStationRegion.getXOffset())));			}			else if (mOffset == JOAConstants.OFFSET_LATITUDE) {				if (!mNtoSSection) {					x = hLeftMargin + (int)((sh.mLat - mStationRegion.getMinLat()) * mStationRegion.getXScale());				}				else {					x = hLeftMargin + (int)((mStationRegion.getMaxLat() - sh.mLat) * mStationRegion.getXScale());				}			}			else if (mOffset == JOAConstants.OFFSET_LONGITUDE) {				// lon must increase to the right				double lon = sh.mLon;				if (mStationRegion.getLeftLon() < 0) {					if (lon < 0 && lon < mStationRegion.getLeftLon()) {						lon += 360.0;					}				}				else if (mStationRegion.getLeftLon() >= 0 && lon < 0) {					lon += 360.0;				}				// if (mFileViewer.mStnFilterActive) {				// if (mFileViewer.mFilteredDataCross180) {				// if (lon < 0) {				// lon += 360.0;				// }				// }				// }				// else {				// if (mFileViewer.mUnFilteredDataCross180) {				// if (lon < 0) {				// lon += 360.0;				// }				// }				// }				x = (int)(hLeftMargin + ((lon - mStationRegion.getLeftLon()) * mStationRegion.getXScale()));			}			else if (mOffset == JOAConstants.OFFSET_TIME) {				x = (int)(hLeftMargin + (mStationRegion.getXScale() * (sh.getDate().getTime() - mStationRegion.getMinTime())));			}			val = interpValues[mCurrLevel][interpCol];			if (val != JOAConstants.MISSINGVALUE) {				y = (int)((val - yOrigin) * yScale);				y = hTopMargin + y;				if (obsMarker == null) {					this.initDataSpot();				}				obsMarker.setNewPos(x, y);				obsMarker2.setNewPos(hLeftMargin, y);				// paintImmediately(0, 0, 1000, 1000);				obsMarker2.drawMarker((Graphics2D)g, true);				obsMarker.drawMarker((Graphics2D)g, true);			}			if (mOverlayContours && mSameFV) {				val = interpOvlValues[mCurrLevel][interpCol];				if (val != JOAConstants.MISSINGVALUE) {					y = (int)((val - yOvlOrigin) * yOvlScale);					y = hTopMargin + y;					obsOvlMarker.setNewPos(x, y);					obsOvlMarker2.setNewPos(hLeftMargin - 35, y);					// paintImmediately(0, 0, 1000, 1000);					obsOvlMarker2.drawMarker((Graphics2D)g, true);					obsOvlMarker.drawMarker((Graphics2D)g, true);				}			}		}		@SuppressWarnings("deprecation")		public void plotYAxis(Graphics gin) {			Graphics2D g = (Graphics2D)gin;			g.setColor(Color.black);			int bottom = this.getSize().height - hBottomMargin;			int top = hTopMargin;			int right = hLeftMargin;			// compute a pretty increment			double mYInc = mInterpInc;			int mYTics = 2;			double yDiff = (mInterpMax - mInterpMin);			int majorYTicks = (int)(yDiff / mYInc);			double yInc = (double)(maxY) / (yDiff / mYInc);			double minorYInc = yInc / ((double)mYTics + 1);			/* draw the Y axis */			g.drawLine(right - 1, top, right - 1, bottom);			// draw the Y tic marks			for (int i = 0; i <= majorYTicks; i++) {				int v = (int)(hTopMargin + (i * yInc));				g.drawLine(right - 6, v, right - 1, v);				// plot the minor ticks				if (i < majorYTicks) {					for (int vv = 0; vv < mYTics + 1; vv++) {						int newV = (int)(v + (vv * minorYInc));						g.drawLine(right - 4, newV, right - 1, newV);					}				}			}			// set the Y precision			// int numPlaces = 1;			int numPlaces = JOAFormulas.GetDisplayPrecision(mYInc);			// label the axes			Font font = new Font(JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_FONT, JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_STYLE,			    JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_SIZE);			g.setFont(font);			FontMetrics fm = Toolkit.getDefaultToolkit().getFontMetrics(font);			double vOrigin;			double myVal;			if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {				vOrigin = mInterpMax;			}			else {				vOrigin = mInterpMin;			}			String sTemp = null;			sTemp = JOAFormulas.returnSpacePaddedString(JOAFormulas.formatDouble(String.valueOf(vOrigin			    + (majorYTicks * mYInc)), numPlaces, false), 4);			int len = fm.stringWidth(sTemp);			int fh = JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_SIZE;			for (int i = 0; i <= majorYTicks; i++) {				if (i == 0 || i == majorYTicks) {					if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {						myVal = vOrigin - (i * mYInc);					}					else {						myVal = vOrigin + (i * mYInc);					}					if (myVal == -0.0) {						myVal = 0.0;					}					int v = (int)(hTopMargin + (i * yInc));					if (numPlaces > 0) {						sTemp = JOAFormulas.returnSpacePaddedString(JOAFormulas.formatDouble(String.valueOf(myVal), numPlaces,						    false), 4);					}					else {						sTemp = JOAFormulas.returnSpacePaddedString((int)myVal, 4);					}					g.setColor(JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_COLOR);					g.drawString(sTemp, right - len - 10, v + fh / 2 - 2);					g.setColor(Color.black);				}			}			// add variable label			font = new Font(JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_FONT, JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_STYLE,			    JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_SIZE);			g.setFont(font);			fm = Toolkit.getDefaultToolkit().getFontMetrics(font);			int width = 0;			String axisLabel = null;			if (mInterpolation.getParam().getVarUnits() != null && mInterpolation.getParam().getVarUnits().length() > 0) {				axisLabel = mInterpolation.getParam().getVarName() + " (" + mInterpolation.getParam().getVarUnits() + ")";				width = fm.stringWidth(axisLabel);			}			else {				axisLabel = mInterpolation.getParam().getVarName();				width = fm.stringWidth(axisLabel);			}			JOAFormulas.drawStyledString(axisLabel, 55, this.getHeight() / 2 + width / 2, g, 90,			    JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_FONT, JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_SIZE,			    JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_STYLE, JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_COLOR);		}		@SuppressWarnings("deprecation")		public void plotOvlYAxis(Graphics gin) {			Graphics2D g = (Graphics2D)gin;			g.setColor(Color.red);			int bottom = this.getSize().height - hBottomMargin;			int top = hTopMargin;			int right = hLeftMargin - 35;			// compute a pretty increment			double mYInc = mOvlInterpInc;			int mYTics = 2;			double yDiff = (mOvlInterpMax - mOvlInterpMin);			int majorYTicks = (int)(yDiff / mYInc);			double yInc = (double)(maxY) / (yDiff / mYInc);			double minorYInc = yInc / ((double)mYTics + 1);			/* draw the Y axis */			g.drawLine(right - 1, top, right - 1, bottom);			// draw the Y tic marks			for (int i = 0; i <= majorYTicks; i++) {				int v = (int)(hTopMargin + (i * yInc));				g.drawLine(right - 6, v, right - 1, v);				// plot the minor ticks				if (i < majorYTicks) {					for (int vv = 0; vv < mYTics + 1; vv++) {						int newV = (int)(v + (vv * minorYInc));						g.drawLine(right - 4, newV, right - 1, newV);					}				}			}			// set the Y precision			// int numPlaces = 1;			int numPlaces = JOAFormulas.GetDisplayPrecision(mYInc);			// label the axes			Font font = new Font(JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_FONT, JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_STYLE,			    JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_SIZE);			g.setFont(font);			FontMetrics fm = Toolkit.getDefaultToolkit().getFontMetrics(font);			double vOrigin;			double myVal;			if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {				vOrigin = mOvlInterpMax;			}			else {				vOrigin = mOvlInterpMin;			}			String sTemp = null;			sTemp = JOAFormulas.returnSpacePaddedString(JOAFormulas.formatDouble(String.valueOf(vOrigin			    + (majorYTicks * mYInc)), numPlaces, false), 4);			int len = fm.stringWidth(sTemp);			int fh = JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_SIZE;			for (int i = 0; i <= majorYTicks; i++) {				if (i == 0 || i == majorYTicks) {					if (mFileViewer.mAllProperties[surfVarNum].isReverseY()) {						myVal = vOrigin - (i * mYInc);					}					else {						myVal = vOrigin + (i * mYInc);					}					if (myVal == -0.0) {						myVal = 0.0;					}					int v = (int)(hTopMargin + (i * yInc));					if (numPlaces > 0) {						sTemp = JOAFormulas.returnSpacePaddedString(JOAFormulas.formatDouble(String.valueOf(myVal), numPlaces,						    false), 4);					}					else {						sTemp = JOAFormulas.returnSpacePaddedString((int)myVal, 4);					}					g.setColor(JOAConstants.DEFAULT_CONTOUR_XSEC_VALUE_COLOR);					g.drawString(sTemp, right - len - 10, v + fh / 2 - 2);					g.setColor(Color.black);				}			}			// add variable label			font = new Font(JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_FONT, JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_STYLE,			    JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_SIZE);			g.setFont(font);			fm = Toolkit.getDefaultToolkit().getFontMetrics(font);			int width = 0;			String axisLabel = null;			if (mOverlayInterpolation.getParam().getVarUnits() != null			    && mOverlayInterpolation.getParam().getVarUnits().length() > 0) {				axisLabel = mOverlayInterpolation.getParam().getVarName() + " ("				    + mOverlayInterpolation.getParam().getVarUnits() + ")";				width = fm.stringWidth(axisLabel);			}			else {				axisLabel = mInterpolation.getParam().getVarName();				width = fm.stringWidth(axisLabel);			}			JOAFormulas.drawStyledString(axisLabel, 20, this.getHeight() / 2 + width / 2, g, 90,			    JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_FONT, JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_SIZE,			    JOAConstants.DEFAULT_CONTOUR_XSEC_LABEL_STYLE, Color.red /*																																		 * JOAConstants.																																		 * DEFAULT_CONTOUR_XSEC_LABEL_COLOR																																		 */);		}		// OK Button		public void dialogDismissed(JDialog d) {			// get new max and min			mInterpMax = ((ConfigHXsec)d).getMax();			mInterpMin = ((ConfigHXsec)d).getMin();			mInterpInc = ((ConfigHXsec)d).getInc();			obsMarker = null;			obsMarker2 = null;			scaleAxes();			if (mOverlayContours) {				mOvlInterpMax = ((ConfigHXsec)d).getOvlMax();				mOvlInterpMin = ((ConfigHXsec)d).getOvlMin();				mOvlInterpInc = ((ConfigHXsec)d).getOvlInc();				obsOvlMarker = null;				obsOvlMarker2 = null;				scaleOvlAxes();			}			this.scaleAxes();			this.paintComponent(this.getGraphics());		}		// Cancel button		public void dialogCancelled(JDialog d) {			mInterpMax = ((ConfigHXsec)d).getOrigMax();			mInterpMin = ((ConfigHXsec)d).getOrigMin();			mInterpInc = ((ConfigHXsec)d).getOrigInc();			obsMarker = null;			obsMarker2 = null;			scaleAxes();			if (mOverlayContours) {				mOvlInterpMax = ((ConfigHXsec)d).getOvlOrigMax();				mOvlInterpMin = ((ConfigHXsec)d).getOvlOrigMin();				mOvlInterpInc = ((ConfigHXsec)d).getOvlOrigInc();				obsOvlMarker = null;				obsOvlMarker2 = null;				scaleOvlAxes();			}			this.paintComponent(this.getGraphics());		}		// something other than the OK button		public void dialogDismissedTwo(JDialog d) {		}		public void dialogApplyTwo(Object d) {		}		// Apply button, OK w/o dismissing the dialog		public void dialogApply(JDialog d) {			mInterpMax = ((ConfigHXsec)d).getMax();			mInterpMin = ((ConfigHXsec)d).getMin();			mInterpInc = ((ConfigHXsec)d).getInc();			obsMarker = null;			obsMarker2 = null;			scaleAxes();			if (mOverlayContours) {				mOvlInterpMax = ((ConfigHXsec)d).getOvlMax();				mOvlInterpMin = ((ConfigHXsec)d).getOvlMin();				mOvlInterpInc = ((ConfigHXsec)d).getOvlInc();				obsOvlMarker = null;				obsOvlMarker2 = null;				scaleOvlAxes();			}			this.paintComponent(this.getGraphics());		}	}	private class LevelDataPanel extends JPanel {		int surfVarNum;		double[][] interpValues;		NewInterpolationSurface surface;		JOAVariable interpVar = mInterpolation.getParam();		double[] surfaceValues;		double[] contourValues;		int lLeftMargin = 20;		int lBottomMargin = 5;		int lTopMargin = 5;		int lRightMargin = 10;		int panelWidth = 0;		int panelHeight = 0;		String initialPadding = null;		Color mBGColor;		public LevelDataPanel(int inWidth, int inHeight) {			super(false);			this.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);			panelWidth = inWidth;			panelHeight = inHeight;			if (JOAConstants.ISMAC) {				this.setFont(new Font("Helvetica", Font.BOLD, 12));			}			init();		}		public void drawContents(Graphics gin) {			Graphics2D g = (Graphics2D)gin;			g.setColor(Color.black);			OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.currElement();			Section sec = (Section)of.mSections.currElement();			Station stn = (Station)sec.mStations.currElement();			String l1 = new String(initialPadding + "Section: "			    + JOAFormulas.returnMiddleTruncatedString(sec.mSectionDescription, 15));			String l1a = initialPadding + "Stn: " + stn.mStnNum + " " + "-------";			if (stn.getDate() != null) {				l1a = new String(initialPadding + "Stn: " + stn.mStnNum + " "				    + stn.getDate().toString(JOAConstants.DEFAULT_DATE_FORMAT));			}			String l2 = new String(initialPadding + "Loc: " + JOAFormulas.formatLon(stn.getLon(), true) + ","			    + JOAFormulas.formatLat(stn.getLat(), true));			if (mOverlayContours && stn.getNearestOverlayStn() != null) {				l2 += " (" + JOAFormulas.formatLon(stn.getNearestOverlayStn().getLon(), true) + ","				    + JOAFormulas.formatLat(stn.getNearestOverlayStn().getLat(), true) + ")";			}			String l4 = new String(initialPadding + "Level: " + mCurrLevel);			double val = surfaceValues[mCurrLevel];			String l5 = new String(initialPadding + mFileViewer.mAllProperties[surfVarNum].getVarLabel() + ": "			    + JOAFormulas.formatDouble(String.valueOf(val), 3, true) + " ("			    + mFileViewer.mAllProperties[surfVarNum].getUnits() + ")");			int interpCol = stn.mOrdinal - 1;			val = interpValues[mCurrLevel][interpCol];			String l6 = new String(initialPadding + interpVar.getVarName() + ": "			    + JOAFormulas.formatDouble(String.valueOf(val), 3, true) + " (" + interpVar.getVarUnits() + ")");			String l7 = "";			if (mOverlayContours && stn.getNearestOverlayStn() != null) {				int ovlInterpCol = stn.getNearestOverlayStn().mOrdinal - 1;				val = interpOvlValues[mCurrLevel][ovlInterpCol];				l7 = new String(initialPadding + mOverlayInterpolation.getParam().getVarName() + ": "				    + JOAFormulas.formatDouble(String.valueOf(val), 3, true) + " ("				    + mOverlayInterpolation.getParam().getVarUnits() + ")");			}			g.drawString(l1, lLeftMargin, 1 * 14);			g.drawString(l1a, lLeftMargin, 2 * 14);			g.drawString(l2, lLeftMargin, 3 * 14);			g.drawString(l4, lLeftMargin, 4 * 14);			g.drawString(l5, lLeftMargin, 5 * 14);			g.drawString(l6, lLeftMargin, 6 * 14);			g.setColor(Color.red);			g.drawString(l7, lLeftMargin, 7 * 14);			g.setColor(Color.black);		}		public void paintComponent(Graphics g) {			super.paintComponent(g);			lLeftMargin = 20;			drawContents(g);		}		public void init() {			// initialize some variables			if (panelWidth <= 150) {				initialPadding = new String("   ");			}			else {				initialPadding = new String(" ");			}			surfVarNum = mInterpolation.getSurfParamNum();			interpValues = mInterpolation.getValues();			surface = mInterpolation.getSurface();			surfaceValues = surface.getValues();			if (mOverlayContours) {				interpOvlValues = mOverlayInterpolation.getValues();			}		}		public void setNewBGColor(Color bg) {			mBGColor = bg;			this.setBackground(mBGColor);		}		public Dimension getPreferredSize() {			return new Dimension(panelWidth, panelHeight);		}		public void obsChanged(Station sh) {			// display the current station			setNewStn(sh);		}		public void setStn(Section sec, Station stn) {			Graphics g = getGraphics();			paintComponent(g);		}		public void setNewStn(Station stn) {			Graphics g = getGraphics();			paintComponent(g);		}	}	private class ColorBarDisplay extends JPanel implements DialogClient, ActionListener {		int cLeftMargin = 0;		int cBottomMargin = 25;		int cTopMargin = 20;		int cRightMargin = 10;		int panelWidth = 0;		int panelHeight = 0;		ObsMarker mObsMarker = null;		double[][] interpValues;		private JPopupMenu mPopupMenu = null;		private Image mOffScreen = null;		public ColorBarDisplay(int width, int height) {			if (mThis.mColorBar == null) { return; }			panelWidth = width;			panelHeight = height;			init();		}		public int getColorBarWidth(Graphics2D g) {			g.setFont(new Font(JOAConstants.DEFAULT_COLORBAR_LABEL_FONT, JOAConstants.DEFAULT_COLORBAR_LABEL_STYLE,			    JOAConstants.DEFAULT_COLORBAR_LABEL_SIZE));			FontMetrics fm = g.getFontMetrics();			int numColors = mColorBar.getNumLevels();			// draw the color ramp and labels			double base = mColorBar.getBaseLevel();			double end = mColorBar.getEndLevel();			double diff = Math.abs(end - base);			int numPlaces = 2;			if (diff < 10) {				numPlaces = 3;			}			else if (diff >= 10 && diff < 100) {				numPlaces = 2;			}			else if (diff >= 100 && diff < 1000) {				numPlaces = 1;			}			else if (diff >= 1000) {				numPlaces = 1;			}			int maxLabelH = 0;			for (int i = 0; i < numColors; i++) {				String sTemp = mColorBar.getFormattedValue(i, numPlaces, true);				int strWidth = fm.stringWidth(sTemp);				maxLabelH = strWidth > maxLabelH ? strWidth : maxLabelH;			}			return maxLabelH + 45;		}		public void showConfigDialog() {			// show configuration dialog			EditColorbar ecb = new EditColorbar(mFrame, mFileViewer, this, mColorBar, true);			ecb.pack();			ecb.setVisible(true);		}		// OK Button		public void dialogDismissed(JDialog d) {			// get a new colorbar from color bar editor			mObsMarker = null;			paintComponent(this.getGraphics());			NewColorBar ncb = ((EditColorbar)d).getColorBar();			if (ncb == null) {				System.out.println("got null cb");			}			mThis.mColorBar = new NewColorBar(ncb);			mThis.mPlotSpec.setColorBar(mThis.mColorBar);			int width = mThis.mContPlot.getSize().width;			int height = mThis.mContPlot.getSize().height;			mThis.mContPlot.setSize(width, height + 1);			mThis.mContPlot.setSize(width, height);			width = this.getSize().width;			height = this.getSize().height;			this.setSize(width, height + 1);			this.setSize(width, height);		}		// Cancel button		public void dialogCancelled(JDialog d) {		}		// something other than the OK button		public void dialogDismissedTwo(JDialog d) {		}		public void dialogApplyTwo(Object d) {		}		// Apply button, OK w/o dismissing the dialog		public void dialogApply(JDialog d) {			mObsMarker = null;			paintComponent(this.getGraphics());			NewColorBar ncb = ((EditColorbar)d).getColorBar();			mThis.mColorBar = new NewColorBar(ncb);			mThis.mPlotSpec.setColorBar(mThis.mColorBar);			int width = mThis.mContPlot.getSize().width;			int height = mThis.mContPlot.getSize().height;			mThis.mContPlot.setSize(width, height + 1);			mThis.mContPlot.setSize(width, height);			width = this.getSize().width;			height = this.getSize().height;			this.setSize(width, height + 1);			this.setSize(width, height);		}		public class cbMouseHandler extends MouseAdapter {			public void mouseClicked(MouseEvent me) {				if (mWindowIsLocked) { return; }				if (me.getClickCount() == 2) {					// show configuration dialog					showConfigDialog();				}			}			public void mouseReleased(MouseEvent me) {				if (mWindowIsLocked) { return; }				super.mouseReleased(me);				if (me.isPopupTrigger()) {					createPopup(me.getPoint());				}			}			public void mousePressed(MouseEvent me) {				if (mWindowIsLocked) { return; }				super.mousePressed(me);				if (me.isPopupTrigger()) {					createPopup(me.getPoint());				}			}		}		public void createPopup(Point point) {			ResourceBundle b = ResourceBundle.getBundle("javaoceanatlas.resources.JOAResources");			mPopupMenu = new JPopupMenu();			JMenuItem openContextualMenu = new JMenuItem(b.getString("kProperties"));			openContextualMenu.setActionCommand("opencontextual");			openContextualMenu.addActionListener(this);			mPopupMenu.add(openContextualMenu);			mPopupMenu.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));			mPopupMenu.show(this, point.x, point.y);		}		public void actionPerformed(ActionEvent e) {			String cmd = e.getActionCommand();			if (cmd.equals("opencontextual")) {				showConfigDialog();			}		}		public void init() {			this.setBackground(JOAConstants.DEFAULT_FRAME_COLOR);			interpValues = mInterpolation.getValues();			if (mAxes && !mCrossSections) {				cBottomMargin = 25;				cTopMargin = 25;			}			else if (!mAxes && !mCrossSections) {				cBottomMargin = 0;				cTopMargin = 40;			}			addMouseListener(new cbMouseHandler());		}		public void invalidate() {			try {				super.invalidate();				if (mOffScreen != null) {					mOffScreen = null;				}				if (mObsMarker != null) {					mObsMarker = null;				}			}			catch (Exception e) {				e.printStackTrace();			}		}		public void paintComponent(Graphics gin) {			Graphics2D g = (Graphics2D)gin;			if (mOffScreen == null) {				mOffScreen = createImage(getSize().width, getSize().height);				Graphics2D og = (Graphics2D)mOffScreen.getGraphics();				// super.paintComponent(og);				drawSwatches(og);				g.drawImage(mOffScreen, 0, 0, null);				og.dispose();			}			else {				g.drawImage(mOffScreen, 0, 0, null);			}			if (mObsMarker != null && !mWindowIsLocked) {				mObsMarker.drawMarker(g, false);			}		}		public void obsChanged(Station sh) {			// display the current observation			int numColors = mColorBar.getNumLevels();			int top = cTopMargin;			int bottom = this.getSize().height - cBottomMargin;			int pixelsPerBand = (bottom - top - 2) / numColors;			int bandTop = 0;			int bandBottom = 0;			int interpCol = sh.mOrdinal - 1;			double val = JOAConstants.MISSINGVALUE;			try {				val = interpValues[mCurrLevel][interpCol];			}			catch (Exception ex) {			}			int index = mColorBar.getColorIndex(val);			if (val != JOAConstants.MISSINGVALUE) {				int xx = cLeftMargin + 5;				bandTop = top + (index - 1) * pixelsPerBand;				bandBottom = bandTop + pixelsPerBand;				int yy = bandTop + (bandBottom - bandTop) / 2;				if (mObsMarker == null) {					mObsMarker = new ObsMarker(0, 0, 10);					mObsMarker.setSymbol(JOAConstants.SYMBOL_RIGHT_ARROW_SYMBOL);				}				mObsMarker.setNewPos(xx, yy);				// Graphics g = getGraphics();				this.paintImmediately(0, 0, 2000, 2000);			}			else {				if (mObsMarker == null) {					mObsMarker = new ObsMarker(0, 0, 10);					mObsMarker.setSymbol(JOAConstants.SYMBOL_RIGHT_ARROW_SYMBOL);				}				mObsMarker.setNewPos(-5, 0);				// Graphics g = getGraphics();				this.paintImmediately(0, 0, 2000, 2000);			}		}		public void drawSwatches(Graphics2D g) {			int numColors = mColorBar.getNumLevels();			int left = cLeftMargin + 10;			int top = cTopMargin;			int bottom = this.getSize().height - cBottomMargin;			int pixelsPerBand = (bottom - top - 2) / numColors;			int bandTop = 0;			int bandBottom = 0;			// draw the color ramp and labels			double base = mColorBar.getBaseLevel();			double end = mColorBar.getEndLevel();			double diff = Math.abs(end - base);			int numPlaces = 2;			if (diff < 10) {				numPlaces = 3;			}			else if (diff >= 10 && diff < 100) {				numPlaces = 2;			}			else if (diff >= 100 && diff < 1000) {				numPlaces = 1;			}			else if (diff >= 1000) {				numPlaces = 1;			}			int labelInc = 0;			if (numColors <= 16) {				labelInc = 1;			}			else if (numColors > 16 && numColors <= 32) {				labelInc = 2;			}			else if (numColors > 32 && numColors <= 48) {				labelInc = 3;			}			else if (numColors > 48 && numColors <= 64) {				labelInc = 4;			}			// g.drawRect(left, top, right-left, bottom-top);			// set the font			g.setFont(new Font(JOAConstants.DEFAULT_COLORBAR_LABEL_FONT, JOAConstants.DEFAULT_COLORBAR_LABEL_STYLE,			    JOAConstants.DEFAULT_COLORBAR_LABEL_SIZE));			for (int i = 0; i < numColors; i++) {				// swatch				bandTop = (int)(top + (i - 1) * pixelsPerBand);				bandBottom = (int)(bandTop + pixelsPerBand);				g.setColor(mColorBar.getColorValue(i));				g.fillRect(left, bandTop, left + 20, bandBottom - bandTop);				// label				g.setColor(Color.black);				if (i % labelInc == 0) {					double myVal = mColorBar.getDoubleValue(i);					String sTemp = JOAFormulas.formatDouble(String.valueOf(myVal), numPlaces, true);					g.drawString(sTemp, left + 35, bandBottom);				}			}			// initialize the spot			if (mObsMarker == null) {				numColors = mColorBar.getNumLevels();				bandTop = 0;				bandBottom = 0;				top = cTopMargin;				bottom = this.getSize().height - cBottomMargin;				pixelsPerBand = (bottom - top - 2) / numColors;				OpenDataFile of = (OpenDataFile)mFileViewer.mOpenFiles.currElement();				Section sech = (Section)of.mSections.currElement();				Station sh = (Station)sech.mStations.currElement();				// Broken with objective analysis				double val = mInterpolation.getClosestValue(mCurrLevel, sh);				int index = mColorBar.getColorIndex(val);				mObsMarker = new ObsMarker(0, 0, 10);				mObsMarker.setSymbol(JOAConstants.SYMBOL_RIGHT_ARROW_SYMBOL);				int xx = cLeftMargin + 5;				if (val != JOAConstants.MISSINGVALUE) {					bandTop = top + (index - 1) * pixelsPerBand;					bandBottom = bandTop + pixelsPerBand;					int yy = bandTop + (bandBottom - bandTop) / 2;					mObsMarker.setNewPos(xx, yy);				}				else {					mObsMarker.setNewPos(-5, 0);				}			}		}		public Dimension getPreferredSize() {			return new Dimension(panelWidth, panelHeight);		}		public Insets getInsets() {			return new Insets(0, 0, 0, 0);		}	}	public RubberbandPanel getPanel() {		return mContPlot;	}}