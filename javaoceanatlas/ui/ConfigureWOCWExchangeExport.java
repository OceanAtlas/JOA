/* * $Id: ConfigureSSExport.java,v 1.4 2005/09/07 18:49:29 oz Exp $ * */package javaoceanatlas.ui;import javax.swing.*;import javax.swing.event.*;import java.awt.*;import java.awt.event.*;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.*;import java.util.Timer;import java.io.*;import javax.swing.border.*;import javaoceanatlas.classicdatamodel.*;import javaoceanatlas.events.*;import javaoceanatlas.ui.widgets.*;import javaoceanatlas.utility.*;import javaoceanatlas.resources.*;import gov.noaa.pmel.util.GeoDate;import gov.noaa.pmel.swing.NPixelBorder;@SuppressWarnings("serial")public class ConfigureWOCWExchangeExport extends JOAJDialog implements ActionListener, ButtonMaintainer, ItemListener,    DataAddedListener, DocumentListener, ListSelectionListener {	protected FileViewer mFileViewer;	protected JOAJButton mOKBtn = null;	protected JOAJButton mCancelButton = null;	protected JOAJList mStnList = null;	protected boolean mIgnore = false;	protected int mTotalStns = 0;	private Timer timer = new Timer();	protected SmallIconButton checkAll = null;	protected SmallIconButton checkNone = null;	protected JTextArea mFileComments = null;	protected JTextField mDateStamp = null;	protected JTextArea mPreview = null;	private boolean alreadyAsked1 = false;	private boolean alreadyAsked2 = false;	private JCheckBox mPadFields;  protected JOAJTextField mCustomMissingFld;  protected JOAJRadioButton mJOADefaultMissing;  protected JOAJRadioButton mWOCEDefaultMissing;  protected JOAJRadioButton mEPICDefaultMissing;	public ConfigureWOCWExchangeExport(FileViewer fv) {		super(fv, "Export WOCE Exchange File", false);		mFileViewer = fv;		this.init();	}	private void buildStnList() {		Vector<String> listData = new Vector<String>();		for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {			OpenDataFile of = (OpenDataFile) mFileViewer.mOpenFiles.elementAt(fc);			for (int sec = 0; sec < of.mNumSections; sec++) {				Section sech = (Section) of.mSections.elementAt(sec);				for (int stc = 0; stc < sech.mStations.size(); stc++) {					Station sh = (Station) sech.mStations.elementAt(stc);					if (sh.mUseStn) {						listData.addElement(sech.mSectionDescription + ":" + sh.mStnNum + "(" + JOAFormulas.formatLat(sh.mLat)						    + " " + JOAFormulas.formatLon(sh.mLon) + ", " + JOAFormulas.formatDate(sh, false) + ")");						mTotalStns++;					}				}			}		}		if (mStnList == null) {			mStnList = new JOAJList(listData);		}		else {			mStnList.setListData(listData);			mStnList.invalidate();		}	}	public void init() {		ResourceBundle b = ResourceBundle.getBundle("javaoceanatlas.resources.JOAResources");		// fill the stn list		buildStnList();		Container contents = this.getContentPane();		this.getContentPane().setLayout(new BorderLayout(0, 0));		JPanel upperContentsPanel = new JPanel();		upperContentsPanel.setLayout(new BorderLayout(5, 0));		JPanel stnSelPanel = new JPanel();		stnSelPanel.setLayout(new BorderLayout(5, 0));		// station selection		JPanel allNoneCont = new JPanel();		allNoneCont.setLayout(new GridLayout(2, 1, 0, 5));		checkAll = new SmallIconButton(new ImageIcon(getClass().getResource("images/checkall.gif")));		allNoneCont.add(checkAll);		checkNone = new SmallIconButton(new ImageIcon(getClass().getResource("images/checknone.gif")));		allNoneCont.add(checkNone);		checkAll.addActionListener(this);		checkNone.addActionListener(this);		checkAll.setActionCommand("all");		checkNone.setActionCommand("none");		JPanel cont1 = new JPanel();		cont1.setLayout(new BorderLayout(0, 0));		cont1.add("North", allNoneCont);		stnSelPanel.add("East", cont1);				checkAll.setToolTipText("Select all stations in the list to export");		checkNone.setToolTipText("Remove selected stations from export");		mStnList.getSelectionModel().setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);		mStnList.setPrototypeCellValue("Atlantic 11 S 210 (11.25 S 180.45 W, 4/1/1999");		mStnList.setVisibleRowCount(6);		JScrollPane listScroller = new JScrollPane(mStnList);		stnSelPanel.add(new TenPixelBorder(listScroller, 0, 5, 0, 0), "Center");		TitledBorder tb = BorderFactory.createTitledBorder(b.getString("kStationSelection"));		if (JOAConstants.ISMAC) {			// tb.setTitleFont(new Font("Helvetica", Font.PLAIN, 11));		}		stnSelPanel.setBorder(tb);		upperContentsPanel.add(new TenPixelBorder(stnSelPanel, 5, 5, 0, 0), "Center");		JPanel commentsPanel = new JPanel();		commentsPanel.setLayout(new ColumnLayout(Orientation.LEFT, Orientation.CENTER));		JPanel stampPanel = new JPanel();		stampPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 5, 5));		stampPanel.add(new JLabel("Date stamp:"));		mDateStamp = new JTextField(15);		stampPanel.add(mDateStamp);		commentsPanel.add(stampPanel);		mDateStamp.getDocument().addDocumentListener(this);		commentsPanel.add(new JLabel("Original Comments:"));		mFileComments = new JTextArea(5, 40);		JScrollPane commentsScroller = new JScrollPane(mFileComments);		commentsPanel.add(commentsScroller);		DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");		Date date = new Date();		mFileComments.append("# Exported from JOA (" + VersionInfo.getVersion() + " " + VersionInfo.getVersionShortDate()		    + ") on " + dateFormat.format(date) + "\n");		for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {			OpenDataFile of = (OpenDataFile) mFileViewer.mOpenFiles.elementAt(fc);			mFileComments.append(of.getComments());		}		mFileComments.getDocument().addDocumentListener(this);		commentsPanel.add(new JLabel("Header Preview:"));		mPreview = new JTextArea(10, 40);		mPreview.setEditable(false);		JScrollPane previewScroller = new JScrollPane(mPreview);		commentsPanel.add(previewScroller);    JPanel missingValuePanel = new JPanel();    missingValuePanel.setLayout(new ColumnLayout(Orientation.LEFT, Orientation.TOP, 0));    mJOADefaultMissing = new JOAJRadioButton(b.getString("kJOADefaultMissing"));    mWOCEDefaultMissing = new JOAJRadioButton(b.getString("kWOCEDefaultMissing"), true);    mEPICDefaultMissing = new JOAJRadioButton(b.getString("kEPICDefaultMissing"));    ButtonGroup bg = new ButtonGroup();    bg.add(mJOADefaultMissing);    bg.add(mWOCEDefaultMissing);    bg.add(mEPICDefaultMissing);    missingValuePanel.add(mWOCEDefaultMissing);    missingValuePanel.add(mJOADefaultMissing);    missingValuePanel.add(mEPICDefaultMissing);    tb = BorderFactory.createTitledBorder(b.getString("kMissingValueSelection"));    missingValuePanel.setBorder(tb);		commentsPanel.add(missingValuePanel);		mPadFields = new JCheckBox(b.getString("kPadFieldsWithBlanks"), true);		commentsPanel.add(mPadFields);		upperContentsPanel.add(BorderLayout.SOUTH, new NPixelBorder(commentsPanel, 0, 10, 0, 10));		// lower panel		mOKBtn = new JOAJButton(b.getString("kOK"));		mOKBtn.setActionCommand("ok");		this.getRootPane().setDefaultButton(mOKBtn);		mCancelButton = new JOAJButton(b.getString("kCancel"));		mCancelButton.setActionCommand("cancel");		JPanel dlgBtnsInset = new JPanel();		JPanel dlgBtnsPanel = new JPanel();		dlgBtnsInset.setLayout(new FlowLayout(FlowLayout.CENTER, 20, 1));		dlgBtnsPanel.setLayout(new GridLayout(1, 4, 15, 1));		if (JOAConstants.ISMAC) {			dlgBtnsPanel.add(mCancelButton);			dlgBtnsPanel.add(mOKBtn);		}		else {			dlgBtnsPanel.add(mOKBtn);			dlgBtnsPanel.add(mCancelButton);		}		dlgBtnsInset.add(dlgBtnsPanel);		mOKBtn.addActionListener(this);		mCancelButton.addActionListener(this);		contents.add(new TenPixelBorder(upperContentsPanel, 5, 5, 5, 5), "Center");		contents.add(new TenPixelBorder(dlgBtnsInset, 5, 5, 5, 5), "South");		this.pack();		mFileViewer.addDataAddedListener(this);		runTimer();		// show dialog at center of screen		Rectangle dBounds = this.getBounds();		Dimension sd = Toolkit.getDefaultToolkit().getScreenSize();		int x = sd.width / 2 - dBounds.width / 2;		int y = sd.height / 2 - dBounds.height / 2;		this.setLocation(x, y);		mStnList.addListSelectionListener(this);	}	public void runTimer() {		TimerTask task = new TimerTask() {			public void run() {				maintainButtons();			}		};		timer.schedule(task, 0, 1000);	}	public void dataAdded(DataAddedEvent evt) {		// redo the station list		buildStnList();	}	public void changedUpdate(DocumentEvent e) {		updatePreview();	}	public void insertUpdate(DocumentEvent e) {		updatePreview();	}	public void removeUpdate(DocumentEvent e) {		updatePreview();	}	public void itemStateChanged(ItemEvent evt) {	}	public void valueChanged(ListSelectionEvent e) {	}	public void actionPerformed(ActionEvent e) {		String cmd = e.getActionCommand();		if (cmd.equals("cancel")) {			timer.cancel();			this.dispose();		}		else if (cmd.equals("ok")) {			if (doSave(mPadFields.isSelected())) {				timer.cancel();				this.dispose();			}		}		else if (cmd.equals("none")) {			checkNone.setSelected(false);			// unselect all selected stations			mStnList.clearSelection();			// updatePreview();		}		else if (cmd.equals("all")) {			checkAll.setSelected(false);			// select all stations in list			mStnList.setSelectionInterval(0, mTotalStns - 1);			// updatePreview();		}	}	private boolean doSave(boolean padFlds) {		boolean isCTD = false;		boolean isBottle = false;		boolean[] isObsQual = null;		boolean hasObsQual = false;		int masterQCStd = JOAConstants.NONE_QC_STD;		boolean convertQC = true;		int convertQCto = JOAConstants.WOCE_QC_STD;		try {			isObsQual = new boolean[mFileViewer.gNumProperties];			int qcStdCnt = 0;			for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {				OpenDataFile of = (OpenDataFile) mFileViewer.mOpenFiles.elementAt(fc);				for (int sec = 0; sec < of.mNumSections; sec++) {					Section sech = (Section) of.mSections.elementAt(sec);					// get the qc standard					int qcStd = sech.getQCStandard();					if (qcStd != masterQCStd) {						masterQCStd = qcStd;						qcStdCnt++;					}					if (sech.mNumCasts == 0) {						continue;					}					for (int stc = 0; stc < sech.mStations.size(); stc++) {						Station sh = (Station) sech.mStations.elementAt(stc);						if (!sh.mUseStn) {							continue;						}						if (sh.getType().toUpperCase().indexOf("CTD") >= 0) {							isCTD = true;						}						if (sh.getType().toUpperCase().indexOf("BOT") >= 0) {							isBottle = true;						}						for (int bb = 0; bb < sh.mNumBottles; bb++) {							Bottle bh = (Bottle) sh.mBottles.elementAt(bb);							for (int i = 0; i < mFileViewer.gNumProperties && !isObsQual[i]; i++) {								if (mFileViewer.mAllProperties[i].getVarLabel().equalsIgnoreCase("PRES")) {									continue;								}								int vPos = sech.getVarPos(mFileViewer.mAllProperties[i].getVarLabel(), false);								if (vPos == -1) {									continue;								}								if (bh.mQualityFlags[vPos] != JOAConstants.MISSINGVALUE) {									isObsQual[i] = true;									hasObsQual = true;								}							}						}					}				}			}			boolean cancelSave = false;			if (isCTD && isBottle) {				// multiple data types in this data				Object[] options = { "OK" };				JFrame ofr = new JFrame("Export Exchange Error");				Toolkit.getDefaultToolkit().beep();				JOptionPane.showOptionDialog(ofr, "This data set has multiple data types. " + "\n"				    + "This version of JOA can only export WOCE Exchange files for datasets of a single type.",				    "Export Exchange Error", JOptionPane.DEFAULT_OPTION, JOptionPane.QUESTION_MESSAGE, null, options,				    options[0]);				cancelSave = true;			}			if (cancelSave) { return false; }			convertQC = true;			convertQCto = JOAConstants.WOCE_QC_STD;			if (hasObsQual && qcStdCnt >= 2) {				// multiple QC standards in this data				Object[] options = { "OK", "Cancel" };				JFrame ofr = new JFrame("Export Exchange Options");				Toolkit.getDefaultToolkit().beep();				int response = JOptionPane.showOptionDialog(ofr, "This data set has multiple quality code standards. " + "\n"				    + "IGOSS (WMO/Argo) quality codes will be converted to WOCE equivalents.", "Export Exchange Options",				    JOptionPane.DEFAULT_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]);				switch (response) {					case 2:						cancelSave = true;				}			}			if (cancelSave) { return false; }		}		catch (Exception ex) {		}		if (isCTD) {			// create a progress dialog			ProgressDialog progress = new ProgressDialog(mFileViewer, "Exporting Exchange Data...", Color.blue, Color.white);			progress.setVisible(true);			boolean[] stnKeepList = new boolean[mTotalStns];			int[] stnList = new int[mStnList.getSelectedIndices().length];			stnList = mStnList.getSelectedIndices();			for (int i = 0; i < mTotalStns; i++) {				stnKeepList[i] = false;			}			for (int i = 0; i < stnList.length; i++) {				stnKeepList[stnList[i]] = true;			}			Frame fr = new Frame();			String directory = System.getProperty("user.dir");			FileDialog f = new FileDialog(fr, "Select directory for saved exchange files:", FileDialog.SAVE);			f.setDirectory(directory);			f.setFile("Select this directory");			Rectangle dBounds = f.getBounds();			Dimension sd = Toolkit.getDefaultToolkit().getScreenSize();			int x = sd.width / 2 - dBounds.width / 2;			int y = sd.height / 2 - dBounds.height / 2;			f.setLocation(x, y);			f.setVisible(true);			directory = f.getDirectory();			f.dispose();			File outFile = null;			int stnCount = 0;			if (directory != null && f.getFile() != null) {				for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {					OpenDataFile of = (OpenDataFile) mFileViewer.mOpenFiles.elementAt(fc);					for (int s = 0; s < of.getNumSections(); s++) {						Section sech = (Section) of.mSections.elementAt(s);						for (int stn = 0; stn < sech.mNumCasts; stn++) {							Station sh = (Station) sech.mStations.elementAt(stn);							if (!sh.mUseStn || !stnKeepList[stnCount++]) {								continue;							}							outFile = new File(directory, JOAFormulas.getCTDExchangeFilename(of.getName()));//							exportCTDExchange(sh, sech.getExpoCode(), sech.getID(), outFile, isObsQual, hasObsQual, masterQCStd,//							    convertQC, convertQCto, padFlds);						}					}					try {						JOAConstants.LogFileStream.writeBytes("Saved CTD Exchange file: " + outFile + "\n");						JOAConstants.LogFileStream.flush();					}					catch (Exception ex) {					}				}			}		}		else {      // get the missing value value      double missingVal = -99;      if (mJOADefaultMissing.isSelected()) {      	missingVal = -99;      }      else if (mWOCEDefaultMissing.isSelected()) {      	missingVal = -999.0;      }      else if (mEPICDefaultMissing.isSelected()) {      	missingVal = 1e35;      }			exportBottleExchange(isObsQual, hasObsQual, masterQCStd, convertQC, convertQCto, padFlds, missingVal);		}		return true;	}	public void maintainButtons() {		if (mStnList != null && mStnList.getSelectedIndex() >= 0) {			mOKBtn.setEnabled(true);		}		else {			mOKBtn.setEnabled(false);		}	}	public void updatePreview() {		boolean isCTD = false;		boolean isBottle = false;		boolean[] isObsQual = null;		boolean hasObsQual = false;		int masterQCStd = JOAConstants.NONE_QC_STD;		boolean convertQC = true;		int convertQCto = JOAConstants.WOCE_QC_STD;		try {			isObsQual = new boolean[mFileViewer.gNumProperties];			int qcStdCnt = 0;			for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {				OpenDataFile of = (OpenDataFile) mFileViewer.mOpenFiles.elementAt(fc);				for (int sec = 0; sec < of.mNumSections; sec++) {					Section sech = (Section) of.mSections.elementAt(sec);					// get the qc standard					int qcStd = sech.getQCStandard();					if (qcStd != masterQCStd) {						masterQCStd = qcStd;						qcStdCnt++;					}					if (sech.mNumCasts == 0) {						continue;					}					for (int stc = 0; stc < sech.mStations.size(); stc++) {						Station sh = (Station) sech.mStations.elementAt(stc);						if (!sh.mUseStn) {							continue;						}						if (sh.getType().toUpperCase().indexOf("CTD") >= 0) {							isCTD = true;						}						if (sh.getType().toUpperCase().indexOf("BOT") >= 0) {							isBottle = true;						}						for (int bb = 0; bb < sh.mNumBottles; bb++) {							Bottle bh = (Bottle) sh.mBottles.elementAt(bb);							for (int i = 0; i < mFileViewer.gNumProperties && !isObsQual[i]; i++) {								if (mFileViewer.mAllProperties[i].getVarLabel().equalsIgnoreCase("PRES")) {									continue;								}								int vPos = sech.getVarPos(mFileViewer.mAllProperties[i].getVarLabel(), false);								if (vPos == -1) {									continue;								}								if (bh.mQualityFlags[vPos] != JOAConstants.MISSINGVALUE) {									isObsQual[i] = true;									hasObsQual = true;								}							}						}					}				}			}			if (!alreadyAsked1 && isCTD && isBottle) {				// multiple data types in this data				Object[] options = { "OK" };				JFrame ofr = new JFrame("Export Exchange Error");				Toolkit.getDefaultToolkit().beep();				JOptionPane.showOptionDialog(ofr, "This data set has multiple data types. " + "\n"				    + "This version of JOA can only export WOCE Exchange files for datasets of a single type.",				    "Export Exchange Error", JOptionPane.DEFAULT_OPTION, JOptionPane.QUESTION_MESSAGE, null, options,				    options[0]);				alreadyAsked1 = true;			}			convertQC = true;			convertQCto = JOAConstants.WOCE_QC_STD;			if (!alreadyAsked2 && hasObsQual && qcStdCnt >= 2) {				// multiple QC standards in this data				Object[] options = { "OK" };				JFrame ofr = new JFrame("Export Exchange Options");				Toolkit.getDefaultToolkit().beep();				JOptionPane.showOptionDialog(ofr, "This data set has multiple quality code standards. " + "\n"				    + "IGOSS (WMO/Argo) quality codes will be converted to WOCE equivalents.", "Export Exchange Options",				    JOptionPane.DEFAULT_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]);				alreadyAsked2 = true;			}		}		catch (Exception ex) {		}		mPreview.setText("");		String delimStr = ",";		if (!isCTD) {			mPreview.append("BOTTLE,");		}		else {			mPreview.append("CTD,");		}		// has the user entered a file stamp field?		String ds = mDateStamp.getText();		if (ds != null && ds.length() > 0) {			mPreview.append(ds + "\n");		}		else {			Calendar calendar = Calendar.getInstance();			Date initDate = calendar.getTime();			GeoDate gd = new GeoDate(initDate.getTime());			mPreview.append(gd.toString("yyyymmdd") + "JOAExport" + "\n");		}		// write the comments, if any		String cmts = mFileComments.getText();		if (!cmts.endsWith("\n")) {			cmts += "\n";		}		if (cmts != null && cmts.length() > 0) {			mPreview.append(cmts);		}		// write the column headers */		mPreview.append("EXPOCODE,SECT_ID,STNNBR,CASTNO,SAMPNO,BTLNBR,BTLNBR_FLAG_W,DATE,TIME,LATITUDE,LONGITUDE,DEPTH,");		// compute the parameter headers		for (int p = 0; p < mFileViewer.gNumProperties; p++) {			// convert parameter to WOCE Convention			String currLabel = mFileViewer.mAllProperties[p].getVarLabel().trim();			String woceLabel = JOAFormulas.paramNameToWOCEName(currLabel);			mPreview.append(woceLabel);			if (isObsQual[p]) {				// parameter has a quality code				mPreview.append(delimStr);				if (masterQCStd == JOAConstants.IGOSS_QC_STD && !convertQC) {					mPreview.append(woceLabel + "_FLAG_I");				}				else if (masterQCStd == JOAConstants.WOCE_QC_STD && !convertQC) {					mPreview.append(woceLabel + "_FLAG_W");				}				else if (convertQC) {					if (convertQCto == JOAConstants.IGOSS_QC_STD) {						mPreview.append(woceLabel + "_FLAG_I");					}					else if (convertQCto == JOAConstants.WOCE_QC_STD) {						mPreview.append(woceLabel + "_FLAG_W");					}				}				if (p < mFileViewer.gNumProperties - 1) {					mPreview.append(delimStr);				}			}			else {				if (p < mFileViewer.gNumProperties - 1) {					mPreview.append(delimStr);				}			}		}		mPreview.append("\n");		// write out the units line		mPreview.append(",,,,,,,,,,,,");		for (int p = 0; p < mFileViewer.gNumProperties; p++) {			// write the units			mPreview.append(mFileViewer.mAllProperties[p].getUnits());			if (p < mFileViewer.gNumProperties - 1) {				mPreview.append(delimStr);				if (isObsQual[p]) {					mPreview.append(delimStr);				}			}		}		mPreview.append("\n");		mPreview.append("END_DATA" + "\n");		mPreview.select(0, 0);	}	public void exportBottleExchange(boolean[] isObsQual, boolean hasObsQual, int masterQCStd, boolean convertQC,	    int convertQCto, boolean padFields, double missingVal) {		String delimStr = ",";		boolean[] stnKeepList = null;		File outFile = null;		// export bottle exchange file		Frame fr = new Frame();		String directory = System.getProperty("user.dir");		FileDialog f = new FileDialog(fr, "Export exchange data as:", FileDialog.SAVE);		f.setDirectory(directory);		if (mFileViewer.mCurrOutFileName != null) {			f.setFile(mFileViewer.mCurrOutFileName + "_hy1.csv");		}		else {			f.setFile(mFileViewer.getTitle() + "_hy1.csv");		}		Rectangle dBounds = f.getBounds();		Dimension sd = Toolkit.getDefaultToolkit().getScreenSize();		int x = sd.width / 2 - dBounds.width / 2;		int y = sd.height / 2 - dBounds.height / 2;		f.setLocation(x, y);		f.setVisible(true);		directory = f.getDirectory();		f.dispose();		if (directory != null && f.getFile() != null) {			stnKeepList = new boolean[mTotalStns];			int[] stnList = new int[mStnList.getSelectedIndices().length];			stnList = mStnList.getSelectedIndices();			for (int i = 0; i < mTotalStns; i++) {				stnKeepList[i] = false;			}			for (int i = 0; i < stnList.length; i++) {				stnKeepList[stnList[i]] = true;			}			outFile = new File(directory, f.getFile());		}		// create a progress dialog		ProgressDialog progress = new ProgressDialog(mFileViewer, "Exporting Exchange Data...", Color.blue, Color.white);		progress.setVisible(true);		try {			FileOutputStream fos = new FileOutputStream(outFile);			BufferedOutputStream bos = new BufferedOutputStream(fos, 1000000);			DataOutputStream out = new DataOutputStream(bos);			/*			 * CTD, 20000718WHPOSIOSCD # # prototype WHPO 'ct1.csv' ctd file # S.			 * Diggs: 2000.07.18 # NUMBER_HEADERS = 10 EXPOCODE = 31WTTUNES_3			 * SECTION_ID = P16C STNNBR = 221 CAST = 1 DATE = 19910901 TIME = 0817			 * LATITUDE = -17.5053 LONGITUDE = -150.4812 BOTTOM = 3600			 * 			 * 			 * CTDPRS,CTDPRS_FLAG_W,CTDTMP,CTDTMP_FLAG_W,CTDSAL,CTDSAL_FLAG_W,CTDOXY,CTDOXY_FLAG_W			 * DBAR,,ITS-90,,PSS-78,,UMOL/KG,,			 */			/*			 * BOTTLE, 20000717WHOISIOSCD #prototype WHPO hy1.csv' bottle file			 * #S.Diggs: 2000.07.17			 * EXPOCODE,SECT_ID,DATE,TIME,LATITUDE,LONGITUDE,DEPTH,STNNBR,CASTNO,SAMPNO,BTLNBR,BTLNBR_FLAG_W,CTDPRS,CTDTMP,CTDSAL,CTDSAL_FLAG_W,CTDOXY,CTDOXY_FLAG_W,SALNTY,SALNTY_FLAG_W,OXYGEN,OXYGEN_FLAG_W,SILCAT,SILCAT_FLAG_W,NITRAT,NITRAT_FLAG_W,NITRIT,NITRIT_FLAG_W,PHSPHT,PHSPHT_FLAG_W,CFC-11,CFC-11_FLAG_W,CFC-12,CFC-12_FLAG_W,TCARBN,TCARBN_FLAG_W,ALKALI,ALKALI_FLAG_W,TRITUM,TRITUM_FLAG_W,DELHE3,DELHE3_FLAG_W,HELIUM,HELIUM_FLAG_W,DELC14,DELC14_FLAG_W,TRITER,DELHER,HELIER,C14ERR			 * ,,,,DEG-N,DEG-E,,,,,,,DBARS,ITS-90,PSS-78,,UMOL/KG,,PSS-78,,UMOL/KG,,UMOL/KG,,UMOL/KG,,UMOL/KG,,UMOL/KG,,PMOL/KG,,PMOL/KG,,UMOL/KG,,UMOL/KG,,TU,,PERCNT,,NMOL/KG,,/MILLE,,TU,PERCNT,NMOL/KG,/MILLE			 */						// write the header			out.writeBytes("BOTTLE,");			// has the user entered a file stamp field?			String ds = mDateStamp.getText();			if (ds != null && ds.length() > 0) {				out.writeBytes(ds + System.getProperty("line.separator"));			}			else {				Calendar calendar = Calendar.getInstance();				Date initDate = calendar.getTime();				GeoDate gd = new GeoDate(initDate.getTime());				out.writeBytes(gd.toString("yyyymmdd") + "JOAExport" + System.getProperty("line.separator"));			}			// write the comments, if any			String cmts = mFileComments.getText();			if (!(cmts.endsWith("\r") || cmts.endsWith("\n"))) {				cmts += System.getProperty("line.separator");			}			if (cmts != null && cmts.length() > 0) {				out.writeBytes(cmts);			}			// write the column headers */			out.writeBytes("EXPOCODE,SECT_ID,STNNBR,CASTNO,SAMPNO,BTLNBR,BTLNBR_FLAG_W,DATE,TIME,LATITUDE,LONGITUDE,DEPTH,CTDRAW,");			// compute the parameter headers			for (int p = 0; p < mFileViewer.gNumProperties; p++) {				// convert parameter to WOCE Convention				String currParam = mFileViewer.mAllProperties[p].getVarLabel();				String woceParam = JOAFormulas.paramNameToWOCEName(currParam).trim();				out.writeBytes(woceParam);				if (isObsQual[p]) {					// parameter has a quality code					out.writeBytes(delimStr);					if (masterQCStd == JOAConstants.IGOSS_QC_STD && !convertQC) {						out.writeBytes(woceParam + "_FLAG_I");					}					else if (masterQCStd == JOAConstants.WOCE_QC_STD && !convertQC) {						out.writeBytes(woceParam + "_FLAG_W");					}					else if (convertQC) {						if (convertQCto == JOAConstants.IGOSS_QC_STD) {							out.writeBytes(woceParam + "_FLAG_I");						}						else if (convertQCto == JOAConstants.WOCE_QC_STD) {							out.writeBytes(woceParam + "_FLAG_W");						}					}					if (p < mFileViewer.gNumProperties - 1) {						out.writeBytes(delimStr);					}				}				else {					if (p < mFileViewer.gNumProperties - 1) {						out.writeBytes(delimStr);					}				}			}			out.writeBytes(System.getProperty("line.separator"));			// write out the units line			out.writeBytes(",,,,,,,,,,,,,");			for (int p = 0; p < mFileViewer.gNumProperties; p++) {				// write the units				out.writeBytes(mFileViewer.mAllProperties[p].getUnits().toUpperCase());				if (p < mFileViewer.gNumProperties - 1) {					out.writeBytes(delimStr);					if (isObsQual[p]) {						out.writeBytes(delimStr);					}				}			}			out.writeBytes(System.getProperty("line.separator"));			int stnCount = 0;			// write the database records			for (int fc = 0; fc < mFileViewer.mNumOpenFiles; fc++) {				OpenDataFile of = (OpenDataFile) mFileViewer.mOpenFiles.elementAt(fc);				for (int sec = 0; sec < of.mNumSections; sec++) {					Section sech = (Section) of.mSections.elementAt(sec);					String expoCode = sech.getExpoCode();					if (expoCode == null) {						expoCode = "NA";					}					String sectionID = sech.mSectionDescription;					if (padFields) {						expoCode = JOAFormulas.returnSpacePaddedString(expoCode, 12);						sectionID = JOAFormulas.returnSpacePaddedString(sectionID, 7);					}					int sectionQC = sech.getQCStandard();					for (int stc = 0; stc < sech.mStations.size(); stc++) {						progress.setPercentComplete(100.0 * ((double) stnCount / (double) mFileViewer.getTotalNumStations()));						Station sh = (Station) sech.mStations.elementAt(stc);						if (!sh.mUseStn || !stnKeepList[stnCount++]) {							continue;						}						double lat = sh.mLat;						double lon = sh.mLon;						for (int b = 0; b < sh.mNumBottles; b++) {							Bottle bh = (Bottle) sh.mBottles.elementAt(b);							// Expocode							out.writeBytes(expoCode + delimStr);							// section identifier							out.writeBytes(sectionID + delimStr);							// stn number							String stnNum = sh.mStnNum;							if (padFields) {								stnNum = JOAFormulas.returnSpacePaddedString(stnNum, 6);							}							out.writeBytes(stnNum + delimStr);							String castNum = String.valueOf(sh.mCastNum);							if (padFields) {								castNum = JOAFormulas.returnSpacePaddedString(castNum, 3);							}							// cast number							out.writeBytes(castNum + delimStr);							String sampNo = String.valueOf(bh.getSampNo());							if (padFields) {								sampNo = JOAFormulas.returnSpacePaddedString(sampNo, 7);							}							// sampno							if (bh.isSampNoUsed()) {								out.writeBytes(sampNo + delimStr);							}							else {								out.writeBytes(JOAFormulas.formatDouble(missingVal, 0, false) + delimStr);							}							if (bh.isBottleNumUsed()) {								String botNum = String.valueOf(bh.getBottleNum());								if (padFields) {									botNum = JOAFormulas.returnSpacePaddedString(botNum, 7);								}								// bottle number								out.writeBytes(botNum + delimStr);							}							else {								out.writeBytes(JOAFormulas.formatDouble(missingVal, 0, false) + delimStr);							}							String botQC = String.valueOf(bh.mQualityFlag);							if (padFields) {								botQC = JOAFormulas.returnSpacePaddedString(botQC, 2);							}							// bottle quality flag							out.writeBytes(botQC + delimStr);							// create a date string							String sYear = String.valueOf(sh.mYear);							String sMonth = String.valueOf(sh.mMonth);							if (sh.mMonth <= 9) {								sMonth = "0" + sMonth;							}							String sDay = String.valueOf(sh.mDay);							if (sh.mDay <= 9) {								sDay = "0" + sDay;							}							String outDate = sYear + sMonth + sDay;							out.writeBytes(outDate + delimStr);							// create a time string							String outTime = "";							if (sh.mHour != JOAConstants.MISSINGVALUE) {								String sHr = String.valueOf(sh.mHour);								if (sh.mHour <= 9) {									sHr = "0" + sHr;								}								outTime = outTime + sHr;								if (sh.mMinute != JOAConstants.MISSINGVALUE) {									String sMn = String.valueOf((int) sh.mMinute);									if (sh.mMinute <= 9) {										sMn = "0" + sMn;									}									outTime = outTime + sMn;								}								else {									outTime = outTime + "00";								}							}							out.writeBytes(outTime + delimStr);							// lat							String latStr = JOAFormulas.formatDouble(lat, 4, false);							if (padFields) {								latStr = JOAFormulas.returnSpacePaddedString(latStr, 8);							}							out.writeBytes(latStr + delimStr);							// lon							String lonStr = JOAFormulas.formatDouble(lon, 4, false);							if (padFields) {								lonStr = JOAFormulas.returnSpacePaddedString(lonStr, 9);							}							out.writeBytes(lonStr + delimStr);							// bottom							String bottStr = "-999.0";							if (sh.mBottomDepthInDBARS != JOAConstants.MISSINGVALUE) {								int p = mFileViewer.getPRESPropertyPos();								double bottom = sh.mBottomDepthInDBARS * mFileViewer.mAllProperties[p].getActScale()								    + mFileViewer.mAllProperties[p].getActOrigin();								bottStr = String.valueOf((int) bottom);							}							if (padFields) {								bottStr = JOAFormulas.returnSpacePaddedString(bottStr, 5);							}							out.writeBytes(bottStr + delimStr);							// ctd raw							if (bh.isRawCTDMeasured()) {								String ctdRawStr = String.valueOf(bh.getRawCTD());								if (padFields) {									ctdRawStr = JOAFormulas.returnSpacePaddedString(ctdRawStr, 7);								}								out.writeBytes(ctdRawStr + delimStr);							}							else {								out.writeBytes(JOAFormulas.formatDouble(missingVal, 0, false) + delimStr);							}															// write out the bottle data							for (int v = 0; v < mFileViewer.gNumProperties; v++) {								int vPos = sech.getVarPos(mFileViewer.mAllProperties[v].getVarLabel(), false);								int prec = mFileViewer.mAllProperties[v].getDisplayPrecision();																if (vPos == -1) {																		String missingValStr = JOAFormulas.formatDouble(missingVal, prec, padFields, 9); 									// this parameter does not exist in this section--write out as									// missing									if (isObsQual[v]) {										out.writeBytes(missingValStr + "");										out.writeBytes(delimStr);										out.writeBytes(missingValStr + "");										if (v < mFileViewer.gNumProperties - 1) {											out.writeBytes(delimStr);										}									}									else {										out.writeBytes(missingValStr + "");										if (v < mFileViewer.gNumProperties - 1) {											out.writeBytes(delimStr);										}									}								}								else {									if (isObsQual[v]) {										if (bh.mDValues[vPos] != JOAConstants.MISSINGVALUE) {											String valStr = JOAFormulas.formatDouble(bh.mDValues[vPos], prec, padFields, 9);											out.writeBytes(valStr + "");										}										else {											String missingValStr = JOAFormulas.formatDouble(missingVal, prec, padFields, 9); 											out.writeBytes(missingValStr + "");										}										out.writeBytes(delimStr);										if (convertQC) {											if (convertQCto == JOAConstants.IGOSS_QC_STD) {												if (sectionQC == JOAConstants.WOCE_QC_STD) {													// convert a WOCE QC to IGOSS													if (sh.getType().indexOf("CTD") >= 0) {														out.writeBytes(JOAFormulas.translateWOCECTDQBToIGOSS(bh.mQualityFlags[vPos]) + "");													}													else {														out.writeBytes(JOAFormulas.translateWOCESampleQBToIGOSS(bh.mQualityFlags[vPos]) + "");													}												}												else {													out.writeBytes(bh.mQualityFlags[vPos] + "");												}											}											else if (convertQCto == JOAConstants.WOCE_QC_STD) {												if (sectionQC == JOAConstants.IGOSS_QC_STD) {													// convert an IGOSS QC to WOCE													out.writeBytes(JOAFormulas.translateIGOSSQBToWOCE(bh.mQualityFlags[vPos]) + "");												}												else {													out.writeBytes(bh.mQualityFlags[vPos] + "");												}											}										}										else {											out.writeBytes(bh.mQualityFlags[vPos] + "");										}										if (v < mFileViewer.gNumProperties - 1) {											out.writeBytes(delimStr);										}									}									else {										if (bh.mDValues[vPos] != JOAConstants.MISSINGVALUE) {											String valStr = JOAFormulas.formatDouble(bh.mDValues[vPos], prec, padFields, 9);											out.writeBytes(valStr + "");										}										else {											String missingValStr = JOAFormulas.formatDouble(missingVal, prec, padFields, 9); 											out.writeBytes(missingValStr + "");										}										if (v < mFileViewer.gNumProperties - 1) {											out.writeBytes(delimStr);										}									}								}							}							out.writeBytes(System.getProperty("line.separator"));						} // for bottles					}				}			}			out.writeBytes("END_DATA" + System.getProperty("line.separator"));			out.flush();			out.close();		}		catch (Exception ex) {			ex.printStackTrace();			System.out.println("An Error occurred exporting the current data");		}		progress.dispose();	}}//	public void exportCTDExchange(Station sh, String expoCode, String sectionID, File outFile, boolean[] isObsQual,//	    boolean hasObsQual, int masterQCStd, boolean convertQC, int convertQCto, boolean padFlds) {//		String delimStr = ","; //		String missingValStr = "-999";// //		try { //			FileOutputStream fos = new FileOutputStream(outFile);//			BufferedOutputStream bos = new BufferedOutputStream(fos, 1000000);//			DataOutputStream out = new DataOutputStream(bos); // ///*// * CTD, 20000718WHPOSIOSCD # # prototype WHPO 'ct1.csv' ctd file # S. Diggs:// * 2000.07.18 # NUMBER_HEADERS = 10 EXPOCODE = 31WTTUNES_3 SECTION_ID = P16C// * STNNBR = 221 CAST = 1 DATE = 19910901 TIME = 0817 LATITUDE = -17.5053// * LONGITUDE = -150.4812 BOTTOM = 3600// * // * // * CTDPRS,CTDPRS_FLAG_W,CTDTMP,CTDTMP_FLAG_W,CTDSAL,CTDSAL_FLAG_W,CTDOXY,CTDOXY_FLAG_W *// * DBAR,,ITS-90,,PSS-78,,UMOL/KG,,// */////			// write the header//			out.writeBytes("CTD,"); //			// has the user entered a file stamp field?//			String ds = mDateStamp.getText();// //			if (ds != null && ds.length() > 0) { //				out.writeBytes(ds + "\r"); //			} //			else {//					Calendar calendar = Calendar.getInstance(); //					Date initDate = calendar.getTime(); //					GeoDate gd = new GeoDate(initDate.getTime());//					out.writeBytes(gd.toString("yyyymmdd") + "JOAExport" + "\r"); //			}// //			// write the comments,if any//			String cmts = mFileComments.getText(); //			if (!cmts.endsWith("\r")) { //					cmts += "\r"; //			} //			if (cmts != null && cmts.length() > 0) { //				out.writeBytes(cmts); //			} // //			// Write the metadata fields//			out.writeBytes("NUMBER_HEADERS = 10"); //			out.writeBytes("EXPOCODE = " + expoCode); // 31WTTUNES_3//			out.writeBytes("SECTION_ID = " + sectionID); // P16C//			out.writeBytes("STNNBR = " + sh.getStn()); // 221//			out.writeBytes("CAST = " + sh.mCastNum); // 1//			out.writeBytes("DATE = "); // 19910901//			out.writeBytes("TIME = "); // 0817//			out.writeBytes("LATITUDE = " + String.valueOf(sh.getLat())); // -17.5053//			out.writeBytes("LONGITUDE = " + String.valueOf(sh.getLon())); // -150.4812//			out.writeBytes("BOTTOM = " + String.valueOf(sh.getBottom())); // 3600 ////  //			// compute the parameter headers//			for (int p = 0; p < mFileViewer.gNumProperties; p++) {//				// convert parameter to WOCE Convention//				out.writeBytes(mFileViewer.mAllProperties[p].getVarLabel());// //				if (isObsQual[p]) {//					// parameter has a quality code//					out.writeBytes(delimStr); //					if (masterQCStd == JOAConstants.IGOSS_QC_STD && !convertQC) {//						out.writeBytes(mFileViewer.mAllProperties[p].getVarLabel().trim() + "_FLAG_I"); //					} //					else if (masterQCStd == JOAConstants.WOCE_QC_STD && !convertQC) {//						out.writeBytes(mFileViewer.mAllProperties[p].getVarLabel().trim() + "_FLAG_W"); //					} //					else if (convertQC) { if (convertQCto == JOAConstants.IGOSS_QC_STD) {//						out.writeBytes(mFileViewer.mAllProperties[p].getVarLabel().trim() + "_FLAG_I"); //					} //					else if (convertQCto == JOAConstants.WOCE_QC_STD) {//						out.writeBytes(mFileViewer.mAllProperties[p].getVarLabel().trim() + "_FLAG_W"); //					} //					if (p < mFileViewer.gNumProperties - 1) {//						out.writeBytes(delimStr); //					} //				}//				else {//						if (p < mFileViewer.gNumProperties - 1) { //							out.writeBytes(delimStr); //						} //				} //				out.writeBytes("\r"); //				}//			}//				//				// write out the units line//				for (int p = 0; p < mFileViewer.gNumProperties; p++) { //					// write the units//					out.writeBytes(mFileViewer.mAllProperties[p].getUnits());//					if (p < mFileViewer.gNumProperties - 1) { //							out.writeBytes(delimStr); //							if (isObsQual[p]) { //								out.writeBytes(delimStr); //							} //					} //				} //				out.writeBytes("\r");// //				int stnCount = 0; //				//				// write the database records//				// create a date string//			String sYear = String.valueOf(sh.mYear); //			String sMonth = String.valueOf(sh.mMonth); //			if (sh.mMonth <= 9) { //				sMonth = "0" + sMonth; //			}// // String sDay = String.valueOf(sh.mDay); // if (sh.mDay <= 9) { //	 sDay = "0" + sDay; //	 } // String outDate = sYear + sMonth + sDay; // out.writeBytes(outDate + delimStr); // // create a time string// String outTime = ""; // if (sh.mHour != JOAConstants.MISSINGVALUE) { //	 String sHr = String.valueOf(sh.mHour); // if (sh.mHour <= 9) { //	 sHr = "0" + sHr; // } // outTime = outTime + sHr;// // if (sh.mMinute != JOAConstants.MISSINGVALUE) { //	 String sMn = String.valueOf(sh.mMinute); //	 if (sh.mMinute <= 9) { //		 sMn = "0" + sMn; //		 }// outTime = outTime + sMn; // } // else { //	 outTime = outTime + "00"; //	 } // }// Section sech = null;// Bottle bh = null;// // out.writeBytes(outTime + delimStr); // // bottom// if (sh.mBottomDepthInDBARS == JOAConstants.MISSINGVALUE) { //	 // write missing value// out.writeBytes(missingValStr + delimStr); // } // else { //	 int p = mFileViewer.getPRESPropertyPos(); //	 double bottom = sh.mBottomDepthInDBARS * mFileViewer.mAllProperties[p].getActScale() + mFileViewer.mAllProperties[p].getActOrigin(); //	 out.writeBytes((int)bottom + delimStr); //	 } // // write out the bottle data// for (int v = 0; v <mFileViewer.gNumProperties; v++) { //	 int vPos = sech.getVarPos(mFileViewer.mAllProperties[v].getVarLabel(), false);// // if (vPos == -1) { //	 // this parameter does not exist in this section--write out as missing//	 if (isObsQual[v]) { //		 out.writeBytes(missingValStr + "");// out.writeBytes(delimStr); // out.writeBytes(missingValStr + ""); // if (v < mFileViewer.gNumProperties - 1) { //	 out.writeBytes(delimStr); //	 } // } //	 else {// out.writeBytes(missingValStr + ""); // if (v < mFileViewer.gNumProperties - 1) { //	 out.writeBytes(delimStr); //	 } // } //	 } // else { //	 if (isObsQual[v]) { //		 if (bh.mDValues[vPos] != JOAConstants.MISSINGVALUE) {// out.writeBytes(bh.mDValues[vPos] + ""); // } //		 else {// out.writeBytes(missingValStr + ""); // } //		 out.writeBytes(delimStr); // if (convertQC) { //	 if (convertQCto == JOAConstants.IGOSS_QC_STD) { //	 if (sectionQC == JOAConstants.WOCE_QC_STD) { //	 // convert a WOCE QC to IGOSS// if (sh.getType().indexOf("CTD") >= 0) {// out.writeBytes(JOAFormulas.translateWOCECTDQBToIGOSS(bh.mQualityFlags[vPos]) + ""); // } // else {// out.writeBytes(JOAFormulas.translateWOCESampleQBToIGOSS(bh.mQualityFlags[vPos]) + "");// } // } //	 else { //		 out.writeBytes(bh.mQualityFlags[vPos] + ""); //		 } //	 } else if (convertQCto == JOAConstants.WOCE_QC_STD) { //	 if (sectionQC == JOAConstants.IGOSS_QC_STD) { //	 // convert an IGOSS QC to WOCE// }// out.writeBytes(JOAFormulas.translateIGOSSQBToWOCE(bh.mQualityFlags[vPos]) + ""); // } // else { //	 out.writeBytes(bh.mQualityFlags[vPos] + ""); //	 } // } // } // else {// out.writeBytes(bh.mQualityFlags[vPos] + ""); } // if (v < mFileViewer.gNumProperties - 1) { //	 out.writeBytes(delimStr); //	 } // } // else { //	 if (bh.mDValues[vPos] != JOAConstants.MISSINGVALUE) {// out.writeBytes(bh.mDValues[vPos] + ""); // } // else {// out.writeBytes(missingValStr + ""); }// // if (v < mFileViewer.gNumProperties - 1) { //	 out.writeBytes(delimStr); //	 } // } // out.writeBytes("\r"); // out.writeBytes("END_DATA" + "\r"); // out.flush();// out.close();//	}// // catch (Exception ex) { //	 ex.printStackTrace(); System.out.println("An Error occurred exporting the current data");//	}//}			