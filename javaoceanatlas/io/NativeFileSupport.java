/* * $Id: NativeFileSupport.java,v 1.2 2005/09/21 05:29:46 oz Exp $ * */package javaoceanatlas.io;import gov.noaa.pmel.util.GeoDate;import java.awt.*;import java.io.*;import java.util.*;import java.util.List;import javax.swing.*;import javaoceanatlas.classicdatamodel.*;import javaoceanatlas.utility.*;import javaoceanatlas.resources.*;import javaoceanatlas.ui.*;import com.apple.mrj.*;public class NativeFileSupport {	public static void readBinary2File(FileViewer mFV) throws FileImportException, FileNotFoundException, IOException,	ArrayIndexOutOfBoundsException {		// create a progress dialog		ProgressDialog progress = new ProgressDialog(mFV, "Reading Binary Data...", Color.blue, Color.white);		progress.setVisible(true);		FileInputStream in = null;		DataInputStream inData = null;		short inShort = 0;		long bytesRead = 0;		File mFile = mFV.getFile();		long bytesInFile = mFile.length();		int numVars = 0;		String errorStr = "No Error";		Parameter tempProperties[] = new Parameter[1000];		boolean DEBUG = false;		// initialize the max/min variables		// for (int i=0; i<100; i++) {		// varMin[i] = 10e9;		// varMax[i] = -10e9;		// }		// store some stuff to make cleanup easier		int oldNumFiles = mFV.getNumOpenFiles();		boolean readError = false;		int oldNumSections = mFV.getNumSections();		// open up the file		try {			in = new FileInputStream(mFile);			BufferedInputStream bis = new BufferedInputStream(in, 10000);			inData = new DataInputStream(bis);		}		catch (FileNotFoundException e) {			FileImportException fiex = new FileImportException();			fiex.setErrorType("Couldn't open the specified file");			throw fiex;		}		// attempt to parse a binary file		OpenDataFile of = null;		try {			// read version			short vers = inData.readShort();			bytesRead += 2;			if (DEBUG) {				System.out.println("vers= " + vers);			}			if (vers < 2) {				FileImportException fiex = new FileImportException();				String errStr = "Invalid version for a JOA binary file";				fiex.setErrorType(errStr);				throw fiex;			}			// read number of bytes in file description string			inShort = inData.readShort();			bytesRead += 2;			// read the file description String			byte buf[] = new byte[inShort];			inData.read(buf, 0, inShort);			String fileDescrip = new String(buf);			bytesRead += inShort;			if (DEBUG) {				System.out.println("fileDescrip= " + fileDescrip);			}			errorStr = "Reading file description \n";			// read the number of sections			int numSections = inData.readShort();			bytesRead += 2;			if (numSections < 0) {				// write overflow--look for encoded values in fileDescrip				if (fileDescrip.indexOf(">>>") > 0) {					String[] tokens = fileDescrip.split(">>>");					numSections = Integer.valueOf(tokens[1]);					fileDescrip = tokens[0];				}				else {					readError = true;					errorStr = "Too many sections! Maximum number is 32768. \n";					FileImportException fiex = new FileImportException();					fiex.setErrorType(errorStr);					throw fiex;				}			}			if (DEBUG) {				System.out.println("numSections= " + numSections);			}			errorStr = "Reading number of sections\n";			// create a new open file object			of = new OpenDataFile(fileDescrip);			mFV.addOpenFile(of);			progress.setPercentComplete(100.0 * ((double) bytesRead / (double) bytesInFile));			// read each section			Section sech;			int ord = mFV.getTotalNumStations();			for (int s = 0; s < numSections; s++) {				errorStr = "Reading sections\n";				// read the section header				inShort = inData.readShort();				bytesRead += 2;				byte buf1[] = new byte[inShort];				inData.read(buf1, 0, inShort);				String sectionDescrip = new String(buf1);				bytesRead += inShort;								int overRideNumCasts = -99;				// test whether there is anything encoded in the section description				if (sectionDescrip.indexOf(">>>") > 0) {					String[] tokens = sectionDescrip.split(">>>");					overRideNumCasts = Integer.valueOf(tokens[1]);					sectionDescrip = tokens[0];				}				if (DEBUG) {					System.out.println("sectionDescrip= " + sectionDescrip);				}				// read the ship code				byte bufsc[] = new byte[2];				bufsc[0] = inData.readByte();				bufsc[1] = inData.readByte();				String shipCode = new String(bufsc);				bytesRead += 2;				if (DEBUG) {					System.out.println("shipCode= " + shipCode);				}				errorStr = "Reading shipcode in section #" + s + "\n";				// read num casts				int numCasts = 0;				if (vers >= 6) {					numCasts = inData.readInt();					bytesRead += 4;				}				else {					numCasts = inData.readShort();					bytesRead += 2;				}								if (numCasts < 0 && overRideNumCasts > 0) {					numCasts = overRideNumCasts;				}				else if (numCasts < 0) {					// error condition					readError = true;					errorStr = "Greater than 32768 casts in section #" + s + "\n";					// clean up					if (readError && oldNumFiles != mFV.getNumOpenFiles()) {						for (int i = 0; i < (mFV.getNumOpenFiles() - oldNumFiles); i++) {							mFV.removeLastFile();						}						mFV.setNumOpenFiles(oldNumFiles);						mFV.setNumSections(oldNumSections);					}					if (in != null) {						try {							in.close();						}						catch (IOException e) {							System.out.println("threw here4a");						}					}					progress.dispose();					FileImportException fiex = new FileImportException();					fiex.setErrorType(errorStr);					throw fiex;				}				if (DEBUG) {					System.out.println("numCasts= " + numCasts);				}				mFV.addToTotalStations(numCasts);				errorStr = "Reading number of variables in section #" + s + "\n";				// read num parameters				numVars = inData.readShort();				bytesRead += 2;				if (DEBUG) {					System.out.println("numVars= " + numVars);				}				errorStr = "Reading number of parameters in section #" + s + "\n";				// quality code				int qcStd = JOAConstants.IGOSS_QC_STD;				if (vers >= 4) {					qcStd = inData.readShort();					bytesRead += 2;					if (DEBUG) {						System.out.println("qcStd= " + qcStd);					}				}				// create a new section				of.mNumSections++;				sech = new Section(of.mNumSections, sectionDescrip, shipCode, numCasts, numVars);				of.addSection(sech);				sech.setQCStandard(qcStd);				// set the section color				mFV.addToTotalSections();				sech.mSectionColor = JOAFormulas.getSectionColor(mFV.getNumSections());				progress.setPercentComplete(100.0 * ((double) bytesRead / (double) bytesInFile));				if (vers == 2) {					// read the properties					byte bufv[] = new byte[4];					for (int p = 0; p < numVars; p++) {						// parameter name						errorStr = "Reading parameter #" + p + "\n";						inData.read(bufv, 0, 4);						String tempVar = new String(bufv).trim();						if (DEBUG) {							System.out.println("tempVar= " + tempVar);						}						bytesRead += 4;						// units						inShort = inData.readShort();						bytesRead += 2;						errorStr = "Reading units for parameter #" + p + "\n";						String units = null;						if (inShort > 0) {							byte buf11[] = new byte[inShort];							inData.read(buf11, 0, inShort);							units = new String(buf11);							bytesRead += inShort;						}						if (DEBUG) {							System.out.println("units= " + units);						}						// convert varnames to UC						tempVar = tempVar.toUpperCase();						// create new property						tempProperties[p] = new Parameter(tempVar, units);						// add this property to the section property list						if (tempProperties[p].getUnits() == null) {							tempProperties[p].setUnits(JOAFormulas.paramNameToJOAUnits(false, tempProperties[p].getVarLabel()));						}						if (tempProperties[p].getUnits() == null) {							tempProperties[p].setUnits(new String("na"));						}						sech.addNewVarToSection(tempProperties[p].getVarLabel(), tempProperties[p].getUnits());						tempProperties[p].setCastOrObs(JOAConstants.ALL_OBS);						// read the actual scale						int actScale = inData.readShort();						bytesRead += 2;						if (DEBUG) {							System.out.println("actScale= " + actScale);						}						if (actScale != 0) {							tempProperties[p].setActScale(1.0 / (double) actScale);						}						else {							tempProperties[p].setActScale(1.0);						}						errorStr = "Reading scale for parameter #" + p + "\n";						// read the actual origin						int actOrigin = inData.readShort();						tempProperties[p].setActOrigin((double) actOrigin * tempProperties[p].getActScale());						errorStr = "Reading origin parameter #" + p + "\n";						if (DEBUG) {							System.out.println("actOrigin= " + actOrigin);						}						// read reverse y						int reverseY = inData.readShort();						bytesRead += 2;						if (DEBUG) {							System.out.println("reverseY= " + reverseY);						}						if (reverseY == 0) {							tempProperties[p].setReverseY(false);						}						else {							tempProperties[p].setReverseY(true);						}						errorStr = "Reading reverse y flag parameter #" + p + "\n";						tempProperties[p].setWasCalculated(false);					}				}				else {					// read the properties					String tempVar = null;					for (int p = 0; p < numVars; p++) {						errorStr = "Reading parameter #" + p + "\n";						// length of parameter name						inShort = inData.readShort();						bytesRead += 2;						// parameter name						if (inShort > 0) {							byte buf13[] = new byte[inShort];							inData.read(buf13, 0, inShort);							tempVar = new String(buf13);							bytesRead += inShort;						}						if (DEBUG) {							System.out.println("tempVar= " + tempVar);						}						errorStr = "Reading name for parameter #" + p + "\n";						// units						inShort = inData.readShort();						bytesRead += 2;						errorStr = "Reading units for parameter #" + p + "\n";						String units = null;						if (inShort > 0) {							byte buf11[] = new byte[inShort];							inData.read(buf11, 0, inShort);							units = new String(buf11);							bytesRead += inShort;						}						if (DEBUG) {							System.out.println("units= " + units);						}						// convert varnames to UC						tempVar = tempVar.toUpperCase();						// create new property						tempProperties[p] = new Parameter(tempVar, units);						// add this property to the section property list						if (tempProperties[p].getUnits() == null) {							tempProperties[p].setUnits(JOAFormulas.paramNameToJOAUnits(false, tempProperties[p].getVarLabel()));						}						if (tempProperties[p].getUnits() == null) {							tempProperties[p].setUnits(new String("na"));						}						sech.addNewVarToSection(tempProperties[p].getVarLabel(), tempProperties[p].getUnits());						tempProperties[p].setCastOrObs(JOAConstants.ALL_OBS);						// read the actual scale						int actScale = inData.readShort();						bytesRead += 2;						if (actScale != 0) {							tempProperties[p].setActScale(1.0 / (double) actScale);						}						else {							tempProperties[p].setActScale(1.0);						}						if (DEBUG) {							System.out.println("actScale= " + actScale);						}						errorStr = "Reading scale for parameter #" + p + "\n";						// read the actual origin						int actOrigin = inData.readShort();						tempProperties[p].setActOrigin((double) actOrigin * tempProperties[p].getActScale());						if (DEBUG) {							System.out.println("actOrigin= " + actOrigin);						}						errorStr = "Reading origin for parameter #" + p + "\n";						// read reverse y						int reverseY = inData.readShort();						bytesRead += 2;						if (reverseY == 0) {							tempProperties[p].setReverseY(false);						}						else {							tempProperties[p].setReverseY(true);						}						if (DEBUG) {							System.out.println("reverseY= " + reverseY);						}						errorStr = "Reading reverse Y for parameter #" + p + "\n";						tempProperties[p].setWasCalculated(false);					}				}				progress.setPercentComplete(100.0 * ((double) bytesRead / (double) bytesInFile));				// read the cast headers				double mMaxDepth = 0.0;				for (int c = 0; c < numCasts; c++) {					errorStr = "Reading cast header #" + c + "\n";					String stnNum = "na";					// try {					// read station number					inShort = inData.readShort();					bytesRead += 2;					byte bufx[] = new byte[inShort];					inData.read(bufx, 0, inShort);					stnNum = new String(bufx);					bytesRead += inShort;					if (DEBUG) {						System.out.println("stnNum= " + stnNum);					}					// }					// catch (Exception ex) {}					errorStr = "Reading station number for cast header #" + c + "\n";					// read cast number					int castNum = inData.readShort();					bytesRead += 2;					if (DEBUG) {						System.out.println("castNum= " + castNum);					}					errorStr = "Reading cast number for cast header #" + c + "\n";					double myLat = 0.0;					double myLon = 0.0;					if (vers == 2) {						// read latitude/lon						int lat = inData.readInt();						bytesRead += 4;						if (DEBUG) {							System.out.println("lat= " + lat);						}						errorStr = "Reading latitude for cast header #" + c + " (v2)\n";						int lon = inData.readInt();						bytesRead += 4;						if (DEBUG) {							System.out.println("lon= " + lon);						}						errorStr = "Reading longitude for cast header #" + c + " (v2)\n";						myLat = lat * 0.001;						myLon = lon * 0.001;					}					else if (vers > 2) {						// read latitude/lon						myLat = inData.readDouble();						bytesRead += 8;						if (DEBUG) {							System.out.println("myLat= " + myLat);						}						errorStr = "Reading latitude for cast header #" + c + " (v3)\n";						myLon = inData.readDouble();						bytesRead += 4;						if (DEBUG) {							System.out.println("myLon= " + myLon);						}						errorStr = "Reading longitude for cast header #" + c + " (v3)\n";					}					/* check latitude an longitude bounds of station */					double maxLat = 0;					maxLat = myLat > maxLat ? myLat : maxLat;					double minLat = 0;					minLat = myLat < minLat ? myLat : minLat;					/* test to see if cruise crosses the dateline */					double myLon0 = 0;					if ((myLon >= -180 && myLon < -178) && (myLon0 >= 178 && myLon0 <= 180)) {					}					else if ((myLon >= 178 && myLon <= 180) && (myLon0 >= -180 && myLon0 < -178)) {					}					/* convert all latitudes to the range -360 to 0 */					double testLon = 0;					if (myLon > 0) {						testLon = myLon /* - 360 */;					}					else {						testLon = myLon;					}					/* compute min and max longitude */					double minLon = 0;					minLon = testLon < minLon /*-360*/? myLon : minLon;					double maxLon = 0;					maxLon = testLon > maxLon /*-360*/? myLon : maxLon;					myLon0 = myLon;					// read number of bottles					int numBottles = inData.readShort();					bytesRead += 2;					if (DEBUG) {						System.out.println("numBottles= " + numBottles);					}					errorStr = "Reading number of bottles for cast header #" + c + " \n";					// read the date					int year = inData.readInt();					bytesRead += 4;					int month = inData.readInt();					bytesRead += 4;					int day = inData.readInt();					bytesRead += 4;					int hour = inData.readInt();					bytesRead += 4;					double min = inData.readDouble();					bytesRead += 8;					errorStr = "Reading date for cast header #" + c + " \n";					// read bottom					int bottomdbar = inData.readInt();					if (DEBUG) {						System.out.println("bottomdbar= " + bottomdbar);					}					errorStr = "Reading bottom for cast header #" + c + " \n";					if (bottomdbar != -99) { // missingVal)						mMaxDepth = (double) bottomdbar > mMaxDepth ? (double) bottomdbar : mMaxDepth;					}					// read station quality					int stnQual = inData.readShort();					bytesRead += 2;					errorStr = "Reading station quality for cast header #" + c + " \n";					ord++;					Station sh = new Station(ord, shipCode, stnNum, castNum, myLat, myLon, numBottles, year, month, day, hour,							min, bottomdbar, stnQual, null, null);					sech.mStations.addElement(sh);					sh.setType("BOTTLE");				}				mFV.setMaxDepth(mMaxDepth);				progress.setPercentComplete(100.0 * ((double) bytesRead / (double) bytesInFile));				// read the bottle data				for (int sc = 0; sc < sech.mStations.size(); sc++) {					Station st = (Station) sech.mStations.elementAt(sc);					progress.setPercentComplete(100.0 * ((double) bytesRead / (double) bytesInFile));					if (DEBUG) {						System.out.println("st.mNumBottles= " + st.mNumBottles);					}					for (int b = 0; b < st.mNumBottles; b++) {						int numV = sech.mNumVars;						Bottle bh = new Bottle(b, numV, st, sech);						// read the bottle quality code						bh.mQualityFlag = inData.readShort();						bytesRead += 2;						if (vers >= 5) {							bh.setBottleNum(inData.readInt());							bh.setBottleNumUsed(true);							bytesRead += 4;						}						for (int v = 0; v < numV; v++) {							errorStr = "Reading data for bottle #" + b + " for param #" + v + " at stn #" + st.getStn() + " \n";							double varVal = 0;							try {								varVal = inData.readDouble();							}							catch (IOException e) {								FileImportException fiex = new FileImportException();								String errStr = "Error reading the parameter data at station " + st.getStn() + "\n" + "Bottle #" + b								+ " Parameter #" + v;								fiex.setErrorType(errStr);								throw fiex;							}							bytesRead += 8;							if (DEBUG) {								System.out.println(v + " val= " + varVal);							}							if (varVal != JOAConstants.MISSINGVALUE) {								bh.mDValues[v] = (float) varVal;							}							else {								bh.mDValues[v] = JOAConstants.MISSINGVALUE;							}							/*							 * // check for max and min if (varVal !=							 * JOAConstants.MISSINGVALUE) { if (varVal < varMin[v]) {							 * varMin[v] = varVal; } if (varVal > varMax[v]) varMax[v] =							 * varVal; }							 */							// get the quality flag							short flag = (short) JOAConstants.MISSINGVALUE;							try {								flag = inData.readShort();							}							catch (IOException e) {								FileImportException fiex = new FileImportException();								String errStr = "Error reading the parameter quality code at station " + st.getStn() + "\n"								+ "Bottle #" + b + " Parameter #" + v;								fiex.setErrorType(errStr);								throw fiex;							}							bytesRead += 2;							if (flag != JOAConstants.MISSINGVALUE) {								bh.mQualityFlags[v] = flag;							}							else {								bh.mQualityFlags[v] = (short) JOAConstants.MISSINGVALUE;							}						} // for v						st.mBottles.addElement(bh);					} // for b				} // for sc				// reconcile tempProperties with AllProperties				for (int v = 0; v < numVars; v++) {					int newPos = mFV.getPropertyPos(tempProperties[v].getVarLabel(), false);					if (newPos < 0) {						// add new variable to AllProperties						String units = JOAFormulas.paramNameToJOAUnits(false, tempProperties[v].getVarLabel());						newPos = mFV.addNewProperty(tempProperties[v].getVarLabel(), units);						if (newPos >= 0) {							mFV.mAllProperties[newPos] = tempProperties[v];						}						else {							;						}					}					/*					 * else { // it does exist--update the parameter ranges if					 * (tempProperties[v].mPlotMin < mAllProperties[newPos].mPlotMin) {					 * mAllProperties[newPos].setPlotMin(tempProperties[v].mPlotMin; }					 * 					 * if (tempProperties[v].mPlotMax > mAllProperties[newPos].mPlotMax) {					 * mAllProperties[newPos].setPlotMax(tempProperties[v].mPlotMax; } }					 */				}			} // for s			// compute the default plot bounds for the parameters			mFV.computePlotBounds();		}		catch (IOException ex) {			readError = true;			FileImportException fiex = new FileImportException();			fiex.setErrorType(errorStr);			throw fiex;		}		catch (NullPointerException e) {			readError = true;			FileImportException fiex = new FileImportException();			fiex.setErrorType(errorStr);			throw fiex;		}		catch (ArrayIndexOutOfBoundsException e) {			readError = true;			FileImportException fiex = new FileImportException();			fiex.setErrorType(errorStr);			throw fiex;		}		catch (NegativeArraySizeException e) {			readError = true;			FileImportException fiex = new FileImportException();			fiex.setErrorType(errorStr);			throw fiex;		}		finally {			// clean up			if (readError && oldNumFiles != mFV.getNumOpenFiles()) {				for (int i = 0; i < (mFV.getNumOpenFiles() - oldNumFiles); i++) {					mFV.removeLastFile();				}				mFV.setNumOpenFiles(oldNumFiles);				mFV.setNumSections(oldNumSections);			}			if (in != null) {				try {					in.close();				}				catch (IOException e) {					System.out.println("threw here4");				}			}			progress.dispose();		}		// read the file comments		StringBuffer sb = null;		while (true) {			try {				// read continuation line				inShort = inData.readShort();				bytesRead += 2;				if (inShort == 1) {					// read number of bytes in file description string					inShort = inData.readShort();					bytesRead += 2;					// read the file description String					byte buf2[] = new byte[inShort];					inData.read(buf2, 0, inShort);					String commentLine = new String(buf2);					bytesRead += inShort;					if (sb == null) {						sb = new StringBuffer(commentLine);					}					else {						sb.append(commentLine);					}				}			}			catch (IOException e) {				break;			}		} // while true		if (sb != null) {			of.addComment(new String(sb));		}	}	public static void readPOABinaryFile(FileViewer mFV) throws FileNotFoundException, IOException,	ArrayIndexOutOfBoundsException {		Parameter tempProperties[] = new Parameter[1000];		double varMin[] = new double[1000];		double varMax[] = new double[1000];		// create a progress dialog		ProgressDialog progress = new ProgressDialog(mFV, "Reading POA Binary Data...", Color.blue, Color.white);		progress.setVisible(true);		FileInputStream in = null;		DataInputStream inData = null;		short inShort = 0;		long bytesRead = 0;		File mFile = mFV.getFile();		long bytesInFile = mFile.length();		int numVars = 0;		for (int i = 0; i < 1000; i++) {			varMin[i] = 32000.;			varMax[i] = -32000.;		}		// store some stuff to make cleanup easier		int oldNumFiles = mFV.getNumOpenFiles();		boolean readError = false;		int oldNumSections = mFV.getNumSections();		// open up the file		try {			in = new FileInputStream(mFile);			BufferedInputStream bis = new BufferedInputStream(in, 1000000);			inData = new DataInputStream(bis);		}		catch (FileNotFoundException e) {			throw e;		}		// attempt to parse a binary file		try {			// read number of bytes in file description string			inShort = inData.readShort();			bytesRead += 2;			// read the file description String			byte buf[] = new byte[inShort];			inData.read(buf, 0, inShort);			String fileDescrip = new String(buf);			bytesRead += inShort;			// read the number of sections			int numSections = inData.readShort();			bytesRead += 2;			// create a new open file object			OpenDataFile of = new OpenDataFile(fileDescrip);			mFV.addOpenFile(of);			progress.setPercentComplete(100.0 * ((double) bytesRead / (double) bytesInFile));			// read each section			Section sech;			int ord = mFV.getTotalNumStations();			for (int s = 0; s < numSections; s++) {				// read the section header				inShort = inData.readShort();				bytesRead += 2;				String sectionDescrip;				if (inShort > 0) {					byte buf1[] = new byte[inShort];					inData.read(buf1, 0, inShort);					sectionDescrip = new String(buf1);					bytesRead += inShort;				}				else {					sectionDescrip = "N.A.";				}				// read the ship code				byte bufsc[] = new byte[2];				bufsc[0] = inData.readByte();				bufsc[1] = inData.readByte();				String shipCode = new String(bufsc);				bytesRead += 2;				// read num casts				int numCasts = inData.readShort();				bytesRead += 2;				mFV.addToTotalStations(numCasts);				// read num parameters				numVars = inData.readShort();				bytesRead += 2;				// create a new section				of.mNumSections++;				sech = new Section(of.mNumSections, sectionDescrip, shipCode, numCasts, numVars);				of.addSection(sech);				// set the section color				mFV.addToTotalSections();				sech.mSectionColor = JOAFormulas.getSectionColor(mFV.getNumSections());				progress.setPercentComplete(100.0 * ((double) bytesRead / (double) bytesInFile));				// read the properties				byte bufv[] = new byte[4];				for (int p = 0; p < numVars; p++) {					inData.read(bufv, 0, 4);					String tempVar = new String(bufv);					bytesRead += 4;					// convert varnames to UC					tempVar = tempVar.toUpperCase();					// assign default units					String units = new String(JOAFormulas.paramNameToJOAUnits(false, tempVar));					// create new property					tempProperties[p] = new Parameter(tempVar, units);					// add this property to the section property list					sech.addNewVarToSection(tempProperties[p].getVarLabel(), units);					tempProperties[p].setCastOrObs(JOAConstants.ALL_OBS);					// read the actual scale					int actScale = inData.readShort();					bytesRead += 2;					if (actScale != 0) {						tempProperties[p].setActScale(1.0 / (double) actScale);					}					else {						tempProperties[p].setActScale(1.0);					}					// read the actual origin					int actOrigin = inData.readShort();					tempProperties[p].setActOrigin((double) actOrigin * tempProperties[p].getActScale());					// read reverse y					int reverseY = inData.readShort();					bytesRead += 2;					if (reverseY == 0) {						tempProperties[p].setReverseY(false);					}					else {						tempProperties[p].setReverseY(true);					}					tempProperties[p].setWasCalculated(false);				}				progress.setPercentComplete(100.0 * ((double) bytesRead / (double) bytesInFile));				// read the cast headers				double mMaxDepth = 0.0;				for (int c = 0; c < numCasts; c++) {					// read station number					int iStnNum = inData.readShort();					bytesRead += 2;					// turn this into a string					String stnNum = String.valueOf(iStnNum);					// read cast number					int castNum = inData.readShort();					bytesRead += 2;					inData.readShort();					bytesRead += 2;					// read latitude					int lat = inData.readInt();					bytesRead += 4;					int lon = inData.readInt();					bytesRead += 4;					/* check latitude an longitude bounds of station */					double myLat = lat * 0.001;					double myLon = lon * 0.001;					double maxLat = 0;					maxLat = myLat > maxLat ? myLat : maxLat;					double minLat = 0;					minLat = myLat < minLat ? myLat : minLat;					/* test to see if cruise crosses the dateline */					double myLon0 = 0;					if ((myLon >= -180 && myLon < -178) && (myLon0 >= 178 && myLon0 <= 180)) {					}					else if ((myLon >= 178 && myLon <= 180) && (myLon0 >= -180 && myLon0 < -178)) {					}					/* convert all latitudes to the range -360 to 0 */					double testLon = 0;					if (myLon > 0) {						testLon = myLon /* - 360 */;					}					else {						testLon = myLon;					}					/* compute min and max longitude */					double minLon = 0;					minLon = testLon < minLon /*-360*/? myLon : minLon;					double maxLon = 0;					maxLon = testLon > maxLon /*-360*/? myLon : maxLon;					myLon0 = myLon;					// read number of bottles					int numBottles = inData.readShort();					bytesRead += 2;					// totalSecBottles[s] += (*sh)->numBottles;					// read the date					long date = 0;					boolean dateErr = false;					int iYear = JOAConstants.MISSINGVALUE;					int iMonth = JOAConstants.MISSINGVALUE;					int iDay = JOAConstants.MISSINGVALUE;					try {						date = inData.readInt();					}					catch (Exception ex) {						dateErr = true;					}					if (!dateErr) {						if (date != JOAConstants.MISSINGVALUE) {							if (date < 0) {								date = 2147483647 + (2147483647 + date);							}							bytesRead += 4;							// expand the date							String dateStr = new String(String.valueOf(date));							if (dateStr.length() < 6) {								while (dateStr.length() < 6) {									dateStr = "0" + dateStr;								}							}							else if (dateStr.length() < 10 && dateStr.length() > 6) {								while (dateStr.length() < 10) {									dateStr = "0" + dateStr;								}							}							String day = dateStr.substring(0, 2);							String month = dateStr.substring(2, 4);							String year = dateStr.substring(4, 6);							iYear = Integer.valueOf(year).intValue();							iMonth = Integer.valueOf(month).intValue();							iDay = Integer.valueOf(day).intValue();						}					}					// read bottom					int bottomdbar = inData.readInt();					if (bottomdbar == 0) {						// probably missing						bottomdbar = JOAConstants.MISSINGVALUE;					}					if (bottomdbar != JOAConstants.MISSINGVALUE) {						mMaxDepth = (double) bottomdbar > mMaxDepth ? (double) bottomdbar : mMaxDepth;					}					// read varFlag					int varFlag = inData.readShort();					bytesRead += 2;					ord++;					Station sh = new Station(ord, shipCode, stnNum, castNum, myLat, myLon, numBottles, iYear, iMonth, iDay,							JOAConstants.MISSINGVALUE, JOAConstants.MISSINGVALUE, bottomdbar, varFlag, null, null);					sech.mStations.addElement(sh);					sh.setType("BOTTLE");				}				mFV.setMaxDepth(mMaxDepth);				progress.setPercentComplete(100.0 * ((double) bytesRead / (double) bytesInFile));				// read the bottle data				for (int sc = 0; sc < sech.mStations.size(); sc++) {					Station st = (Station) sech.mStations.elementAt(sc);					progress.setPercentComplete(100.0 * ((double) bytesRead / (double) bytesInFile));					for (int b = 0; b < st.mNumBottles; b++) {						int numV = sech.mNumVars;						Bottle bh = new Bottle(b, numV, st, sech);						for (int v = 0; v < numV; v++) {							int varVal = 0;							try {								varVal = inData.readShort();							}							catch (IOException e) {								System.out.println("IOException reading bottle");								e.printStackTrace();							}							bytesRead += 2;							if (varVal != JOAConstants.MISSINGVALUE) {								bh.mDValues[v] = (float) (varVal * tempProperties[v].getActScale() + tempProperties[v].getActOrigin());							}							else {								bh.mDValues[v] = JOAConstants.MISSINGVALUE;							}							// check for max and min							if (varVal != JOAConstants.MISSINGVALUE) {								if (varVal < varMin[v]) {									varMin[v] = varVal;								}								if (varVal > varMax[v]) {									varMax[v] = varVal;								}							}							// assign the quality flag as missing							bh.mQualityFlags[v] = (short) JOAConstants.MISSINGVALUE;						} // for v						st.mBottles.addElement(bh);					} // for b				} // for sc				// Update Temp Properties				for (int v = 0; v < numVars; v++) {					if (varMin[v] != JOAConstants.MISSINGVALUE && varMin[v] != 32000) {						tempProperties[v]						               .setPlotMin(varMin[v] * tempProperties[v].getActScale() + tempProperties[v].getActOrigin());					}					if (varMax[v] != JOAConstants.MISSINGVALUE && varMax[v] != 32000) {						tempProperties[v]						               .setPlotMax(varMax[v] * tempProperties[v].getActScale() + tempProperties[v].getActOrigin());					}				}				// reconcile tempProperties with AllProperties				for (int v = 0; v < numVars; v++) {					int newPos = mFV.getPropertyPos(tempProperties[v].getVarLabel(), false);					if (newPos < 0) {						// add new variable to AllProperties						String units = JOAFormulas.paramNameToJOAUnits(false, tempProperties[v].getVarLabel());						newPos = mFV.addNewProperty(tempProperties[v].getVarLabel(), units);						if (newPos >= 0) {							mFV.mAllProperties[newPos] = tempProperties[v];						}						else {							;						}					}					else {						// it does exist--update the parameter ranges						if (tempProperties[v].getPlotMin() < mFV.mAllProperties[newPos].getPlotMin()) {							mFV.mAllProperties[newPos].setPlotMin(tempProperties[v].getPlotMin());						}						if (tempProperties[v].getPlotMax() > mFV.mAllProperties[newPos].getPlotMax()) {							mFV.mAllProperties[newPos].setPlotMax(tempProperties[v].getPlotMax());						}					}				}			} // for s			// read the file comments			StringBuffer sb = null;			while (true) {				try {					// read continuation line					inShort = inData.readShort();					bytesRead += 2;					if (inShort == 1) {						// read number of bytes in file description string						inShort = inData.readShort();						bytesRead += 2;						// read the file description String						byte buf2[] = new byte[inShort];						inData.read(buf2, 0, inShort);						String commentLine = new String(buf2);						bytesRead += inShort;						if (sb == null) {							sb = new StringBuffer(commentLine);						}						else {							sb.append(commentLine);						}					}				}				catch (IOException e) {					break;				}			} // while true			if (sb != null) {				of.mFileComments = new String(sb);			}		}		catch (IOException e) {			readError = true;			throw e;		}		catch (NullPointerException e) {			readError = true;			throw e;		}		catch (ArrayIndexOutOfBoundsException e) {			readError = true;			throw e;		}		finally {			// clean up			if (readError && oldNumFiles != mFV.getNumOpenFiles()) {				for (int i = 0; i < (mFV.getNumOpenFiles() - oldNumFiles); i++) {					mFV.removeLastFile();				}				mFV.setNumOpenFiles(oldNumFiles);				mFV.setNumSections(oldNumSections);			}			if (in != null) {				try {					in.close();				}				catch (IOException e) {					;				}			}			progress.dispose();		}	}	public static void readSD2File(FileViewer mFV) throws FileImportException {		double minLat = 90.;		double maxLat = -90.;		double minLon = 360.;		double maxLon = -360.;		int totBots = 0;		String inLine = new String();		LineNumberReader in = null;		File mFile = mFV.getFile();		long bytesInFile = mFile.length();		long bytesRead = 0;		int[] ns = new int[2500];		String shipCode = "";		ProgressDialog progress = new ProgressDialog(mFV, "Reading SD2 Data...", Color.blue, Color.white);		progress.setVisible(true);		double[] min = new double[8];		double[] max = new double[8];		for (int i = 0; i < 8; i++) {			min[i] = 100000000;			max[i] = -100000000;		}		int nodcDummyStnNumber = 1;		try {			in = new LineNumberReader(new FileReader(mFile), 10000);			progress.setPercentComplete(100.0 * ((double) bytesRead / (double) bytesInFile));			// create a new open file object			OpenDataFile of = new OpenDataFile("Untitled");			mFV.addOpenFile(of);			// first pass on the data file to get number of actual bottles per cast			int sc = -1;			int stnNum = 0;			do {				// read a line				inLine = in.readLine();				if (inLine == null) {					break;				}				bytesRead += inLine.length();				progress.setPercentComplete(0.5 * (100.0 * ((double) bytesRead / (double) bytesInFile)));				if (inLine.length() == 0 && bytesRead < bytesInFile) {					continue;				}				// get the record type				String testStr = inLine.substring(79, 80);				int recordType = Integer.valueOf(testStr.trim()).intValue();				if (recordType == 1) {					// ExtractItem(inLine, 10, 4, testStr);					testStr = inLine.substring(9, 13);					int nodcStnNum = nodcDummyStnNumber;					try {						nodcStnNum = Integer.valueOf(testStr.trim()).intValue();					}					catch (Exception exx) {						nodcStnNum = JOAConstants.MISSINGVALUE;					}					// read the second station header					do {						inLine = in.readLine();						bytesRead += inLine.length();					} while (inLine.length() == 0 && bytesRead < bytesInFile);					if (inLine == null) {						break;					}					// ExtractItem(inLine, 80, 1, testStr);					testStr = inLine.substring(79, 80);					recordType = Integer.valueOf(testStr.trim()).intValue();					if (recordType != 2) {						// an error has occurred						throw new FileImportException();					}					sc++;					ns[sc] = 0;					// ExtractItem(inLine, 18, 9, testStr);					testStr = inLine.substring(17, 26);					// test to see if missing and if so use the nodc stn number					if (testStr.length() > 0) {						try {							stnNum = Integer.valueOf(testStr.trim()).intValue();						}						catch (NumberFormatException ex) {							stnNum = 0;						}						if (stnNum == 0) {							stnNum = nodcStnNum;						}					}					else {						stnNum = nodcStnNum;					}				}				else if (recordType == 3 || recordType == 4) {					ns[sc]++;				}			} while (bytesRead < bytesInFile);			in.close();			in = null;			in = new LineNumberReader(new FileReader(mFile), 10000);			// main loop			int ord = mFV.getTotalNumStations();			Station sh = null;			Section sech = null;			sc = -1;			int s = 0;			int c = 0;			bytesRead = 0;			int nodcStnNum = 0;			int bc = 0;			int numVars = 8;			Parameter[] tempProperties = new Parameter[8];			tempProperties[0] = new Parameter("PRES");			tempProperties[0].setReverseY(true);			tempProperties[0].setWasCalculated(false);			tempProperties[1] = new Parameter("TEMP");			tempProperties[1].setReverseY(false);			tempProperties[1].setWasCalculated(false);			tempProperties[2] = new Parameter("SALT");			tempProperties[2].setReverseY(false);			tempProperties[2].setWasCalculated(false);			tempProperties[3] = new Parameter("O2");			tempProperties[3].setReverseY(false);			tempProperties[3].setWasCalculated(false);			tempProperties[4] = new Parameter("PO4");			tempProperties[4].setReverseY(false);			tempProperties[4].setWasCalculated(false);			tempProperties[5] = new Parameter("SIO3");			tempProperties[5].setReverseY(false);			tempProperties[5].setWasCalculated(false);			tempProperties[6] = new Parameter("NO2");			tempProperties[6].setReverseY(false);			tempProperties[6].setWasCalculated(false);			tempProperties[7] = new Parameter("NO3");			tempProperties[7].setReverseY(false);			tempProperties[7].setWasCalculated(false);			double pres = 0.0;			double temp = 0.0;			double salt = 0.0;			double o2 = 0.0;			double po4 = 0.0;			double sio3 = 0.0;			double no2 = 0.0;			double no3 = 0.0;			double presMax = -100000000;			double presMin = 100000000;			double tempMax = -100000000;			double tempMin = 100000000;			double saltMax = -100000000;			double saltMin = 100000000;			double o2Max = -100000000;			double o2Min = 100000000;			double po4Max = -100000000;			double po4Min = 100000000;			double sio3Max = -100000000;			double sio3Min = 100000000;			double no2Max = -100000000;			double no2Min = 100000000;			double no3Max = -100000000;			double no3Min = 100000000;			do {				sc++;				// read master record 1--every record is considered a new section--store				// the section information				do {					inLine = in.readLine();					if (inLine == null) {						break;					}					bytesRead += inLine.length();				} while (inLine.length() == 0 && bytesRead < bytesInFile);				if (inLine == null) {					break;				}				progress.setPercentComplete(50 + (0.5 * (100.0 * ((double) bytesRead / (double) bytesInFile))));				// get the nodc consecutive station number				// ExtractItem(inLine, 10, 4, testStr);				String testStr = inLine.substring(9, 13);				try {					nodcStnNum = Integer.valueOf(testStr.trim()).intValue();				}				catch (NumberFormatException ex) {					nodcStnNum = 0;				}				if (s == 0) {					// ExtractItem(inLine, 54, 2, shipCode);					shipCode = inLine.substring(53, 55);					// create a new section object					of.mNumSections++;					String sectionName = mFile.getName().substring(0, mFile.getName().length() - 3);					sech = new Section(of.mNumSections, sectionName, shipCode, 0, 8);					of.addSection(sech);					s++;					c = 0;					// set the section color					mFV.addToTotalSections();					sech.mSectionColor = JOAFormulas.getSectionColor(mFV.getNumSections());					// install the parameters					tempProperties[0].setUnits(JOAFormulas.paramNameToJOAUnits(false, tempProperties[0].getVarLabel()));					tempProperties[1].setUnits(JOAFormulas.paramNameToJOAUnits(false, tempProperties[1].getVarLabel()));					tempProperties[2].setUnits(JOAFormulas.paramNameToJOAUnits(false, tempProperties[2].getVarLabel()));					tempProperties[3].setUnits(JOAFormulas.paramNameToJOAUnits(false, tempProperties[3].getVarLabel()));					tempProperties[4].setUnits(JOAFormulas.paramNameToJOAUnits(false, tempProperties[4].getVarLabel()));					tempProperties[5].setUnits(JOAFormulas.paramNameToJOAUnits(false, tempProperties[5].getVarLabel()));					tempProperties[6].setUnits(JOAFormulas.paramNameToJOAUnits(false, tempProperties[6].getVarLabel()));					tempProperties[7].setUnits(JOAFormulas.paramNameToJOAUnits(false, tempProperties[7].getVarLabel()));					sech.addNewVarToSection(tempProperties[0].getVarLabel(), tempProperties[0].getUnits());					sech.addNewVarToSection(tempProperties[1].getVarLabel(), tempProperties[0].getUnits());					sech.addNewVarToSection(tempProperties[2].getVarLabel(), tempProperties[0].getUnits());					sech.addNewVarToSection(tempProperties[3].getVarLabel(), tempProperties[0].getUnits());					sech.addNewVarToSection(tempProperties[4].getVarLabel(), tempProperties[0].getUnits());					sech.addNewVarToSection(tempProperties[5].getVarLabel(), tempProperties[0].getUnits());					sech.addNewVarToSection(tempProperties[6].getVarLabel(), tempProperties[0].getUnits());					sech.addNewVarToSection(tempProperties[7].getVarLabel(), tempProperties[0].getUnits());				}				// read lat and lon				char hem = inLine.charAt(26);				// ExtractItem(inLine, 28, 2, testStr);				testStr = inLine.substring(27, 29);				double degs = Double.valueOf(testStr.trim()).doubleValue();				// ExtractItem(inLine, 30, 2, testStr);				testStr = inLine.substring(29, 31);				double mins = Double.valueOf(testStr.trim()).doubleValue();				// ExtractItem(inLine, 32, 1, testStr);				testStr = inLine.substring(31, 32);				double tenths = 0.0;				try {					tenths = Double.valueOf(testStr.trim()).doubleValue();				}				catch (NumberFormatException ex) {				}				double myLat = degs + (mins + (tenths / 10)) / 60;				myLat = hem == 'S' ? -myLat : myLat;				hem = inLine.charAt(32);				// ExtractItem(inLine, 34, 3, testStr);				testStr = inLine.substring(33, 36);				degs = Double.valueOf(testStr.trim()).doubleValue();				// ExtractItem(inLine, 37, 2, testStr);				testStr = inLine.substring(36, 38);				mins = Double.valueOf(testStr.trim()).doubleValue();				// ExtractItem(inLine, 39, 1, testStr);				testStr = inLine.substring(38, 39);				tenths = 0.0;				try {					tenths = Double.valueOf(testStr.trim()).doubleValue();				}				catch (NumberFormatException ex) {				}				double myLon = degs + (mins + (tenths / 10)) / 60;				myLon = hem == 'W' ? -myLon : myLon;				maxLat = myLat > maxLat ? myLat : maxLat;				minLat = myLat < minLat ? myLat : minLat;				// test to see if cruise crosses the dateline				double myLon0 = 0;				if ((myLon >= -180 && myLon < -178) && (myLon0 >= 178 && myLon0 <= 180)) {				}				else if ((myLon >= 178 && myLon <= 180) && (myLon0 >= -180 && myLon0 < -178)) {				}				// convert all latitudes to the range -360 to 0				double testLon = 0;				if (myLon > 0) {					testLon = myLon /* - 360 */;				}				else {					testLon = myLon;				}				// compute min and max longitude				minLon = testLon < minLon /*-360*/? myLon : minLon;				maxLon = testLon > maxLon /*-360*/? myLon : maxLon;				myLon0 = myLon;				// read the date				// ExtractItem(inLine, 41, 2, testStr);				testStr = inLine.substring(40, 42);				double yy = 1900;				try {					yy = 1900 + Double.valueOf(testStr.trim()).doubleValue();				}				catch (NumberFormatException ex) {				}				// ExtractItem(inLine, 43, 2, testStr);				testStr = inLine.substring(42, 44);				double mm = 1.0;				try {					mm = Double.valueOf(testStr.trim()).doubleValue();				}				catch (NumberFormatException ex) {				}				// ExtractItem(inLine, 45, 2, testStr);				testStr = inLine.substring(44, 46);				double dd = 1.0;				try {					dd = Double.valueOf(testStr.trim()).doubleValue();				}				catch (NumberFormatException ex) {				}				// ExtractItem(inLine, 47, 3, testStr);				testStr = inLine.substring(46, 49);				double fhr = 0.0;				try {					fhr = Double.valueOf(testStr.trim()).doubleValue() / 10.0;				}				catch (NumberFormatException ex) {				}				int hr = (int) Math.floor(fhr);				double rmn = fhr - (double) hr;				double dmin = rmn * 60;				int mn = (int) dmin;				// read the depth				// ExtractItem(inLine, 56, 5, testStr);				double z = JOAConstants.MISSINGVALUE;				testStr = inLine.substring(55, 60);				if (testStr.length() > 0) {					z = 0.0;					try {						z = Double.valueOf(testStr.trim()).doubleValue();					}					catch (NumberFormatException ex) {					}				}				// read master record 2				do {					inLine = in.readLine();					if (inLine == null) {						break;					}					bytesRead += inLine.length();				} while (inLine.length() == 0 && bytesRead < bytesInFile);				if (inLine == null) {					break;				}				// read the station number				// ExtractItem(inLine, 18, 9, testStr);				testStr = inLine.substring(17, 26);				// test to see if missing and if so use the nodc stn number				if (testStr.length() > 0) {					try {						stnNum = Integer.valueOf(testStr.trim()).intValue();						if (stnNum == 0) {							stnNum = nodcStnNum;						}					}					catch (NumberFormatException ex) {						stnNum = nodcStnNum;					}				}				else {					stnNum = nodcStnNum;				}				// use the number of obs from first pass				int numObs = ns[sc];				// new Station found				sech.mNumCasts++;				// begin counting up number of obs read				int obsRead = 1; // 1 because we've already read the first one				// read the cast headers				ord++;				sh = new Station(ord, shipCode, String.valueOf(stnNum), 1, myLat, myLon, 0, (int) yy, (int) mm, (int) dd,						(int) hr, (int) mn, (int) z, JOAConstants.MISSINGVALUE, null, null);				sech.mStations.addElement(sh);				sh.setType("BOTTLE");				mFV.addToTotalStations(1);				if (c == 0) { // first cast in section				}				if (c == 0 /* && gNumSections == 1 */) { // different than file.c, here					// gNumSections					; // gCurrStn = (*sech)->StationHead; // == 1 => first file ever read				}				// assign numBottles				sh.mNumBottles = numObs;				totBots += sh.mNumBottles;				c++;				// read the detail records				for (int i = 0; i < numObs; i++) {					do {						inLine = in.readLine();						if (inLine == null) {							break;						}						bytesRead += inLine.length();					} while (inLine.length() == 0 && bytesRead < bytesInFile);					if (inLine == null) {						break;					}					// make sure this is not the last detail record					// ExtractItem(inLine, 79, 1, testStr);					testStr = inLine.substring(78, 79);					int nextRecType = 0;					try {						nextRecType = Integer.valueOf(testStr.trim()).intValue();					}					catch (NumberFormatException ex) {						nextRecType = 0;					}					if (nextRecType == 1 && i + 1 != numObs) {						// premature end of detail						totBots -= numObs - i - 1;						numObs = i + 1;						sh.mNumBottles = numObs;						break;					}					// make a new bottle					Bottle bh = new Bottle(bc++, 7, sh, sech);					for (int v = 0; v < numVars; v++) {						bh.mDValues[v] = JOAConstants.MISSINGVALUE;						bh.mQualityFlags[v] = (short) JOAConstants.MISSINGVALUE;					}					// depth					// ExtractItem(inLine, 1, 5, testStr);					testStr = inLine.substring(0, 5);					try {						z = Double.valueOf(testStr.trim()).doubleValue();					}					catch (NumberFormatException ex) {						z = 0;					}					pres = JOAFormulas.zToPres(z);					// temperature					// ExtractItem(inLine, 8, 5, testStr);					testStr = inLine.substring(7, 12);					try {						temp = Double.valueOf(testStr.trim()).doubleValue();						// ExtractItem(inLine, 13, 1, testStr);						testStr = inLine.substring(12, 13);						int prec = Integer.valueOf(testStr.trim()).intValue();						if (prec != 9) {							temp = temp / (Math.pow(10, (double) prec));						}						else {							temp = JOAConstants.MISSINGVALUE;						}					}					catch (NumberFormatException ex) {						temp = JOAConstants.MISSINGVALUE;					}					// salinity					// ExtractItem(inLine, 15, 5, testStr);					testStr = inLine.substring(14, 19);					try {						salt = Double.valueOf(testStr.trim()).doubleValue();						// ExtractItem(inLine, 20, 1, testStr);						testStr = inLine.substring(19, 20);						int prec = Integer.valueOf(testStr.trim()).intValue();						if (prec != 9) {							salt = salt / (Math.pow(10, (double) prec));						}						else {							salt = JOAConstants.MISSINGVALUE;						}					}					catch (NumberFormatException ex) {						salt = JOAConstants.MISSINGVALUE;					}					// oxygen					// ExtractItem(inLine, 33, 4, testStr);					testStr = inLine.substring(32, 36);					try {						o2 = Double.valueOf(testStr.trim()).doubleValue();						// ExtractItem(inLine, 37, 1, testStr);						testStr = inLine.substring(36, 37);						int prec = Integer.valueOf(testStr.trim()).intValue();						if (prec != 9) {							o2 = o2 / (Math.pow(10, (double) prec));						}						else {							o2 = JOAConstants.MISSINGVALUE;						}					}					catch (NumberFormatException ex) {						o2 = JOAConstants.MISSINGVALUE;					}					// phosphate					// ExtractItem(inLine, 49, 4, testStr);					testStr = inLine.substring(48, 52);					try {						po4 = Double.valueOf(testStr.trim()).doubleValue();						// ExtractItem(inLine, 53, 1, testStr);						testStr = inLine.substring(52, 53);						int prec = Integer.valueOf(testStr.trim()).intValue();						if (prec != 9) {							po4 = po4 / (Math.pow(10, (double) prec));						}						else {							po4 = JOAConstants.MISSINGVALUE;						}					}					catch (NumberFormatException ex) {						po4 = JOAConstants.MISSINGVALUE;					}					// silicate					// ExtractItem(inLine, 59, 4, testStr);					testStr = inLine.substring(58, 62);					try {						sio3 = Double.valueOf(testStr.trim()).doubleValue();						// ExtractItem(inLine, 63, 1, testStr);						testStr = inLine.substring(62, 63);						int prec = Integer.valueOf(testStr.trim()).intValue();						if (prec != 9) {							sio3 = sio3 / (Math.pow(10, (double) prec));						}						else {							sio3 = JOAConstants.MISSINGVALUE;						}					}					catch (NumberFormatException ex) {						sio3 = JOAConstants.MISSINGVALUE;					}					// nitrite					// ExtractItem(inLine, 64, 3, testStr);					testStr = inLine.substring(63, 66);					try {						no2 = Double.valueOf(testStr.trim()).doubleValue();						;						// ExtractItem(inLine, 67, 1, testStr);						testStr = inLine.substring(66, 67);						int prec = Integer.valueOf(testStr.trim()).intValue();						if (prec != 9) {							no2 = no2 / (Math.pow(10, (double) prec));						}						else {							no2 = JOAConstants.MISSINGVALUE;						}					}					catch (NumberFormatException ex) {						no2 = JOAConstants.MISSINGVALUE;					}					// nitrate					// ExtractItem(inLine, 68, 3, testStr);					testStr = inLine.substring(67, 70);					try {						no3 = Double.valueOf(testStr.trim()).doubleValue();						// ExtractItem(inLine, 71, 1, testStr);						testStr = inLine.substring(70, 71);						int prec = Integer.valueOf(testStr.trim()).intValue();						if (prec != 9) {							no3 = no3 / (Math.pow(10, (double) prec));						}						else {							no3 = JOAConstants.MISSINGVALUE;						}					}					catch (NumberFormatException ex) {						no3 = JOAConstants.MISSINGVALUE;					}					int castNum = 0;					// ExtractItem(inLine, 48, 1, testStr);					testStr = inLine.substring(47, 48);					try {						castNum = Integer.valueOf(testStr.trim()).intValue();					}					catch (NumberFormatException ex) {						castNum = JOAConstants.MISSINGVALUE;					}					sh.mCastNum = castNum;					// add these to the bottle					bh.mDValues[0] = (float) pres;					bh.mDValues[1] = (float) temp;					bh.mDValues[2] = (float) salt;					bh.mDValues[3] = (float) o2;					bh.mDValues[4] = (float) po4;					bh.mDValues[5] = (float) sio3;					bh.mDValues[6] = (float) no2;					bh.mDValues[7] = (float) no3;					obsRead++;					sh.mBottles.addElement(bh);					// compute the max and mins					max[0] = presMax = pres > presMax && pres != JOAConstants.MISSINGVALUE ? pres : presMax;					min[0] = presMin = pres < presMin && pres != JOAConstants.MISSINGVALUE ? pres : presMin;					max[1] = tempMax = temp > tempMax && temp != JOAConstants.MISSINGVALUE ? temp : tempMax;					min[1] = tempMin = temp < tempMin && temp != JOAConstants.MISSINGVALUE ? temp : tempMin;					max[2] = saltMax = salt > saltMax && salt != JOAConstants.MISSINGVALUE ? salt : saltMax;					min[2] = saltMin = salt < saltMin && salt != JOAConstants.MISSINGVALUE ? salt : saltMin;					max[3] = o2Max = o2 > o2Max && o2 != JOAConstants.MISSINGVALUE ? o2 : o2Max;					min[3] = o2Min = o2 < o2Min && o2 != JOAConstants.MISSINGVALUE ? o2 : o2Min;					max[4] = po4Max = po4 > po4Max && po4 != JOAConstants.MISSINGVALUE ? po4 : po4Max;					min[4] = po4Min = po4 < po4Min && po4 != JOAConstants.MISSINGVALUE ? po4 : po4Min;					max[5] = sio3Max = sio3 > sio3Max && sio3 != JOAConstants.MISSINGVALUE ? sio3 : sio3Max;					min[5] = sio3Min = sio3 < sio3Min && sio3 != JOAConstants.MISSINGVALUE ? sio3 : sio3Min;					max[6] = no2Max = no2 > no2Max && no2 != JOAConstants.MISSINGVALUE ? no2 : no2Max;					min[6] = no2Min = no2 < no2Min && no2 != JOAConstants.MISSINGVALUE ? no2 : no2Min;					max[7] = no3Max = no3 > no3Max && no3 != JOAConstants.MISSINGVALUE ? no3 : no3Max;					min[7] = no3Min = no3 < no3Min && no3 != JOAConstants.MISSINGVALUE ? no3 : no3Min;				}			} while (bytesRead < bytesInFile);			// have read all the data and the lists have been constructed			// reconcile tempProperties with AllProperties			double[] offset = new double[1000];			double[] dfactor = new double[1000];			short factor;			double range;			for (int v = 0; v < numVars; v++) {				tempProperties[v].setCastOrObs(JOAConstants.ALL_OBS);				int newPos = mFV.getPropertyPos(tempProperties[v].getVarLabel(), false);				if (newPos < 0) {					// variable doesn't exist--check if it's a default property					int d = JOAFormulas.isDefaultVar(tempProperties[v].getVarLabel());					if (d >= 0) {						// is a default--add using default factors						dfactor[v] = JOAConstants.defaultProperties[d].getActScale();						offset[v] = JOAConstants.defaultProperties[d].getActOrigin();						tempProperties[v].setActScale((double) dfactor[v]);						tempProperties[v].setActOrigin((double) offset[v]);						tempProperties[v].setPlotMin(min[v]);						tempProperties[v].setPlotMax(max[v]);						newPos = mFV.addNewProperty(tempProperties[v].getVarLabel(), tempProperties[v].getUnits());						if (newPos >= 0) {							mFV.mAllProperties[newPos] = tempProperties[v];						}						else {							; // an unknown error has occurred						}					}					else {						if (max[v] == -100000000) {							// all data for this variable are missing							tempProperties[v].setActScale(1.0);							tempProperties[v].setActOrigin(0.0);							tempProperties[v].setPlotMin(0.0);							tempProperties[v].setPlotMax(0.0);						}						else {							offset[v] = Math.floor(min[v]);							range = max[v] - offset[v];							factor = (short) JOAFormulas.log10((double) JOAConstants.TWOBYTES / range);							factor = (short) Math.pow(10, (double) factor);							dfactor[v] = (double) 1 / (double) factor;							int i = 1;							while (offset[v] / dfactor[v] >= JOAConstants.TWOBYTES /*							 * &&							 * offset[v] >							 * 1000							 */) {								// overflow occurred								min[v] = min[v];								offset[v] = Math.floor(min[v] - (10 * i++));								range = max[v] - offset[v];								factor = (short) JOAFormulas.log10((double) JOAConstants.TWOBYTES / range);								factor = (short) Math.pow(10, (double) factor);								dfactor[v] = (double) 1 / (double) factor;							}							// store this in the property array							tempProperties[v].setActScale((double) dfactor[v]);							tempProperties[v].setActOrigin((double) offset[v]);							tempProperties[v].setPlotMin(min[v]);							tempProperties[v].setPlotMax(max[v]);						}						// not a default property--add property						newPos = mFV.addNewProperty(tempProperties[v].getVarLabel(), new String(""));						if (newPos >= 0) {							mFV.mAllProperties[newPos] = tempProperties[v];						}						else {							; // an unknown error has occurred						}					}				}				else {					// variable already exists--use existing values for conversion					dfactor[v] = mFV.mAllProperties[newPos].getActScale();					offset[v] = mFV.mAllProperties[newPos].getActOrigin();					min[v] = mFV.mAllProperties[newPos].getPlotMin();					max[v] = mFV.mAllProperties[newPos].getPlotMax();					tempProperties[v].setActScale((double) dfactor[v]);					tempProperties[v].setActOrigin((double) offset[v]);					tempProperties[v].setPlotMin(min[v]);					tempProperties[v].setPlotMax(max[v]);				}			}		}		catch (IOException ex) {			ex.printStackTrace();		}		finally {			progress.dispose();		}	}	public static void importWOD(FileViewer mFV) throws FileImportException {		double minLat = 90.;		double maxLat = -90.;		double minLon = 360.;		double maxLon = -360.;		File mFile = mFV.getFile();		long bytesInFile = mFile.length();		long bytesRead = 0;		int QCStandard = JOAConstants.WOCE_QC_STD;		boolean useQCStd = false;		int mCastCount = 0;		HashMap<String, double[]> varMinsBySection = new HashMap<String, double[]>();		HashMap<String, double[]> varMaxsBySection = new HashMap<String, double[]>();		HashMap<String, Parameter[]> tempPropsBySection = new HashMap<String, Parameter[]>();		HashMap<String, Section> allSections = new HashMap<String, Section>();		DepthConversionRule mDepthConversionRule = DepthConversionRule.CONVERT_DEPTH_TO_PRESSURE;		PreferPressureParameterRule mPreferPressureParameterRule = PreferPressureParameterRule.PREFER_PRESSURE_PARAMETER;		// read the file		ProgressDialog progress = new ProgressDialog(mFV, "Reading WOD Data...", Color.blue, Color.white);		progress.setVisible(true);		try {			// create a WOD CSV reader			WODCSVReader reader = new WODCSVReader(mFV.getFile().getPath(), CastIDRule.ORIG_STN_ID, SectionIDRule.ORIG_CRUISE_ID,					CastNumberRule.JOA_SUBSTITUTION, WODQCStandard.WOCE, null);			long fileSizeInBytes = reader.getFileLength();			long startTime = System.currentTimeMillis();			// create a new open file object			OpenDataFile of = new OpenDataFile("Untitled");			mFV.addOpenFile(of);			// read the WOD Data			int bc = 0; // number of bottles read			//			String oldSecDescrip = new String("");			//			String oldStn = new String();			//			double oldLat = JOAConstants.MISSINGVALUE;			//			double oldLon = JOAConstants.MISSINGVALUE;			String stnNum;			int castNum;			double lat;			double lon;			int ord = mFV.getTotalNumStations();			Station sh = null;			double mMaxDepth = 0.0;			boolean eof = true;			long cumLength = 0;			String depthUnits = "";			int pressurePos = -99;			int tempPos = -99;			int depthPos = -99;			TemperatureScale tempScale = TemperatureScale.UNKNOWN;			while (eof) {				// Read to a cast that has profile data				try {					reader.readCast();					cumLength += reader.getCastLength();					mCastCount++;				}				catch (Exception ex) {					//						System.out.println("Exiting loop");					break;				}				progress.setPercentComplete(((double)cumLength/(double)fileSizeInBytes) * 100.0);				if (!reader.isValidProfile()) {					continue;				}				// read the metadata that identify the cast				List<String[]> stnmeta = reader.getCastMetaData();				String sectionDescrip = reader.getSectionID(stnmeta);								if (sectionDescrip == null || sectionDescrip.length() == 0) {					System.out.println("Skipping a section");					continue;				}				lat = reader.getLatitude(stnmeta);				lon = reader.getLongitude(stnmeta);				// update max and min positions				maxLat = lat > maxLat ? lat : maxLat;				minLat = lat < minLat ? lat : minLat;				// convert all longitudes to the range -360 to 0				double testLon = 0;				if (lon > 0) {					testLon = lon /* - 360 */;				}				else {					testLon = lon;				}				// compute min and max longitude				minLon = testLon < minLon /*-360*/? lon : minLon;				maxLon = testLon > maxLon /*-360*/? lon : maxLon;				boolean dateErr = false;				GeoDate date = reader.getCastDate(stnmeta);				if (date == null) {					date = new GeoDate();					dateErr = true;				}				stnNum = reader.getCastID(stnmeta);				castNum = reader.getCastNumber(stnmeta);				List<String[]> meta = reader.getTaggedMetaData();				double bottomDepth = reader.getBottomDepth(meta);				if (bottomDepth != JOAConstants.MISSINGVALUE) {					mMaxDepth = bottomDepth > mMaxDepth ? bottomDepth : mMaxDepth;				}				String shipCode = reader.getPlatform(meta);				WODQCStandard qcStandard = reader.getOriginatorsQCConvention(meta);				Section sech = allSections.get(sectionDescrip);				if (sech == null) {					// only read the parameter info if we have a new section					List<String[]> varSection = reader.getVariableMetaData();					List<String[]> paramsWithScale = reader.getParametersWithScale(meta);					List<String> paramList = reader.getWODParameters(varSection, ConvertParameterNamesRule.CONVERT_TO_JOA_LEXICON);					List<String> unitsList = reader.getWODAssignedUnits(varSection);//					List<Integer> flagList = reader.getProfileFlags(varSection);										tempPos = reader.getParamPos("temp", paramList, true);					depthPos = reader.getParamPos("depth", paramList, false);				  depthUnits = reader.getDepthUnits(paramList, unitsList);					pressurePos = reader.getPressurePos(paramList, unitsList);										// get the temperature scale 					tempScale = reader.getTempScale(paramsWithScale);										double varMin[] = new double[1000];					double varMax[] = new double[1000];					//initialize the max/min variables					for (int i = 0; i < 1000; i++) {						varMin[i] = 32000;						varMax[i] = -32000;					}					varMinsBySection.put(sectionDescrip, varMin);					varMaxsBySection.put(sectionDescrip, varMax);					int numVars = 0;					Parameter[] tempProperties = new Parameter[1000];					for (int i=0; i<paramList.size(); i++) {						// make a new parameter						String param = JOAFormulas.paramNameToJOAName(paramList.get(i).trim());						String units = unitsList.get(i);												 if (depthPos >= 0 && i == depthPos && mDepthConversionRule == DepthConversionRule.CONVERT_DEPTH_TO_PRESSURE ||								 pressurePos >= 0 && mPreferPressureParameterRule == PreferPressureParameterRule.PREFER_PRESSURE_PARAMETER) {							 	// rename pressure and units							 param = "PRES";							 units = "db";						 }						tempProperties[numVars] = new Parameter(param, units);						tempProperties[numVars].setReverseY(JOAFormulas.isParamReversed(param));						tempProperties[numVars].setWasCalculated(false);						if (param.equalsIgnoreCase("PRES") || param.startsWith("DEPT") || param.startsWith("Z")) {							tempProperties[numVars].setActScale(1.0);							tempProperties[numVars].setActOrigin(0.0);						}						numVars++;					}										tempPropsBySection.put(sectionDescrip, tempProperties);					// create a new section					of.mNumSections++;					sech = new Section(of.mNumSections, sectionDescrip, shipCode, 0, numVars);					of.addSection(sech);					sech.setQCStandard(QCStandard);					allSections.put(sectionDescrip, sech);					// set the section color					mFV.addToTotalSections();					sech.mSectionColor = JOAFormulas.getSectionColor(mFV.getNumSections());					for (int v = 0; v < numVars; v++) {						sech.addNewVarToSection(tempProperties[v].getVarLabel(), tempProperties[v].getUnits());					}				}				sech.mNumCasts++;				ord++;				sh = new Station(ord, shipCode, stnNum, castNum, lat, lon, 0, date.getYear(), date.getMonth(), 						date.getDay(), date.getHours(), date.getMinutes(),						(int) bottomDepth, JOAConstants.MISSINGVALUE, null, null);				sech.mStations.addElement(sh);				sh.setType("BOTTLE");				sh.mDateError = dateErr;				bc = 0;				mFV.addToTotalStations(1);				mFV.setMaxDepth(mMaxDepth);				// read the bottle data into current station				Bottle[] newBots = reader.getParameterData(bc, sh, sech, DepthConversionRule.CONVERT_DEPTH_TO_PRESSURE,						PreferPressureParameterRule.PREFER_PRESSURE_PARAMETER, depthPos, depthUnits, pressurePos,						qcStandard, tempScale, TempConversionRule.ITS90_TO_IPTS68, tempPos);				sh.mNumBottles = newBots.length;				// update max and mins for this section and add bottles to Station				double varMin[] = varMinsBySection.get(sectionDescrip);				double varMax[] = varMaxsBySection.get(sectionDescrip);				for (int i=0; i<newBots.length; i++) {					Bottle bh = newBots[i];					for (int v=0; v<sech.mNumVars; v++) {						if (bh.mDValues[v] != JOAConstants.MISSINGVALUE) {							if (bh.mDValues[v] < varMin[v]) {								varMin[v] = bh.mDValues[v];							}							if (bh.mDValues[v] > varMax[v]) {								varMax[v] = bh.mDValues[v];							}						}					}					sh.mBottles.addElement(bh);				}				// store bottle count in last stn of previous section				JOAFormulas.sortBottlesByPres(sech, sh);				// Update Temp Properties				Parameter[] tempProperties = tempPropsBySection.get(sectionDescrip);				for (int v = 0; v < tempProperties.length; v++) {					if (varMin[v] != JOAConstants.MISSINGVALUE && varMin[v] != 32000) {						tempProperties[v].setPlotMin(varMin[v]);					}					if (varMax[v] != JOAConstants.MISSINGVALUE && varMax[v] != -32000) {						tempProperties[v].setPlotMax(varMax[v]);					}				}			} // end of big while loop			progress.setPercentComplete(100.0);			progress.dispose();			double secs = (double)(System.currentTimeMillis() - startTime)/1000.0;			System.out.println("Read " + mCastCount + " casts in "+ secs + "seconds (" + mCastCount/secs + ")");			// store bottle count in last stn of previous section			Section lastSec = (Section) of.mSections.lastElement();			Station lastStn = (Station) lastSec.mStations.lastElement();			lastStn.mNumBottles = lastStn.mBottles.size();			JOAFormulas.sortBottlesByPres(lastSec, lastStn);						for (Section sech: allSections.values()) {				String sectionDescrip = sech.mSectionDescription;				Parameter[] tempProperties = tempPropsBySection.get(sectionDescrip);				double varMin[] = varMinsBySection.get(sectionDescrip);				double varMax[] = varMaxsBySection.get(sectionDescrip);				int numVarsBySection = sech.mNumVars;								// Update temp Properties for each section				for (int v = 0; v < numVarsBySection; v++) {					if (varMin[v] != JOAConstants.MISSINGVALUE && varMin[v] != 32000) {						tempProperties[v].setPlotMin(varMin[v]);					}					if (varMax[v] != JOAConstants.MISSINGVALUE && varMax[v] != -32000) {						tempProperties[v].setPlotMax(varMax[v]);					}				}								// reconcile tempProperties with AllProperties				for (int v = 0; v < numVarsBySection; v++) {					int newPos = mFV.getPropertyPos(tempProperties[v].getVarLabel(), false);					if (newPos < 0) {						// variable doesn't exist--check if it's a default property						int d = JOAFormulas.isDefaultVar(tempProperties[v].getVarLabel());						if (d >= 0) {							// is a default--add using default factors							double dfactor = JOAConstants.defaultProperties[d].getActScale();							double offset = JOAConstants.defaultProperties[d].getActOrigin();							tempProperties[v].setActScale(dfactor);							tempProperties[v].setActOrigin(offset);							tempProperties[v].setPlotMin(varMin[v]);							tempProperties[v].setPlotMax(varMax[v]);							newPos = mFV.addNewProperty(tempProperties[v].getVarLabel(), tempProperties[v].getUnits());							if (newPos >= 0) {								mFV.mAllProperties[newPos] = tempProperties[v];							}							else {								; // an unknown error has occurred							}						}						else {							// isn't a default							if (varMax[v] == -32000) {								// all data for this variable are missing								tempProperties[v].setActScale(1.0);								tempProperties[v].setActOrigin(0.0);								tempProperties[v].setPlotMin(0.0);								tempProperties[v].setPlotMax(0.0);							}							else {								double offset = Math.floor(varMin[v]);								double range = varMax[v] - offset;								double factor = (short) (JOAFormulas.log10((double) JOAConstants.TWOBYTES / range));								factor = Math.pow(10, (double) factor);								double dfactor = (double) 1 / (double) factor;								int i = 1;								while (offset / dfactor >= JOAConstants.TWOBYTES /*								 * && offset[v] >								 * 1000								 */) {									// overflow occurred									varMin[v] = varMin[v];									offset = Math.floor(varMin[v] - (10 * i++));									range = varMax[v] - offset;									factor = (short) JOAFormulas.log10((double) JOAConstants.TWOBYTES / range);									factor = Math.pow(10, (double) factor);									dfactor = (double) 1 / (double) factor;								}								// store this in the property array								tempProperties[v].setActScale(dfactor);								tempProperties[v].setActOrigin(offset);								tempProperties[v].setPlotMin(varMin[v]);								tempProperties[v].setPlotMax(varMax[v]);							}							// not a default property--add property							newPos = mFV.addNewProperty(tempProperties[v].getVarLabel(), tempProperties[v].getUnits());							if (newPos >= 0) {								mFV.mAllProperties[newPos] = tempProperties[v];							}							else {								; // an unknown error has occurred							}						}					}					else {						// it does exist--update the parameter ranges						if (tempProperties[v].getPlotMin() < mFV.mAllProperties[newPos].getPlotMin()) {							mFV.mAllProperties[newPos].setPlotMin(tempProperties[v].getPlotMin());						}						if (tempProperties[v].getPlotMax() > mFV.mAllProperties[newPos].getPlotMax()) {							mFV.mAllProperties[newPos].setPlotMax(tempProperties[v].getPlotMax());						}					}				}			}		}		catch (Exception ex) {			ex.printStackTrace();			if (ex instanceof FileImportException) {				throw (FileImportException) ex;			}			else {				FileImportException fie = new FileImportException();				fie.setErrorType("An unknown error occurred parsing this file!");				throw (fie);			}		}		finally {			progress.dispose();		}	}	public static void importSpreadSheet(FileViewer mFV) throws FileImportException {		double minLat = 90.;		double maxLat = -90.;		double minLon = 360.;		double maxLon = -360.;		String inLine = new String();		LineNumberReader in = null;		double varMin[] = new double[1000];		double varMax[] = new double[1000];		File mFile = mFV.getFile();		long bytesInFile = mFile.length();		long bytesRead = 0;		int QCStandard = JOAConstants.IGOSS_QC_STD;		boolean useQCStd = false;		int lnCnt = 0;		Parameter tempProperties[] = new Parameter[1000];		// read the file		ProgressDialog progress = new ProgressDialog(mFV, "Reading Spreadsheet Data...", Color.blue, Color.white);		progress.setVisible(true);		for (int i = 0; i < 1000; i++) {			varMin[i] = 32000;			varMax[i] = -32000;		}		try {			in = new LineNumberReader(new FileReader(mFile), 10000);			progress.setPercentComplete(100.0 * ((double) bytesRead / (double) bytesInFile));			// create a new open file object			OpenDataFile of = new OpenDataFile("Untitled");			mFV.addOpenFile(of);			// read the column header line			inLine = in.readLine();			bytesRead += inLine.length();			lnCnt++;			// convert string to uppercase			String inLineLC = new String(inLine);			inLine = inLine.toUpperCase();			// find the columns of important stuff			// Use the custom delimiter here			JOAConstants.DELIMITER = JOAConstants.IMPORTDELIMITER;			String[] secStrings = { "SEC", "SE", "WHP-ID", "PROJECT", "ID", "NAME", "EXP" };			int[] secStrictness = { JOAConstants.STARTSWITH, JOAConstants.MATCHES, JOAConstants.MATCHES,					JOAConstants.MATCHES, JOAConstants.MATCHES, JOAConstants.MATCHES, JOAConstants.MATCHES };			int secNamePos = JOAFormulas.getItemNumber(inLine, secStrings, secStrictness);			String[] shipStrings = { "SHIP", "SHP", "SH", "VESSEL", "SHIP" };			int[] shipStrictness = { JOAConstants.MATCHES, JOAConstants.MATCHES, JOAConstants.MATCHES, JOAConstants.MATCHES,					JOAConstants.STARTSWITH };			int shipPos = JOAFormulas.getItemNumber(inLine, shipStrings, shipStrictness);			String[] stnStrings = { "STA", "STATION", "ST", "STN", "STN" };			int[] stnStrictness = { JOAConstants.MATCHES, JOAConstants.MATCHES, JOAConstants.MATCHES,					JOAConstants.STARTSWITH, JOAConstants.CONTAINS };			int stnNumPos = JOAFormulas.getItemNumber(inLine, stnStrings, stnStrictness);			String[] castStrings = { "CA", "CAST", "CST" };			int[] castStrictness = { JOAConstants.MATCHES, JOAConstants.STARTSWITH, JOAConstants.STARTSWITH };			int castNumPos = JOAFormulas.getItemNumber(inLine, castStrings, castStrictness);			String[] latStrings = { "LAT", "LA", "LAT" };			int[] latStrictness = { JOAConstants.STARTSWITH, JOAConstants.MATCHES, JOAConstants.CONTAINS };			int latPos = JOAFormulas.getItemNumber(inLine, latStrings, latStrictness);			String[] lonStrings = { "LON", "LO", "LON" };			int[] lonStrictness = { JOAConstants.STARTSWITH, JOAConstants.MATCHES, JOAConstants.CONTAINS };			int lonPos = JOAFormulas.getItemNumber(inLine, lonStrings, lonStrictness);			String[] dateStrings = { "DA", "DAT", "DATE", "DATE" };			int[] dateStrictness = { JOAConstants.MATCHES, JOAConstants.MATCHES, JOAConstants.CONTAINS, JOAConstants.MATCHES };			int datePos = JOAFormulas.getItemNumber(inLine, dateStrings, dateStrictness);			String[] timeStrings = { "T", "TIM", "TIME", "TIME" };			int[] timeStrictness = { JOAConstants.MATCHES, JOAConstants.MATCHES, JOAConstants.MATCHES,					JOAConstants.STARTSWITH };			int timePos = JOAFormulas.getItemNumber(inLine, timeStrings, timeStrictness);			String[] bottStrings = { "BOTTOM", "WATER DEPTH", "ZBOT" };			int[] bottStrictness = { JOAConstants.STARTSWITH, JOAConstants.MATCHES, JOAConstants.MATCHES };			int bottomPos = JOAFormulas.getItemNumber(inLine, bottStrings, bottStrictness);			String[] presStrings = { "PRES", "DEPTH", "P", "PR", "CTDP", "DEPTH", "Z", "REVPRS" };			int[] presStrictness = { JOAConstants.MATCHES, JOAConstants.STARTSWITH, JOAConstants.MATCHES,					JOAConstants.STARTSWITH, JOAConstants.STARTSWITH, JOAConstants.MATCHES, JOAConstants.MATCHES,					JOAConstants.MATCHES};			int paramStartPos = JOAFormulas.getItemNumber(inLine, presStrings, presStrictness);			// test for missing required stuff			if ((stnNumPos == -1 && castNumPos == -1) || latPos == -1 || lonPos == -1 || paramStartPos == -1) {				// throw an exception				FileImportException fie = new FileImportException();				fie.setErrorType("A required field is missing from input file ((stn or cast) or lat or lon or params)");				fie.setErrorLine(1);				throw (fie);			}			// get the individual parameters			int ic = paramStartPos;			int numVars = 0;			boolean[] hasQC = new boolean[1000];			int[] varPos = new int[1000];			while (true) {				hasQC[numVars] = false;				String param = JOAFormulas.getItem(inLineLC, ic);				if (param == null || param.length() == 0) {					break;				}				// test if this is a QC Flag				if (param.indexOf("FLAG") >= 0 && numVars > 0) {					// Quality Code					hasQC[numVars - 1] = true;					if (param.indexOf("_W") >= 0) {						QCStandard = JOAConstants.WOCE_QC_STD;					}					useQCStd = true;				}				else {					// break this into param name and units					// store the current delimiter					char oldDelim = JOAConstants.DELIMITER;					String units = new String("");					if (param.indexOf(' ') > 0) {						// number of items						JOAConstants.DELIMITER = ' ';						int numItems = JOAFormulas.numItems(param) + 1;						if (numItems > 2) {							int start = param.indexOf(' ');							units = param.substring(start);						}						else {							units = JOAFormulas.getItem(param, 2);						}					}					if (units.endsWith(" ")) {						units = units.substring(0, units.length() - 1);					}					// param is always first item					param = JOAFormulas.getItem(param, 1);					param = param.trim();					// make sure param is still 4 chars					// param = JOAFormulas.formatParamName(param);					// translate to a JOA parameter name					param = JOAFormulas.paramNameToJOAName(param);					// trim any preceeding blanks from units					while (units.startsWith(" ")) {						String test = new String(units);						units = test.substring(1, test.length());					}					JOAConstants.DELIMITER = oldDelim;					// convert varnames to UC					param = param.toUpperCase();					// create new property					boolean reverse = false;					if (param.endsWith(":R") || param.startsWith("PRES") || param.startsWith("DEPT")) {						reverse = true;						param = param.substring(0, 4);					}					else {						reverse = false;					}					varPos[numVars] = ic;					tempProperties[numVars] = new Parameter(param, units);					tempProperties[numVars].setReverseY(reverse);					tempProperties[numVars].setWasCalculated(false);					if (param.equalsIgnoreCase("PRES") || param.startsWith("DEPT") || param.startsWith("Z")) {						tempProperties[numVars].setActScale(1.0);						tempProperties[numVars].setActOrigin(0.0);					}					numVars++;				}				ic++;			}			// main loop			int bc = 0; // number of bottles read			String oldSecDescrip = new String("");			String oldStn = new String();			double oldLat = JOAConstants.MISSINGVALUE;			double oldLon = JOAConstants.MISSINGVALUE;			String stnNum;			int castNum;			double myLat;			double myLon;			int ord = mFV.getTotalNumStations();			Station sh = null;			Section sech = null;			Section prevsech = null;			boolean newSection = false;			double mMaxDepth = 0.0;			int lineCnt = 1;			while (true) {				inLine = in.readLine();				lineCnt++;				if (inLine == null || inLine.length() < 2) {					break;				}				bytesRead += inLine.length();				progress.setPercentComplete(100.0 * ((double) bytesRead / (double) bytesInFile));				// section name				String sectionDescrip = null;				if (secNamePos != -1) {					sectionDescrip = JOAFormulas.getItem(inLine, secNamePos);				}				else {					sectionDescrip = new String("Untitled");				}				// ship code				String shipCode = null;				if (shipPos != -1) {					shipCode = JOAFormulas.getItem(inLine, shipPos);				}				else {					shipCode = new String("  ");				}				if (!sectionDescrip.equalsIgnoreCase(oldSecDescrip)) {					newSection = true;					// create a new section					prevsech = sech;					of.mNumSections++;					sech = new Section(of.mNumSections, sectionDescrip, shipCode, 0, numVars);					of.addSection(sech);					if (useQCStd) {						sech.setQCStandard(QCStandard);					}					// set the section color					mFV.addToTotalSections();					sech.mSectionColor = JOAFormulas.getSectionColor(mFV.getNumSections());					oldSecDescrip = new String(sectionDescrip);					for (int v = 0; v < numVars; v++) {						sech.addNewVarToSection(tempProperties[v].getVarLabel(), tempProperties[v].getUnits());					}				}				// read the station number				if (stnNumPos != -1) {					stnNum = JOAFormulas.getItem(inLine, stnNumPos);				}				else {					stnNum = JOAFormulas.getItem(inLine, castNumPos);				}				// cast number				if (castNumPos != -1) {					castNum = JOAFormulas.getIntItem(inLine, castNumPos);				}				else {					castNum = 1;				}				// lat				myLat = JOAFormulas.getDoubleItem(inLine, latPos);				// lon				myLon = JOAFormulas.getDoubleItem(inLine, lonPos);				maxLat = myLat > maxLat ? myLat : maxLat;				minLat = myLat < minLat ? myLat : minLat;				// convert all latitudes to the range -360 to 0				double testLon = 0;				if (myLon > 0) {					testLon = myLon /* - 360 */;				}				else {					testLon = myLon;				}				// compute min and max longitude				minLon = testLon < minLon /*-360*/? myLon : minLon;				maxLon = testLon > maxLon /*-360*/? myLon : maxLon;				// date				int year = JOAConstants.MISSINGVALUE;				int month = JOAConstants.MISSINGVALUE;				int day = JOAConstants.MISSINGVALUE;				int hour = JOAConstants.MISSINGVALUE;				double min = JOAConstants.MISSINGVALUE;				if (datePos != -1) {					String sDate = JOAFormulas.getItem(inLine, datePos);					String sTime = null;					// parse the date					// store the current delimiter					char oldDelim = JOAConstants.DELIMITER;					// isolate the date if time is present					if (sDate.indexOf(' ') >= 0) {						JOAConstants.DELIMITER = ' ';						sTime = JOAFormulas.getItem(sDate, 2);						sDate = JOAFormulas.getItem(sDate, 1);					}					// get the date delimiter					if (sDate.indexOf('/') >= 0) {						JOAConstants.DELIMITER = '/';					}					else if (sDate.indexOf('-') >= 0) {						JOAConstants.DELIMITER = '-';					}					// get the day					String sDay;					String sMonth;					String sYear;					try {						sDay = JOAFormulas.getItem(sDate, 2);						day = Integer.valueOf(sDay).intValue();					}					catch (Exception ex) {						FileImportException fie = new FileImportException();						fie.setErrorType("An error occurred parsing day in the date: " + sDate);						fie.setErrorLine(lineCnt);						throw fie;					}					// get the month					try {						sMonth = JOAFormulas.getItem(sDate, 1);						month = Integer.valueOf(sMonth).intValue();					}					catch (Exception ex) {						FileImportException fie = new FileImportException();						fie.setErrorType("An error occurred parsing month in the date: " + sDate);						fie.setErrorLine(lineCnt);						// throw fie;					}					// get the year					try {						sYear = JOAFormulas.getItem(sDate, 3);						year = Integer.valueOf(sYear).intValue();					}					catch (Exception ex) {						FileImportException fie = new FileImportException();						fie.setErrorType("An error occurred parsing year in the date: " + sDate);						fie.setErrorLine(lineCnt);						// throw fie;					}					// test for a time string					if (sTime != null) {						// parse the time						JOAConstants.DELIMITER = ':';						String sHour = JOAFormulas.getItem(sTime, 1);						String sMin = JOAFormulas.getItem(sTime, 2);						hour = Integer.valueOf(sHour).intValue();						min = Double.valueOf(sMin).doubleValue();					}					else {						hour = JOAConstants.MISSINGVALUE;						min = JOAConstants.MISSINGVALUE;					}					// restore the delimiter					JOAConstants.DELIMITER = oldDelim;				}				if (timePos != -1) {					String sTime = JOAFormulas.getItem(inLine, timePos);					// parse the time					// store the current delimiter					char oldDelim = JOAConstants.DELIMITER;					// test for a time string					if (sTime != null) {						// parse the time						JOAConstants.DELIMITER = ':';						String sHour = JOAFormulas.getItem(sTime, 1);						String sMin = JOAFormulas.getItem(sTime, 2);						hour = Integer.valueOf(sHour).intValue();						min = Double.valueOf(sMin).doubleValue();					}					else {						hour = JOAConstants.MISSINGVALUE;						min = JOAConstants.MISSINGVALUE;					}					// restore the delimiter					JOAConstants.DELIMITER = oldDelim;				}				// read bottom				double bottomdbar = JOAConstants.MISSINGVALUE;				if (bottomPos != -1) {					bottomdbar = JOAFormulas.getDoubleItem(inLine, bottomPos);				}				if (!JOAFormulas.isMissing(bottomdbar)) {					mMaxDepth = bottomdbar > mMaxDepth ? bottomdbar : mMaxDepth;				}				else {					bottomdbar = JOAConstants.MISSINGVALUE;				}				if (newSection || !(stnNum.equalsIgnoreCase(oldStn)) || myLat != oldLat || myLon != oldLon) {					// new Station found					if (!newSection && mFV.getTotalNumStations() > 0) {						// New station in this section: store bottle count in previous						// station						Station lastStn = (Station) sech.mStations.lastElement();						lastStn.mNumBottles = lastStn.mBottles.size();					}					else if (prevsech != null && newSection && mFV.getTotalNumStations() > 0) {						// update bottle count in last station of previous sech						Station lastStn = (Station) prevsech.mStations.lastElement();						lastStn.mNumBottles = lastStn.mBottles.size();					}					if (sh != null) {						JOAFormulas.sortBottlesByPres(sech, sh);					}					sech.mNumCasts++;					ord++;					sh = new Station(ord, shipCode, stnNum, castNum, myLat, myLon, 0, year, month, day, hour, min,							(int) bottomdbar, JOAConstants.MISSINGVALUE, null, null);					sech.mStations.addElement(sh);					sh.setType("BOTTLE");					if (datePos == -1) {						sh.mDateError = true;					}					newSection = false;					oldStn = stnNum;					oldLat = myLat;					oldLon = myLon;					bc = 0;					mFV.addToTotalStations(1);				}				mFV.setMaxDepth(mMaxDepth);				// read the bottle data into current station				Bottle bh = new Bottle(bc++, numVars, sh, sech);				int p = 0;				for (int v = 0; v < numVars; v++) {					int pos = varPos[v];					try {						double varVal = JOAFormulas.getDoubleItem(inLine, pos);						if (varVal == JOAConstants.MISSINGVALUE || JOAFormulas.isMissing(varVal)) {							bh.mDValues[v] = JOAConstants.MISSINGVALUE;						}						else {							bh.mDValues[v] = (float) varVal;						}					}					catch (Exception ex) {						System.out.println(inLine + " " + pos);						bh.mDValues[v] = JOAConstants.MISSINGVALUE;					}					// check for max and min					if (bh.mDValues[v] != JOAConstants.MISSINGVALUE) {						if (bh.mDValues[v] < varMin[v]) {							varMin[v] = bh.mDValues[v];						}						if (bh.mDValues[v] > varMax[v]) {							varMax[v] = bh.mDValues[v];						}					}					if (hasQC[v]) {						// read a QC						short qcVal = JOAFormulas.getShortItem(inLine, pos + 1);						if (!JOAFormulas.isMissing(qcVal)) {							bh.mQualityFlags[v] = qcVal;						}						else {							bh.mQualityFlags[v] = (short) JOAConstants.MISSINGVALUE;						}						p += 2;					}					else {						p++;					}				} // for v				sh.mBottles.addElement(bh);			} // while			// store bottle count in last stn of previous section			Section lastSec = (Section) of.mSections.lastElement();			Station lastStn = (Station) lastSec.mStations.lastElement();			lastStn.mNumBottles = lastStn.mBottles.size();			JOAFormulas.sortBottlesByPres(lastSec, lastStn);			// Update Temp Properties			for (int v = 0; v < numVars; v++) {				if (varMin[v] != JOAConstants.MISSINGVALUE && varMin[v] != 32000) {					tempProperties[v].setPlotMin(varMin[v]);				}				if (varMax[v] != JOAConstants.MISSINGVALUE && varMax[v] != -32000) {					tempProperties[v].setPlotMax(varMax[v]);				}			}			// reconcile tempProperties with AllProperties			for (int v = 0; v < numVars; v++) {				int newPos = mFV.getPropertyPos(tempProperties[v].getVarLabel(), false);				if (newPos < 0) {					// variable doesn't exist--check if it's a default property					int d = JOAFormulas.isDefaultVar(tempProperties[v].getVarLabel());					if (d >= 0) {						// is a default--add using default factors						double dfactor = JOAConstants.defaultProperties[d].getActScale();						double offset = JOAConstants.defaultProperties[d].getActOrigin();						tempProperties[v].setActScale(dfactor);						tempProperties[v].setActOrigin(offset);						tempProperties[v].setPlotMin(varMin[v]);						tempProperties[v].setPlotMax(varMax[v]);						newPos = mFV.addNewProperty(tempProperties[v].getVarLabel(), tempProperties[v].getUnits());						if (newPos >= 0) {							mFV.mAllProperties[newPos] = tempProperties[v];						}						else {							; // an unknown error has occurred						}					}					else {						// isn't a default						if (varMax[v] == -32000) {							// all data for this variable are missing							tempProperties[v].setActScale(1.0);							tempProperties[v].setActOrigin(0.0);							tempProperties[v].setPlotMin(0.0);							tempProperties[v].setPlotMax(0.0);						}						else {							double offset = Math.floor(varMin[v]);							double range = varMax[v] - offset;							double factor = (short) (JOAFormulas.log10((double) JOAConstants.TWOBYTES / range));							factor = Math.pow(10, (double) factor);							double dfactor = (double) 1 / (double) factor;							int i = 1;							while (offset / dfactor >= JOAConstants.TWOBYTES /*							 * && offset[v] >							 * 1000							 */) {								// overflow occurred								varMin[v] = varMin[v];								offset = Math.floor(varMin[v] - (10 * i++));								range = varMax[v] - offset;								factor = (short) JOAFormulas.log10((double) JOAConstants.TWOBYTES / range);								factor = Math.pow(10, (double) factor);								dfactor = (double) 1 / (double) factor;							}							// store this in the property array							tempProperties[v].setActScale(dfactor);							tempProperties[v].setActOrigin(offset);							tempProperties[v].setPlotMin(varMin[v]);							tempProperties[v].setPlotMax(varMax[v]);						}						// not a default property--add property						newPos = mFV.addNewProperty(tempProperties[v].getVarLabel(), tempProperties[v].getUnits());						if (newPos >= 0) {							mFV.mAllProperties[newPos] = tempProperties[v];						}						else {							; // an unknown error has occurred						}					}				}				else {					// it does exist--update the parameter ranges					if (tempProperties[v].getPlotMin() < mFV.mAllProperties[newPos].getPlotMin()) {						mFV.mAllProperties[newPos].setPlotMin(tempProperties[v].getPlotMin());					}					if (tempProperties[v].getPlotMax() > mFV.mAllProperties[newPos].getPlotMax()) {						mFV.mAllProperties[newPos].setPlotMax(tempProperties[v].getPlotMax());					}				}			}			/*			 * for (int v=0; v<numVars; v++) { int newPos =			 * getPropertyPos(tempProperties[v].getVarLabel()); if (newPos < 0) { //			 * add new variable to AllProperties newPos =			 * AddNewProperty(tempProperties[v].getVarLabel()); if (newPos >= 0)			 * mAllProperties[newPos] = tempProperties[v]; else ; } else { // it does			 * exist--update the parameter ranges if (tempProperties[v].mPlotMin <			 * mAllProperties[newPos].mPlotMin) {			 * mAllProperties[newPos].setPlotMin(tempProperties[v].mPlotMin; }			 * 			 * if (tempProperties[v].mPlotMax > mAllProperties[newPos].mPlotMax) {			 * mAllProperties[newPos].setPlotMax(tempProperties[v].mPlotMax; } } }			 */		}		catch (Exception ex) {			ex.printStackTrace();			if (ex instanceof FileImportException) {				throw (FileImportException) ex;			}			else {				FileImportException fie = new FileImportException();				fie.setErrorType("An unknown error occurred parsing this file!");				fie.setErrorLine(in.getLineNumber() - 1);				throw (fie);			}		}		finally {			progress.dispose();		}	}	@SuppressWarnings("deprecation")	public static void saveBinary2Data(FileViewer mFV, File file, int whichFile) {		try {			FileOutputStream fos = new FileOutputStream(file);			BufferedOutputStream bos = new BufferedOutputStream(fos, 1000000);			DataOutputStream out = new DataOutputStream(bos);			short vers = 5;			try {				// version number current version is 5				out.writeShort(vers);				String fd = new String();				for (int fc = 0; fc < mFV.getNumOpenFiles(); fc++) {					if (whichFile >= 0 && fc != whichFile) {						continue;					}					OpenDataFile of = mFV.getOpenFile(fc);					fd += of.mName;				}				// determine the number of sections--store valid sections in a vector				Vector<Section> outSections = new Vector<Section>();				int numSections = 0;				for (int fc = 0; fc < mFV.getNumOpenFiles(); fc++) {					if (whichFile >= 0 && fc != whichFile) {						continue;					}					OpenDataFile of = mFV.getOpenFile(fc);					for (int sec = 0; sec < of.mNumSections; sec++) {						Section sech = (Section) of.mSections.elementAt(sec);						// section has to have at least one station not filtered						for (int stc = 0; stc < sech.mStations.size(); stc++) {							Station sh = (Station) sech.mStations.elementAt(stc);							if (!sh.mUseStn) {								continue;							}							else {								outSections.addElement(sech);								numSections++;								break;							}						}					}				}				short ns = (short) numSections;				if (ns < 0) {					// encode the number of sections in the description					fd += ">>>" + String.valueOf(numSections);					JFrame f = new JFrame("Write JOA File Warning");					Toolkit.getDefaultToolkit().beep();					JOptionPane					.showMessageDialog(f,					"The current data set has more than 32768 sections--the resulting file will ony be compatible with JOA 5.0 and above.");				}				// File Description length				out.writeShort(fd.length());				// File Description				out.writeBytes(fd);				if (numSections == 0) {					JFrame f = new JFrame("Write JOA File Error");					Toolkit.getDefaultToolkit().beep();					JOptionPane.showMessageDialog(f, "There are no valid sections in the current data set.");					out.flush();					out.close();					return;				}				// write number of sections				out.writeShort(numSections);				// write the section headers				for (int fc = 0; fc < outSections.size(); fc++) {					Section sech = (Section) outSections.elementAt(fc);					// section name length					out.writeShort(sech.mSectionDescription.length());					// section name					out.writeBytes(sech.mSectionDescription);					// write the ship code					String ship = sech.getShipCode();					if (ship != null && ship.length() > 0) {						out.writeByte(ship.charAt(0));						if (ship.length() > 1) {							out.writeByte(ship.charAt(1));						}						else {							out.writeByte(' ');						}					}					else {						out.writeBytes("un");					}					// compute the number of stations for this section					int castCount = 0;					for (int stc = 0; stc < sech.mStations.size(); stc++) {						Station sh = (Station) sech.mStations.elementAt(stc);						if (sh.mUseStn) {							castCount++;						}					}					// numcasts					if (vers <= 5) {						out.writeShort(castCount);					}					else {						out.writeInt(castCount);					}					// num parameters					out.writeShort(sech.mNumVars);					// quality code standard					out.writeShort(sech.getQCStandard());					// write the variable identifiers					for (int i = 0; i < sech.mNumVars; i++) {						int vPos = mFV.getPropertyPos(sech.mProperties[i], false);						// section param name length						out.writeShort(sech.mProperties[i].length());						// param name						out.writeBytes(sech.mProperties[i]);						/*						 * if (sech.mProperties[i].length() >= 4)						 * out.writeBytes(sech.mProperties[i].substring(0, 4)); else if						 * (sech.mProperties[i].length() < 4) { while						 * (sech.mProperties[i].length() < 4) { sech.mProperties[i] =						 * sech.mProperties[i] + " "; } out.writeBytes(sech.mProperties[i]); }						 */						// units						if (mFV.mAllProperties[vPos].getUnits() != null && mFV.mAllProperties[vPos].getUnits().length() > 0) {							out.writeShort(mFV.mAllProperties[vPos].getUnits().length());							out.writeBytes(mFV.mAllProperties[vPos].getUnits());						}						else {							int unitsLength = 0;							out.writeShort(unitsLength);						}						double scale = mFV.mAllProperties[vPos].getActScale();						double origin = mFV.mAllProperties[vPos].getActOrigin();						int d = JOAFormulas.isDefaultVar(sech.mProperties[i]);						if (d >= 0) {							// is a default--add using default factors							scale = JOAConstants.defaultProperties[d].getActScale();							origin = JOAConstants.defaultProperties[d].getActOrigin();						}						// scale factor						out.writeShort((short) (1.0 / scale));						// origin						out.writeShort((short) (1.0 / origin));						// reverseY						if (mFV.mAllProperties[vPos].isReverseY()) {							out.writeShort(1);						}						else {							out.writeShort(0);						}					}					// write the cast descriptions					for (int stc = 0; stc < sech.mStations.size(); stc++) {						Station sh = (Station) sech.mStations.elementAt(stc);						if (!sh.mUseStn) {							continue;						}						// station number length						out.writeShort(sh.mStnNum.length());						// station number						out.writeBytes(sh.mStnNum);						// cast						out.writeShort(sh.mCastNum);						// lat						out.writeDouble(sh.mLat);						// lon						out.writeDouble(sh.mLon);						// numBottles						out.writeShort(sh.mNumBottles);						// date						out.writeInt(sh.mYear);						out.writeInt(sh.mMonth);						out.writeInt(sh.mDay);						out.writeInt(sh.mHour);						out.writeDouble(sh.mMinute);						// bottom						out.writeInt(sh.mBottomDepthInDBARS);						// station quality flag						out.writeShort(sh.mVarFlag);					}					// write the bottle data					for (int stc = 0; stc < sech.mStations.size(); stc++) {						Station sh = (Station) sech.mStations.elementAt(stc);						if (!sh.mUseStn) {							continue;						}						// write the bottle data and quality flags						for (int b = 0; b < sh.mNumBottles; b++) {							Bottle bh = (Bottle) sh.mBottles.elementAt(b);							// write the bottle quality							short flag = bh.mQualityFlag;							// if (sech.getQCStandard() == JOAConstants.WOCE_QC_STD)							// flag = (short)JOAFormulas.translateWOCEBottleQBToIGOSS(flag);							out.writeShort(flag);							// write the bottle number							int bottleNum = bh.getBottleNum();							out.writeInt(bottleNum);							int numV = sech.mNumVars;							for (int v = 0; v < numV; v++) {								out.writeDouble(bh.mDValues[v]);								flag = bh.mQualityFlags[v];								/*								 * if (sech.getQCStandard() == JOAConstants.WOCE_QC_STD) { if								 * (sh.getType().indexOf("CTD") >= 0) flag =								 * (short)JOAFormulas.translateWOCECTDQBToIGOSS(flag); else flag =								 * (short)JOAFormulas.translateWOCESampleQBToIGOSS(flag); }								 */								out.writeShort(flag);							}						}					}				} // for sech				for (int fc = 0; fc < mFV.getNumOpenFiles(); fc++) {					if (whichFile >= 0 && fc != whichFile) {						continue;					}					OpenDataFile of = mFV.getOpenFile(fc);					// write any file comments					if (of.mFileComments.length() > 0) {						out.writeShort(1);						out.writeShort(of.mFileComments.length());						out.writeBytes(of.mFileComments);					}				}			}			catch (Exception ex) {			}			out.flush();			out.close();			// type the file if on the Mac			if (JOAConstants.ISMAC) {				MRJFileUtils.setFileTypeAndCreator(file, new MRJOSType("ATB2"), new MRJOSType("JOAA"));			}		}		catch (IOException ex) {			System.out.println("An error occured writing a binary file");		}	}}